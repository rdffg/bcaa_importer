// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataAdvice.hxx"

namespace dataadvice
{
  // DataAdvice
  // 

  const DataAdvice::RollYear_type& DataAdvice::
  RollYear () const
  {
    return this->RollYear_.get ();
  }

  DataAdvice::RollYear_type& DataAdvice::
  RollYear ()
  {
    return this->RollYear_.get ();
  }

  void DataAdvice::
  RollYear (const RollYear_type& x)
  {
    this->RollYear_.set (x);
  }

  const DataAdvice::OwnershipYear_type& DataAdvice::
  OwnershipYear () const
  {
    return this->OwnershipYear_.get ();
  }

  DataAdvice::OwnershipYear_type& DataAdvice::
  OwnershipYear ()
  {
    return this->OwnershipYear_.get ();
  }

  void DataAdvice::
  OwnershipYear (const OwnershipYear_type& x)
  {
    this->OwnershipYear_.set (x);
  }

  const DataAdvice::RunType_type& DataAdvice::
  RunType () const
  {
    return this->RunType_.get ();
  }

  DataAdvice::RunType_type& DataAdvice::
  RunType ()
  {
    return this->RunType_.get ();
  }

  void DataAdvice::
  RunType (const RunType_type& x)
  {
    this->RunType_.set (x);
  }

  void DataAdvice::
  RunType (::std::unique_ptr< RunType_type > x)
  {
    this->RunType_.set (std::move (x));
  }

  const DataAdvice::StartDate_type& DataAdvice::
  StartDate () const
  {
    return this->StartDate_.get ();
  }

  DataAdvice::StartDate_type& DataAdvice::
  StartDate ()
  {
    return this->StartDate_.get ();
  }

  void DataAdvice::
  StartDate (const StartDate_type& x)
  {
    this->StartDate_.set (x);
  }

  void DataAdvice::
  StartDate (::std::unique_ptr< StartDate_type > x)
  {
    this->StartDate_.set (std::move (x));
  }

  const DataAdvice::EndDate_type& DataAdvice::
  EndDate () const
  {
    return this->EndDate_.get ();
  }

  DataAdvice::EndDate_type& DataAdvice::
  EndDate ()
  {
    return this->EndDate_.get ();
  }

  void DataAdvice::
  EndDate (const EndDate_type& x)
  {
    this->EndDate_.set (x);
  }

  void DataAdvice::
  EndDate (::std::unique_ptr< EndDate_type > x)
  {
    this->EndDate_.set (std::move (x));
  }

  const DataAdvice::AssessmentAreas_optional& DataAdvice::
  AssessmentAreas () const
  {
    return this->AssessmentAreas_;
  }

  DataAdvice::AssessmentAreas_optional& DataAdvice::
  AssessmentAreas ()
  {
    return this->AssessmentAreas_;
  }

  void DataAdvice::
  AssessmentAreas (const AssessmentAreas_type& x)
  {
    this->AssessmentAreas_.set (x);
  }

  void DataAdvice::
  AssessmentAreas (const AssessmentAreas_optional& x)
  {
    this->AssessmentAreas_ = x;
  }

  void DataAdvice::
  AssessmentAreas (::std::unique_ptr< AssessmentAreas_type > x)
  {
    this->AssessmentAreas_.set (std::move (x));
  }

  const DataAdvice::ReportSummary_optional& DataAdvice::
  ReportSummary () const
  {
    return this->ReportSummary_;
  }

  DataAdvice::ReportSummary_optional& DataAdvice::
  ReportSummary ()
  {
    return this->ReportSummary_;
  }

  void DataAdvice::
  ReportSummary (const ReportSummary_type& x)
  {
    this->ReportSummary_.set (x);
  }

  void DataAdvice::
  ReportSummary (const ReportSummary_optional& x)
  {
    this->ReportSummary_ = x;
  }

  void DataAdvice::
  ReportSummary (::std::unique_ptr< ReportSummary_type > x)
  {
    this->ReportSummary_.set (std::move (x));
  }

  const DataAdvice::Version_type& DataAdvice::
  Version () const
  {
    return this->Version_.get ();
  }

  const DataAdvice::Version_type& DataAdvice::
  Version_default_value ()
  {
    return Version_default_value_;
  }

  const DataAdvice::RequestID_type& DataAdvice::
  RequestID () const
  {
    return this->RequestID_.get ();
  }

  DataAdvice::RequestID_type& DataAdvice::
  RequestID ()
  {
    return this->RequestID_.get ();
  }

  void DataAdvice::
  RequestID (const RequestID_type& x)
  {
    this->RequestID_.set (x);
  }

  void DataAdvice::
  RequestID (::std::unique_ptr< RequestID_type > x)
  {
    this->RequestID_.set (std::move (x));
  }

  const DataAdvice::OrderID_type& DataAdvice::
  OrderID () const
  {
    return this->OrderID_.get ();
  }

  DataAdvice::OrderID_type& DataAdvice::
  OrderID ()
  {
    return this->OrderID_.get ();
  }

  void DataAdvice::
  OrderID (const OrderID_type& x)
  {
    this->OrderID_.set (x);
  }

  void DataAdvice::
  OrderID (::std::unique_ptr< OrderID_type > x)
  {
    this->OrderID_.set (std::move (x));
  }

  const DataAdvice::RunDate_type& DataAdvice::
  RunDate () const
  {
    return this->RunDate_.get ();
  }

  DataAdvice::RunDate_type& DataAdvice::
  RunDate ()
  {
    return this->RunDate_.get ();
  }

  void DataAdvice::
  RunDate (const RunDate_type& x)
  {
    this->RunDate_.set (x);
  }

  void DataAdvice::
  RunDate (::std::unique_ptr< RunDate_type > x)
  {
    this->RunDate_.set (std::move (x));
  }


  // Version
  // 


  // RunType
  // 

  RunType::
  RunType (value v)
  : ::xml_schema::string (_xsd_RunType_literals_[v])
  {
  }

  RunType::
  RunType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  RunType::
  RunType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  RunType::
  RunType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  RunType::
  RunType (const RunType& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  RunType& RunType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_RunType_literals_[v]);

    return *this;
  }


  // DeliverySummary
  // 

  const DeliverySummary::TotalFolioCount_optional& DeliverySummary::
  TotalFolioCount () const
  {
    return this->TotalFolioCount_;
  }

  DeliverySummary::TotalFolioCount_optional& DeliverySummary::
  TotalFolioCount ()
  {
    return this->TotalFolioCount_;
  }

  void DeliverySummary::
  TotalFolioCount (const TotalFolioCount_type& x)
  {
    this->TotalFolioCount_.set (x);
  }

  void DeliverySummary::
  TotalFolioCount (const TotalFolioCount_optional& x)
  {
    this->TotalFolioCount_ = x;
  }

  const DeliverySummary::TaxableFolioCount_optional& DeliverySummary::
  TaxableFolioCount () const
  {
    return this->TaxableFolioCount_;
  }

  DeliverySummary::TaxableFolioCount_optional& DeliverySummary::
  TaxableFolioCount ()
  {
    return this->TaxableFolioCount_;
  }

  void DeliverySummary::
  TaxableFolioCount (const TaxableFolioCount_type& x)
  {
    this->TaxableFolioCount_.set (x);
  }

  void DeliverySummary::
  TaxableFolioCount (const TaxableFolioCount_optional& x)
  {
    this->TaxableFolioCount_ = x;
  }

  const DeliverySummary::TaxExemptFolioCount_optional& DeliverySummary::
  TaxExemptFolioCount () const
  {
    return this->TaxExemptFolioCount_;
  }

  DeliverySummary::TaxExemptFolioCount_optional& DeliverySummary::
  TaxExemptFolioCount ()
  {
    return this->TaxExemptFolioCount_;
  }

  void DeliverySummary::
  TaxExemptFolioCount (const TaxExemptFolioCount_type& x)
  {
    this->TaxExemptFolioCount_.set (x);
  }

  void DeliverySummary::
  TaxExemptFolioCount (const TaxExemptFolioCount_optional& x)
  {
    this->TaxExemptFolioCount_ = x;
  }

  const DeliverySummary::TotalGrossValues_optional& DeliverySummary::
  TotalGrossValues () const
  {
    return this->TotalGrossValues_;
  }

  DeliverySummary::TotalGrossValues_optional& DeliverySummary::
  TotalGrossValues ()
  {
    return this->TotalGrossValues_;
  }

  void DeliverySummary::
  TotalGrossValues (const TotalGrossValues_type& x)
  {
    this->TotalGrossValues_.set (x);
  }

  void DeliverySummary::
  TotalGrossValues (const TotalGrossValues_optional& x)
  {
    this->TotalGrossValues_ = x;
  }

  void DeliverySummary::
  TotalGrossValues (::std::unique_ptr< TotalGrossValues_type > x)
  {
    this->TotalGrossValues_.set (std::move (x));
  }

  const DeliverySummary::TotalTaxExemptValues_optional& DeliverySummary::
  TotalTaxExemptValues () const
  {
    return this->TotalTaxExemptValues_;
  }

  DeliverySummary::TotalTaxExemptValues_optional& DeliverySummary::
  TotalTaxExemptValues ()
  {
    return this->TotalTaxExemptValues_;
  }

  void DeliverySummary::
  TotalTaxExemptValues (const TotalTaxExemptValues_type& x)
  {
    this->TotalTaxExemptValues_.set (x);
  }

  void DeliverySummary::
  TotalTaxExemptValues (const TotalTaxExemptValues_optional& x)
  {
    this->TotalTaxExemptValues_ = x;
  }

  void DeliverySummary::
  TotalTaxExemptValues (::std::unique_ptr< TotalTaxExemptValues_type > x)
  {
    this->TotalTaxExemptValues_.set (std::move (x));
  }

  const DeliverySummary::TotalNetValues_optional& DeliverySummary::
  TotalNetValues () const
  {
    return this->TotalNetValues_;
  }

  DeliverySummary::TotalNetValues_optional& DeliverySummary::
  TotalNetValues ()
  {
    return this->TotalNetValues_;
  }

  void DeliverySummary::
  TotalNetValues (const TotalNetValues_type& x)
  {
    this->TotalNetValues_.set (x);
  }

  void DeliverySummary::
  TotalNetValues (const TotalNetValues_optional& x)
  {
    this->TotalNetValues_ = x;
  }

  void DeliverySummary::
  TotalNetValues (::std::unique_ptr< TotalNetValues_type > x)
  {
    this->TotalNetValues_.set (std::move (x));
  }

  const DeliverySummary::GeneralValues_optional& DeliverySummary::
  GeneralValues () const
  {
    return this->GeneralValues_;
  }

  DeliverySummary::GeneralValues_optional& DeliverySummary::
  GeneralValues ()
  {
    return this->GeneralValues_;
  }

  void DeliverySummary::
  GeneralValues (const GeneralValues_type& x)
  {
    this->GeneralValues_.set (x);
  }

  void DeliverySummary::
  GeneralValues (const GeneralValues_optional& x)
  {
    this->GeneralValues_ = x;
  }

  void DeliverySummary::
  GeneralValues (::std::unique_ptr< GeneralValues_type > x)
  {
    this->GeneralValues_.set (std::move (x));
  }

  const DeliverySummary::BCTransitValues_optional& DeliverySummary::
  BCTransitValues () const
  {
    return this->BCTransitValues_;
  }

  DeliverySummary::BCTransitValues_optional& DeliverySummary::
  BCTransitValues ()
  {
    return this->BCTransitValues_;
  }

  void DeliverySummary::
  BCTransitValues (const BCTransitValues_type& x)
  {
    this->BCTransitValues_.set (x);
  }

  void DeliverySummary::
  BCTransitValues (const BCTransitValues_optional& x)
  {
    this->BCTransitValues_ = x;
  }

  void DeliverySummary::
  BCTransitValues (::std::unique_ptr< BCTransitValues_type > x)
  {
    this->BCTransitValues_.set (std::move (x));
  }

  const DeliverySummary::SchoolValues_optional& DeliverySummary::
  SchoolValues () const
  {
    return this->SchoolValues_;
  }

  DeliverySummary::SchoolValues_optional& DeliverySummary::
  SchoolValues ()
  {
    return this->SchoolValues_;
  }

  void DeliverySummary::
  SchoolValues (const SchoolValues_type& x)
  {
    this->SchoolValues_.set (x);
  }

  void DeliverySummary::
  SchoolValues (const SchoolValues_optional& x)
  {
    this->SchoolValues_ = x;
  }

  void DeliverySummary::
  SchoolValues (::std::unique_ptr< SchoolValues_type > x)
  {
    this->SchoolValues_.set (std::move (x));
  }

  const DeliverySummary::AmendmentReasonCounts_optional& DeliverySummary::
  AmendmentReasonCounts () const
  {
    return this->AmendmentReasonCounts_;
  }

  DeliverySummary::AmendmentReasonCounts_optional& DeliverySummary::
  AmendmentReasonCounts ()
  {
    return this->AmendmentReasonCounts_;
  }

  void DeliverySummary::
  AmendmentReasonCounts (const AmendmentReasonCounts_type& x)
  {
    this->AmendmentReasonCounts_.set (x);
  }

  void DeliverySummary::
  AmendmentReasonCounts (const AmendmentReasonCounts_optional& x)
  {
    this->AmendmentReasonCounts_ = x;
  }

  void DeliverySummary::
  AmendmentReasonCounts (::std::unique_ptr< AmendmentReasonCounts_type > x)
  {
    this->AmendmentReasonCounts_.set (std::move (x));
  }

  const DeliverySummary::DeleteReasonCounts_optional& DeliverySummary::
  DeleteReasonCounts () const
  {
    return this->DeleteReasonCounts_;
  }

  DeliverySummary::DeleteReasonCounts_optional& DeliverySummary::
  DeleteReasonCounts ()
  {
    return this->DeleteReasonCounts_;
  }

  void DeliverySummary::
  DeleteReasonCounts (const DeleteReasonCounts_type& x)
  {
    this->DeleteReasonCounts_.set (x);
  }

  void DeliverySummary::
  DeleteReasonCounts (const DeleteReasonCounts_optional& x)
  {
    this->DeleteReasonCounts_ = x;
  }

  void DeliverySummary::
  DeleteReasonCounts (::std::unique_ptr< DeleteReasonCounts_type > x)
  {
    this->DeleteReasonCounts_.set (std::move (x));
  }


  // AmendmentReasonCountCollection
  // 

  const AmendmentReasonCountCollection::AmendmentReasonCount_sequence& AmendmentReasonCountCollection::
  AmendmentReasonCount () const
  {
    return this->AmendmentReasonCount_;
  }

  AmendmentReasonCountCollection::AmendmentReasonCount_sequence& AmendmentReasonCountCollection::
  AmendmentReasonCount ()
  {
    return this->AmendmentReasonCount_;
  }

  void AmendmentReasonCountCollection::
  AmendmentReasonCount (const AmendmentReasonCount_sequence& s)
  {
    this->AmendmentReasonCount_ = s;
  }


  // AmendmentReasonCount
  // 

  const AmendmentReasonCount::AmendmentReasonCode_type& AmendmentReasonCount::
  AmendmentReasonCode () const
  {
    return this->AmendmentReasonCode_.get ();
  }

  AmendmentReasonCount::AmendmentReasonCode_type& AmendmentReasonCount::
  AmendmentReasonCode ()
  {
    return this->AmendmentReasonCode_.get ();
  }

  void AmendmentReasonCount::
  AmendmentReasonCode (const AmendmentReasonCode_type& x)
  {
    this->AmendmentReasonCode_.set (x);
  }

  void AmendmentReasonCount::
  AmendmentReasonCode (::std::unique_ptr< AmendmentReasonCode_type > x)
  {
    this->AmendmentReasonCode_.set (std::move (x));
  }

  const AmendmentReasonCount::AmendmentReasonDescription_optional& AmendmentReasonCount::
  AmendmentReasonDescription () const
  {
    return this->AmendmentReasonDescription_;
  }

  AmendmentReasonCount::AmendmentReasonDescription_optional& AmendmentReasonCount::
  AmendmentReasonDescription ()
  {
    return this->AmendmentReasonDescription_;
  }

  void AmendmentReasonCount::
  AmendmentReasonDescription (const AmendmentReasonDescription_type& x)
  {
    this->AmendmentReasonDescription_.set (x);
  }

  void AmendmentReasonCount::
  AmendmentReasonDescription (const AmendmentReasonDescription_optional& x)
  {
    this->AmendmentReasonDescription_ = x;
  }

  void AmendmentReasonCount::
  AmendmentReasonDescription (::std::unique_ptr< AmendmentReasonDescription_type > x)
  {
    this->AmendmentReasonDescription_.set (std::move (x));
  }

  const AmendmentReasonCount::FolioCount_type& AmendmentReasonCount::
  FolioCount () const
  {
    return this->FolioCount_.get ();
  }

  AmendmentReasonCount::FolioCount_type& AmendmentReasonCount::
  FolioCount ()
  {
    return this->FolioCount_.get ();
  }

  void AmendmentReasonCount::
  FolioCount (const FolioCount_type& x)
  {
    this->FolioCount_.set (x);
  }


  // DeleteReasonCountCollection
  // 

  const DeleteReasonCountCollection::DeleteReasonCount_sequence& DeleteReasonCountCollection::
  DeleteReasonCount () const
  {
    return this->DeleteReasonCount_;
  }

  DeleteReasonCountCollection::DeleteReasonCount_sequence& DeleteReasonCountCollection::
  DeleteReasonCount ()
  {
    return this->DeleteReasonCount_;
  }

  void DeleteReasonCountCollection::
  DeleteReasonCount (const DeleteReasonCount_sequence& s)
  {
    this->DeleteReasonCount_ = s;
  }


  // DeleteReasonCount
  // 

  const DeleteReasonCount::DeleteReasonCode_type& DeleteReasonCount::
  DeleteReasonCode () const
  {
    return this->DeleteReasonCode_.get ();
  }

  DeleteReasonCount::DeleteReasonCode_type& DeleteReasonCount::
  DeleteReasonCode ()
  {
    return this->DeleteReasonCode_.get ();
  }

  void DeleteReasonCount::
  DeleteReasonCode (const DeleteReasonCode_type& x)
  {
    this->DeleteReasonCode_.set (x);
  }

  void DeleteReasonCount::
  DeleteReasonCode (::std::unique_ptr< DeleteReasonCode_type > x)
  {
    this->DeleteReasonCode_.set (std::move (x));
  }

  const DeleteReasonCount::DeleteReasonDescription_optional& DeleteReasonCount::
  DeleteReasonDescription () const
  {
    return this->DeleteReasonDescription_;
  }

  DeleteReasonCount::DeleteReasonDescription_optional& DeleteReasonCount::
  DeleteReasonDescription ()
  {
    return this->DeleteReasonDescription_;
  }

  void DeleteReasonCount::
  DeleteReasonDescription (const DeleteReasonDescription_type& x)
  {
    this->DeleteReasonDescription_.set (x);
  }

  void DeleteReasonCount::
  DeleteReasonDescription (const DeleteReasonDescription_optional& x)
  {
    this->DeleteReasonDescription_ = x;
  }

  void DeleteReasonCount::
  DeleteReasonDescription (::std::unique_ptr< DeleteReasonDescription_type > x)
  {
    this->DeleteReasonDescription_.set (std::move (x));
  }

  const DeleteReasonCount::FolioCount_type& DeleteReasonCount::
  FolioCount () const
  {
    return this->FolioCount_.get ();
  }

  DeleteReasonCount::FolioCount_type& DeleteReasonCount::
  FolioCount ()
  {
    return this->FolioCount_.get ();
  }

  void DeleteReasonCount::
  FolioCount (const FolioCount_type& x)
  {
    this->FolioCount_.set (x);
  }


  // AssessmentAreaCollection
  // 

  const AssessmentAreaCollection::AssessmentArea_sequence& AssessmentAreaCollection::
  AssessmentArea () const
  {
    return this->AssessmentArea_;
  }

  AssessmentAreaCollection::AssessmentArea_sequence& AssessmentAreaCollection::
  AssessmentArea ()
  {
    return this->AssessmentArea_;
  }

  void AssessmentAreaCollection::
  AssessmentArea (const AssessmentArea_sequence& s)
  {
    this->AssessmentArea_ = s;
  }


  // AssessmentArea
  // 

  const AssessmentArea::AssessmentAreaCode_type& AssessmentArea::
  AssessmentAreaCode () const
  {
    return this->AssessmentAreaCode_.get ();
  }

  AssessmentArea::AssessmentAreaCode_type& AssessmentArea::
  AssessmentAreaCode ()
  {
    return this->AssessmentAreaCode_.get ();
  }

  void AssessmentArea::
  AssessmentAreaCode (const AssessmentAreaCode_type& x)
  {
    this->AssessmentAreaCode_.set (x);
  }

  void AssessmentArea::
  AssessmentAreaCode (::std::unique_ptr< AssessmentAreaCode_type > x)
  {
    this->AssessmentAreaCode_.set (std::move (x));
  }

  const AssessmentArea::AssessmentAreaDescription_optional& AssessmentArea::
  AssessmentAreaDescription () const
  {
    return this->AssessmentAreaDescription_;
  }

  AssessmentArea::AssessmentAreaDescription_optional& AssessmentArea::
  AssessmentAreaDescription ()
  {
    return this->AssessmentAreaDescription_;
  }

  void AssessmentArea::
  AssessmentAreaDescription (const AssessmentAreaDescription_type& x)
  {
    this->AssessmentAreaDescription_.set (x);
  }

  void AssessmentArea::
  AssessmentAreaDescription (const AssessmentAreaDescription_optional& x)
  {
    this->AssessmentAreaDescription_ = x;
  }

  void AssessmentArea::
  AssessmentAreaDescription (::std::unique_ptr< AssessmentAreaDescription_type > x)
  {
    this->AssessmentAreaDescription_.set (std::move (x));
  }

  const AssessmentArea::Jurisdictions_optional& AssessmentArea::
  Jurisdictions () const
  {
    return this->Jurisdictions_;
  }

  AssessmentArea::Jurisdictions_optional& AssessmentArea::
  Jurisdictions ()
  {
    return this->Jurisdictions_;
  }

  void AssessmentArea::
  Jurisdictions (const Jurisdictions_type& x)
  {
    this->Jurisdictions_.set (x);
  }

  void AssessmentArea::
  Jurisdictions (const Jurisdictions_optional& x)
  {
    this->Jurisdictions_ = x;
  }

  void AssessmentArea::
  Jurisdictions (::std::unique_ptr< Jurisdictions_type > x)
  {
    this->Jurisdictions_.set (std::move (x));
  }

  const AssessmentArea::AreaSummary_optional& AssessmentArea::
  AreaSummary () const
  {
    return this->AreaSummary_;
  }

  AssessmentArea::AreaSummary_optional& AssessmentArea::
  AreaSummary ()
  {
    return this->AreaSummary_;
  }

  void AssessmentArea::
  AreaSummary (const AreaSummary_type& x)
  {
    this->AreaSummary_.set (x);
  }

  void AssessmentArea::
  AreaSummary (const AreaSummary_optional& x)
  {
    this->AreaSummary_ = x;
  }

  void AssessmentArea::
  AreaSummary (::std::unique_ptr< AreaSummary_type > x)
  {
    this->AreaSummary_.set (std::move (x));
  }


  // AssessmentAreaCode
  // 


  // JurisdictionCollection
  // 

  const JurisdictionCollection::Jurisdiction_sequence& JurisdictionCollection::
  Jurisdiction () const
  {
    return this->Jurisdiction_;
  }

  JurisdictionCollection::Jurisdiction_sequence& JurisdictionCollection::
  Jurisdiction ()
  {
    return this->Jurisdiction_;
  }

  void JurisdictionCollection::
  Jurisdiction (const Jurisdiction_sequence& s)
  {
    this->Jurisdiction_ = s;
  }


  // Jurisdiction
  // 

  const Jurisdiction::JurisdictionCode_type& Jurisdiction::
  JurisdictionCode () const
  {
    return this->JurisdictionCode_.get ();
  }

  Jurisdiction::JurisdictionCode_type& Jurisdiction::
  JurisdictionCode ()
  {
    return this->JurisdictionCode_.get ();
  }

  void Jurisdiction::
  JurisdictionCode (const JurisdictionCode_type& x)
  {
    this->JurisdictionCode_.set (x);
  }

  void Jurisdiction::
  JurisdictionCode (::std::unique_ptr< JurisdictionCode_type > x)
  {
    this->JurisdictionCode_.set (std::move (x));
  }

  const Jurisdiction::JurisdictionDescription_optional& Jurisdiction::
  JurisdictionDescription () const
  {
    return this->JurisdictionDescription_;
  }

  Jurisdiction::JurisdictionDescription_optional& Jurisdiction::
  JurisdictionDescription ()
  {
    return this->JurisdictionDescription_;
  }

  void Jurisdiction::
  JurisdictionDescription (const JurisdictionDescription_type& x)
  {
    this->JurisdictionDescription_.set (x);
  }

  void Jurisdiction::
  JurisdictionDescription (const JurisdictionDescription_optional& x)
  {
    this->JurisdictionDescription_ = x;
  }

  void Jurisdiction::
  JurisdictionDescription (::std::unique_ptr< JurisdictionDescription_type > x)
  {
    this->JurisdictionDescription_.set (std::move (x));
  }

  const Jurisdiction::FolioRecords_optional& Jurisdiction::
  FolioRecords () const
  {
    return this->FolioRecords_;
  }

  Jurisdiction::FolioRecords_optional& Jurisdiction::
  FolioRecords ()
  {
    return this->FolioRecords_;
  }

  void Jurisdiction::
  FolioRecords (const FolioRecords_type& x)
  {
    this->FolioRecords_.set (x);
  }

  void Jurisdiction::
  FolioRecords (const FolioRecords_optional& x)
  {
    this->FolioRecords_ = x;
  }

  void Jurisdiction::
  FolioRecords (::std::unique_ptr< FolioRecords_type > x)
  {
    this->FolioRecords_.set (std::move (x));
  }

  const Jurisdiction::JurisdictionSummary_optional& Jurisdiction::
  JurisdictionSummary () const
  {
    return this->JurisdictionSummary_;
  }

  Jurisdiction::JurisdictionSummary_optional& Jurisdiction::
  JurisdictionSummary ()
  {
    return this->JurisdictionSummary_;
  }

  void Jurisdiction::
  JurisdictionSummary (const JurisdictionSummary_type& x)
  {
    this->JurisdictionSummary_.set (x);
  }

  void Jurisdiction::
  JurisdictionSummary (const JurisdictionSummary_optional& x)
  {
    this->JurisdictionSummary_ = x;
  }

  void Jurisdiction::
  JurisdictionSummary (::std::unique_ptr< JurisdictionSummary_type > x)
  {
    this->JurisdictionSummary_.set (std::move (x));
  }


  // JurisdictionCode
  // 


  // FolioGroupValues
  // 

  const FolioGroupValues::LandValue_type& FolioGroupValues::
  LandValue () const
  {
    return this->LandValue_.get ();
  }

  FolioGroupValues::LandValue_type& FolioGroupValues::
  LandValue ()
  {
    return this->LandValue_.get ();
  }

  void FolioGroupValues::
  LandValue (const LandValue_type& x)
  {
    this->LandValue_.set (x);
  }

  const FolioGroupValues::ImprovementValue_type& FolioGroupValues::
  ImprovementValue () const
  {
    return this->ImprovementValue_.get ();
  }

  FolioGroupValues::ImprovementValue_type& FolioGroupValues::
  ImprovementValue ()
  {
    return this->ImprovementValue_.get ();
  }

  void FolioGroupValues::
  ImprovementValue (const ImprovementValue_type& x)
  {
    this->ImprovementValue_.set (x);
  }

  const FolioGroupValues::ParkingAreaValue_optional& FolioGroupValues::
  ParkingAreaValue () const
  {
    return this->ParkingAreaValue_;
  }

  FolioGroupValues::ParkingAreaValue_optional& FolioGroupValues::
  ParkingAreaValue ()
  {
    return this->ParkingAreaValue_;
  }

  void FolioGroupValues::
  ParkingAreaValue (const ParkingAreaValue_type& x)
  {
    this->ParkingAreaValue_.set (x);
  }

  void FolioGroupValues::
  ParkingAreaValue (const ParkingAreaValue_optional& x)
  {
    this->ParkingAreaValue_ = x;
  }


  // FolioRecordCollection
  // 

  const FolioRecordCollection::FolioRecord_sequence& FolioRecordCollection::
  FolioRecord () const
  {
    return this->FolioRecord_;
  }

  FolioRecordCollection::FolioRecord_sequence& FolioRecordCollection::
  FolioRecord ()
  {
    return this->FolioRecord_;
  }

  void FolioRecordCollection::
  FolioRecord (const FolioRecord_sequence& s)
  {
    this->FolioRecord_ = s;
  }


  // FolioRecord
  // 

  const FolioRecord::RollNumber_type& FolioRecord::
  RollNumber () const
  {
    return this->RollNumber_.get ();
  }

  FolioRecord::RollNumber_type& FolioRecord::
  RollNumber ()
  {
    return this->RollNumber_.get ();
  }

  void FolioRecord::
  RollNumber (const RollNumber_type& x)
  {
    this->RollNumber_.set (x);
  }

  void FolioRecord::
  RollNumber (::std::unique_ptr< RollNumber_type > x)
  {
    this->RollNumber_.set (std::move (x));
  }

  const FolioRecord::FolioStatus_optional& FolioRecord::
  FolioStatus () const
  {
    return this->FolioStatus_;
  }

  FolioRecord::FolioStatus_optional& FolioRecord::
  FolioStatus ()
  {
    return this->FolioStatus_;
  }

  void FolioRecord::
  FolioStatus (const FolioStatus_type& x)
  {
    this->FolioStatus_.set (x);
  }

  void FolioRecord::
  FolioStatus (const FolioStatus_optional& x)
  {
    this->FolioStatus_ = x;
  }

  void FolioRecord::
  FolioStatus (::std::unique_ptr< FolioStatus_type > x)
  {
    this->FolioStatus_.set (std::move (x));
  }

  const FolioRecord::FolioStatusDescription_optional& FolioRecord::
  FolioStatusDescription () const
  {
    return this->FolioStatusDescription_;
  }

  FolioRecord::FolioStatusDescription_optional& FolioRecord::
  FolioStatusDescription ()
  {
    return this->FolioStatusDescription_;
  }

  void FolioRecord::
  FolioStatusDescription (const FolioStatusDescription_type& x)
  {
    this->FolioStatusDescription_.set (x);
  }

  void FolioRecord::
  FolioStatusDescription (const FolioStatusDescription_optional& x)
  {
    this->FolioStatusDescription_ = x;
  }

  void FolioRecord::
  FolioStatusDescription (::std::unique_ptr< FolioStatusDescription_type > x)
  {
    this->FolioStatusDescription_.set (std::move (x));
  }

  const FolioRecord::FolioAction_optional& FolioRecord::
  FolioAction () const
  {
    return this->FolioAction_;
  }

  FolioRecord::FolioAction_optional& FolioRecord::
  FolioAction ()
  {
    return this->FolioAction_;
  }

  void FolioRecord::
  FolioAction (const FolioAction_type& x)
  {
    this->FolioAction_.set (x);
  }

  void FolioRecord::
  FolioAction (const FolioAction_optional& x)
  {
    this->FolioAction_ = x;
  }

  void FolioRecord::
  FolioAction (::std::unique_ptr< FolioAction_type > x)
  {
    this->FolioAction_.set (std::move (x));
  }

  const FolioRecord::FolioAddresses_optional& FolioRecord::
  FolioAddresses () const
  {
    return this->FolioAddresses_;
  }

  FolioRecord::FolioAddresses_optional& FolioRecord::
  FolioAddresses ()
  {
    return this->FolioAddresses_;
  }

  void FolioRecord::
  FolioAddresses (const FolioAddresses_type& x)
  {
    this->FolioAddresses_.set (x);
  }

  void FolioRecord::
  FolioAddresses (const FolioAddresses_optional& x)
  {
    this->FolioAddresses_ = x;
  }

  void FolioRecord::
  FolioAddresses (::std::unique_ptr< FolioAddresses_type > x)
  {
    this->FolioAddresses_.set (std::move (x));
  }

  const FolioRecord::OwnershipGroups_optional& FolioRecord::
  OwnershipGroups () const
  {
    return this->OwnershipGroups_;
  }

  FolioRecord::OwnershipGroups_optional& FolioRecord::
  OwnershipGroups ()
  {
    return this->OwnershipGroups_;
  }

  void FolioRecord::
  OwnershipGroups (const OwnershipGroups_type& x)
  {
    this->OwnershipGroups_.set (x);
  }

  void FolioRecord::
  OwnershipGroups (const OwnershipGroups_optional& x)
  {
    this->OwnershipGroups_ = x;
  }

  void FolioRecord::
  OwnershipGroups (::std::unique_ptr< OwnershipGroups_type > x)
  {
    this->OwnershipGroups_.set (std::move (x));
  }

  const FolioRecord::LegalDescriptions_optional& FolioRecord::
  LegalDescriptions () const
  {
    return this->LegalDescriptions_;
  }

  FolioRecord::LegalDescriptions_optional& FolioRecord::
  LegalDescriptions ()
  {
    return this->LegalDescriptions_;
  }

  void FolioRecord::
  LegalDescriptions (const LegalDescriptions_type& x)
  {
    this->LegalDescriptions_.set (x);
  }

  void FolioRecord::
  LegalDescriptions (const LegalDescriptions_optional& x)
  {
    this->LegalDescriptions_ = x;
  }

  void FolioRecord::
  LegalDescriptions (::std::unique_ptr< LegalDescriptions_type > x)
  {
    this->LegalDescriptions_.set (std::move (x));
  }

  const FolioRecord::FolioDescription_optional& FolioRecord::
  FolioDescription () const
  {
    return this->FolioDescription_;
  }

  FolioRecord::FolioDescription_optional& FolioRecord::
  FolioDescription ()
  {
    return this->FolioDescription_;
  }

  void FolioRecord::
  FolioDescription (const FolioDescription_type& x)
  {
    this->FolioDescription_.set (x);
  }

  void FolioRecord::
  FolioDescription (const FolioDescription_optional& x)
  {
    this->FolioDescription_ = x;
  }

  void FolioRecord::
  FolioDescription (::std::unique_ptr< FolioDescription_type > x)
  {
    this->FolioDescription_.set (std::move (x));
  }

  const FolioRecord::Sales_optional& FolioRecord::
  Sales () const
  {
    return this->Sales_;
  }

  FolioRecord::Sales_optional& FolioRecord::
  Sales ()
  {
    return this->Sales_;
  }

  void FolioRecord::
  Sales (const Sales_type& x)
  {
    this->Sales_.set (x);
  }

  void FolioRecord::
  Sales (const Sales_optional& x)
  {
    this->Sales_ = x;
  }

  void FolioRecord::
  Sales (::std::unique_ptr< Sales_type > x)
  {
    this->Sales_.set (std::move (x));
  }

  const FolioRecord::Values_optional& FolioRecord::
  Values () const
  {
    return this->Values_;
  }

  FolioRecord::Values_optional& FolioRecord::
  Values ()
  {
    return this->Values_;
  }

  void FolioRecord::
  Values (const Values_type& x)
  {
    this->Values_.set (x);
  }

  void FolioRecord::
  Values (const Values_optional& x)
  {
    this->Values_ = x;
  }

  void FolioRecord::
  Values (::std::unique_ptr< Values_type > x)
  {
    this->Values_.set (std::move (x));
  }

  const FolioRecord::Amendments_optional& FolioRecord::
  Amendments () const
  {
    return this->Amendments_;
  }

  FolioRecord::Amendments_optional& FolioRecord::
  Amendments ()
  {
    return this->Amendments_;
  }

  void FolioRecord::
  Amendments (const Amendments_type& x)
  {
    this->Amendments_.set (x);
  }

  void FolioRecord::
  Amendments (const Amendments_optional& x)
  {
    this->Amendments_ = x;
  }

  void FolioRecord::
  Amendments (::std::unique_ptr< Amendments_type > x)
  {
    this->Amendments_.set (std::move (x));
  }

  const FolioRecord::MinorTaxing_optional& FolioRecord::
  MinorTaxing () const
  {
    return this->MinorTaxing_;
  }

  FolioRecord::MinorTaxing_optional& FolioRecord::
  MinorTaxing ()
  {
    return this->MinorTaxing_;
  }

  void FolioRecord::
  MinorTaxing (const MinorTaxing_type& x)
  {
    this->MinorTaxing_.set (x);
  }

  void FolioRecord::
  MinorTaxing (const MinorTaxing_optional& x)
  {
    this->MinorTaxing_ = x;
  }

  void FolioRecord::
  MinorTaxing (::std::unique_ptr< MinorTaxing_type > x)
  {
    this->MinorTaxing_.set (std::move (x));
  }

  const FolioRecord::Farms_optional& FolioRecord::
  Farms () const
  {
    return this->Farms_;
  }

  FolioRecord::Farms_optional& FolioRecord::
  Farms ()
  {
    return this->Farms_;
  }

  void FolioRecord::
  Farms (const Farms_type& x)
  {
    this->Farms_.set (x);
  }

  void FolioRecord::
  Farms (const Farms_optional& x)
  {
    this->Farms_ = x;
  }

  void FolioRecord::
  Farms (::std::unique_ptr< Farms_type > x)
  {
    this->Farms_.set (std::move (x));
  }

  const FolioRecord::ManufacturedHomes_optional& FolioRecord::
  ManufacturedHomes () const
  {
    return this->ManufacturedHomes_;
  }

  FolioRecord::ManufacturedHomes_optional& FolioRecord::
  ManufacturedHomes ()
  {
    return this->ManufacturedHomes_;
  }

  void FolioRecord::
  ManufacturedHomes (const ManufacturedHomes_type& x)
  {
    this->ManufacturedHomes_.set (x);
  }

  void FolioRecord::
  ManufacturedHomes (const ManufacturedHomes_optional& x)
  {
    this->ManufacturedHomes_ = x;
  }

  void FolioRecord::
  ManufacturedHomes (::std::unique_ptr< ManufacturedHomes_type > x)
  {
    this->ManufacturedHomes_.set (std::move (x));
  }

  const FolioRecord::ManagedForests_optional& FolioRecord::
  ManagedForests () const
  {
    return this->ManagedForests_;
  }

  FolioRecord::ManagedForests_optional& FolioRecord::
  ManagedForests ()
  {
    return this->ManagedForests_;
  }

  void FolioRecord::
  ManagedForests (const ManagedForests_type& x)
  {
    this->ManagedForests_.set (x);
  }

  void FolioRecord::
  ManagedForests (const ManagedForests_optional& x)
  {
    this->ManagedForests_ = x;
  }

  void FolioRecord::
  ManagedForests (::std::unique_ptr< ManagedForests_type > x)
  {
    this->ManagedForests_.set (std::move (x));
  }

  const FolioRecord::OilAndGas_optional& FolioRecord::
  OilAndGas () const
  {
    return this->OilAndGas_;
  }

  FolioRecord::OilAndGas_optional& FolioRecord::
  OilAndGas ()
  {
    return this->OilAndGas_;
  }

  void FolioRecord::
  OilAndGas (const OilAndGas_type& x)
  {
    this->OilAndGas_.set (x);
  }

  void FolioRecord::
  OilAndGas (const OilAndGas_optional& x)
  {
    this->OilAndGas_ = x;
  }

  void FolioRecord::
  OilAndGas (::std::unique_ptr< OilAndGas_type > x)
  {
    this->OilAndGas_.set (std::move (x));
  }

  const FolioRecord::LandCharacteristics_optional& FolioRecord::
  LandCharacteristics () const
  {
    return this->LandCharacteristics_;
  }

  FolioRecord::LandCharacteristics_optional& FolioRecord::
  LandCharacteristics ()
  {
    return this->LandCharacteristics_;
  }

  void FolioRecord::
  LandCharacteristics (const LandCharacteristics_type& x)
  {
    this->LandCharacteristics_.set (x);
  }

  void FolioRecord::
  LandCharacteristics (const LandCharacteristics_optional& x)
  {
    this->LandCharacteristics_ = x;
  }

  void FolioRecord::
  LandCharacteristics (::std::unique_ptr< LandCharacteristics_type > x)
  {
    this->LandCharacteristics_.set (std::move (x));
  }


  // String32
  // 


  // FolioRollNumber
  // 

  const FolioRollNumber::Action_optional& FolioRollNumber::
  Action () const
  {
    return this->Action_;
  }

  FolioRollNumber::Action_optional& FolioRollNumber::
  Action ()
  {
    return this->Action_;
  }

  void FolioRollNumber::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioRollNumber::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioRollNumber::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioRollNumber::OldValue_optional& FolioRollNumber::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioRollNumber::OldValue_optional& FolioRollNumber::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioRollNumber::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioRollNumber::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioRollNumber::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // FolioAction
  // 

  const FolioAction::FolioAdd_optional& FolioAction::
  FolioAdd () const
  {
    return this->FolioAdd_;
  }

  FolioAction::FolioAdd_optional& FolioAction::
  FolioAdd ()
  {
    return this->FolioAdd_;
  }

  void FolioAction::
  FolioAdd (const FolioAdd_type& x)
  {
    this->FolioAdd_.set (x);
  }

  void FolioAction::
  FolioAdd (const FolioAdd_optional& x)
  {
    this->FolioAdd_ = x;
  }

  void FolioAction::
  FolioAdd (::std::unique_ptr< FolioAdd_type > x)
  {
    this->FolioAdd_.set (std::move (x));
  }

  const FolioAction::FolioDelete_optional& FolioAction::
  FolioDelete () const
  {
    return this->FolioDelete_;
  }

  FolioAction::FolioDelete_optional& FolioAction::
  FolioDelete ()
  {
    return this->FolioDelete_;
  }

  void FolioAction::
  FolioDelete (const FolioDelete_type& x)
  {
    this->FolioDelete_.set (x);
  }

  void FolioAction::
  FolioDelete (const FolioDelete_optional& x)
  {
    this->FolioDelete_ = x;
  }

  void FolioAction::
  FolioDelete (::std::unique_ptr< FolioDelete_type > x)
  {
    this->FolioDelete_.set (std::move (x));
  }


  // FolioAdd
  // 

  const FolioAdd::FolioRenumber_optional& FolioAdd::
  FolioRenumber () const
  {
    return this->FolioRenumber_;
  }

  FolioAdd::FolioRenumber_optional& FolioAdd::
  FolioRenumber ()
  {
    return this->FolioRenumber_;
  }

  void FolioAdd::
  FolioRenumber (const FolioRenumber_type& x)
  {
    this->FolioRenumber_.set (x);
  }

  void FolioAdd::
  FolioRenumber (const FolioRenumber_optional& x)
  {
    this->FolioRenumber_ = x;
  }

  void FolioAdd::
  FolioRenumber (::std::unique_ptr< FolioRenumber_type > x)
  {
    this->FolioRenumber_.set (std::move (x));
  }


  // FolioDelete
  // 

  const FolioDelete::FolioRenumber_optional& FolioDelete::
  FolioRenumber () const
  {
    return this->FolioRenumber_;
  }

  FolioDelete::FolioRenumber_optional& FolioDelete::
  FolioRenumber ()
  {
    return this->FolioRenumber_;
  }

  void FolioDelete::
  FolioRenumber (const FolioRenumber_type& x)
  {
    this->FolioRenumber_.set (x);
  }

  void FolioDelete::
  FolioRenumber (const FolioRenumber_optional& x)
  {
    this->FolioRenumber_ = x;
  }

  void FolioDelete::
  FolioRenumber (::std::unique_ptr< FolioRenumber_type > x)
  {
    this->FolioRenumber_.set (std::move (x));
  }

  const FolioDelete::DeleteReasonCode_optional& FolioDelete::
  DeleteReasonCode () const
  {
    return this->DeleteReasonCode_;
  }

  FolioDelete::DeleteReasonCode_optional& FolioDelete::
  DeleteReasonCode ()
  {
    return this->DeleteReasonCode_;
  }

  void FolioDelete::
  DeleteReasonCode (const DeleteReasonCode_type& x)
  {
    this->DeleteReasonCode_.set (x);
  }

  void FolioDelete::
  DeleteReasonCode (const DeleteReasonCode_optional& x)
  {
    this->DeleteReasonCode_ = x;
  }

  void FolioDelete::
  DeleteReasonCode (::std::unique_ptr< DeleteReasonCode_type > x)
  {
    this->DeleteReasonCode_.set (std::move (x));
  }

  const FolioDelete::DeleteReasonDescription_optional& FolioDelete::
  DeleteReasonDescription () const
  {
    return this->DeleteReasonDescription_;
  }

  FolioDelete::DeleteReasonDescription_optional& FolioDelete::
  DeleteReasonDescription ()
  {
    return this->DeleteReasonDescription_;
  }

  void FolioDelete::
  DeleteReasonDescription (const DeleteReasonDescription_type& x)
  {
    this->DeleteReasonDescription_.set (x);
  }

  void FolioDelete::
  DeleteReasonDescription (const DeleteReasonDescription_optional& x)
  {
    this->DeleteReasonDescription_ = x;
  }

  void FolioDelete::
  DeleteReasonDescription (::std::unique_ptr< DeleteReasonDescription_type > x)
  {
    this->DeleteReasonDescription_.set (std::move (x));
  }


  // FolioRenumber
  // 

  const FolioRenumber::AssessmentAreaCode_type& FolioRenumber::
  AssessmentAreaCode () const
  {
    return this->AssessmentAreaCode_.get ();
  }

  FolioRenumber::AssessmentAreaCode_type& FolioRenumber::
  AssessmentAreaCode ()
  {
    return this->AssessmentAreaCode_.get ();
  }

  void FolioRenumber::
  AssessmentAreaCode (const AssessmentAreaCode_type& x)
  {
    this->AssessmentAreaCode_.set (x);
  }

  void FolioRenumber::
  AssessmentAreaCode (::std::unique_ptr< AssessmentAreaCode_type > x)
  {
    this->AssessmentAreaCode_.set (std::move (x));
  }

  const FolioRenumber::AssessmentAreaDescription_optional& FolioRenumber::
  AssessmentAreaDescription () const
  {
    return this->AssessmentAreaDescription_;
  }

  FolioRenumber::AssessmentAreaDescription_optional& FolioRenumber::
  AssessmentAreaDescription ()
  {
    return this->AssessmentAreaDescription_;
  }

  void FolioRenumber::
  AssessmentAreaDescription (const AssessmentAreaDescription_type& x)
  {
    this->AssessmentAreaDescription_.set (x);
  }

  void FolioRenumber::
  AssessmentAreaDescription (const AssessmentAreaDescription_optional& x)
  {
    this->AssessmentAreaDescription_ = x;
  }

  void FolioRenumber::
  AssessmentAreaDescription (::std::unique_ptr< AssessmentAreaDescription_type > x)
  {
    this->AssessmentAreaDescription_.set (std::move (x));
  }

  const FolioRenumber::JurisdictionCode_type& FolioRenumber::
  JurisdictionCode () const
  {
    return this->JurisdictionCode_.get ();
  }

  FolioRenumber::JurisdictionCode_type& FolioRenumber::
  JurisdictionCode ()
  {
    return this->JurisdictionCode_.get ();
  }

  void FolioRenumber::
  JurisdictionCode (const JurisdictionCode_type& x)
  {
    this->JurisdictionCode_.set (x);
  }

  void FolioRenumber::
  JurisdictionCode (::std::unique_ptr< JurisdictionCode_type > x)
  {
    this->JurisdictionCode_.set (std::move (x));
  }

  const FolioRenumber::JurisdictionDescription_optional& FolioRenumber::
  JurisdictionDescription () const
  {
    return this->JurisdictionDescription_;
  }

  FolioRenumber::JurisdictionDescription_optional& FolioRenumber::
  JurisdictionDescription ()
  {
    return this->JurisdictionDescription_;
  }

  void FolioRenumber::
  JurisdictionDescription (const JurisdictionDescription_type& x)
  {
    this->JurisdictionDescription_.set (x);
  }

  void FolioRenumber::
  JurisdictionDescription (const JurisdictionDescription_optional& x)
  {
    this->JurisdictionDescription_ = x;
  }

  void FolioRenumber::
  JurisdictionDescription (::std::unique_ptr< JurisdictionDescription_type > x)
  {
    this->JurisdictionDescription_.set (std::move (x));
  }

  const FolioRenumber::RollNumber_type& FolioRenumber::
  RollNumber () const
  {
    return this->RollNumber_.get ();
  }

  FolioRenumber::RollNumber_type& FolioRenumber::
  RollNumber ()
  {
    return this->RollNumber_.get ();
  }

  void FolioRenumber::
  RollNumber (const RollNumber_type& x)
  {
    this->RollNumber_.set (x);
  }

  void FolioRenumber::
  RollNumber (::std::unique_ptr< RollNumber_type > x)
  {
    this->RollNumber_.set (std::move (x));
  }


  // FolioItemGroup
  // 

  const FolioItemGroup::Action_optional& FolioItemGroup::
  Action () const
  {
    return this->Action_;
  }

  FolioItemGroup::Action_optional& FolioItemGroup::
  Action ()
  {
    return this->Action_;
  }

  void FolioItemGroup::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioItemGroup::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioItemGroup::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }


  // FolioAddressCollection
  // 

  const FolioAddressCollection::FolioAddress_sequence& FolioAddressCollection::
  FolioAddress () const
  {
    return this->FolioAddress_;
  }

  FolioAddressCollection::FolioAddress_sequence& FolioAddressCollection::
  FolioAddress ()
  {
    return this->FolioAddress_;
  }

  void FolioAddressCollection::
  FolioAddress (const FolioAddress_sequence& s)
  {
    this->FolioAddress_ = s;
  }


  // FolioAddress
  // 

  const FolioAddress::PrimaryFlag_optional& FolioAddress::
  PrimaryFlag () const
  {
    return this->PrimaryFlag_;
  }

  FolioAddress::PrimaryFlag_optional& FolioAddress::
  PrimaryFlag ()
  {
    return this->PrimaryFlag_;
  }

  void FolioAddress::
  PrimaryFlag (const PrimaryFlag_type& x)
  {
    this->PrimaryFlag_.set (x);
  }

  void FolioAddress::
  PrimaryFlag (const PrimaryFlag_optional& x)
  {
    this->PrimaryFlag_ = x;
  }

  void FolioAddress::
  PrimaryFlag (::std::unique_ptr< PrimaryFlag_type > x)
  {
    this->PrimaryFlag_.set (std::move (x));
  }

  const FolioAddress::UnitNumber_optional& FolioAddress::
  UnitNumber () const
  {
    return this->UnitNumber_;
  }

  FolioAddress::UnitNumber_optional& FolioAddress::
  UnitNumber ()
  {
    return this->UnitNumber_;
  }

  void FolioAddress::
  UnitNumber (const UnitNumber_type& x)
  {
    this->UnitNumber_.set (x);
  }

  void FolioAddress::
  UnitNumber (const UnitNumber_optional& x)
  {
    this->UnitNumber_ = x;
  }

  void FolioAddress::
  UnitNumber (::std::unique_ptr< UnitNumber_type > x)
  {
    this->UnitNumber_.set (std::move (x));
  }

  const FolioAddress::StreetNumber_optional& FolioAddress::
  StreetNumber () const
  {
    return this->StreetNumber_;
  }

  FolioAddress::StreetNumber_optional& FolioAddress::
  StreetNumber ()
  {
    return this->StreetNumber_;
  }

  void FolioAddress::
  StreetNumber (const StreetNumber_type& x)
  {
    this->StreetNumber_.set (x);
  }

  void FolioAddress::
  StreetNumber (const StreetNumber_optional& x)
  {
    this->StreetNumber_ = x;
  }

  void FolioAddress::
  StreetNumber (::std::unique_ptr< StreetNumber_type > x)
  {
    this->StreetNumber_.set (std::move (x));
  }

  const FolioAddress::StreetDirectionPrefix_optional& FolioAddress::
  StreetDirectionPrefix () const
  {
    return this->StreetDirectionPrefix_;
  }

  FolioAddress::StreetDirectionPrefix_optional& FolioAddress::
  StreetDirectionPrefix ()
  {
    return this->StreetDirectionPrefix_;
  }

  void FolioAddress::
  StreetDirectionPrefix (const StreetDirectionPrefix_type& x)
  {
    this->StreetDirectionPrefix_.set (x);
  }

  void FolioAddress::
  StreetDirectionPrefix (const StreetDirectionPrefix_optional& x)
  {
    this->StreetDirectionPrefix_ = x;
  }

  void FolioAddress::
  StreetDirectionPrefix (::std::unique_ptr< StreetDirectionPrefix_type > x)
  {
    this->StreetDirectionPrefix_.set (std::move (x));
  }

  const FolioAddress::StreetName_optional& FolioAddress::
  StreetName () const
  {
    return this->StreetName_;
  }

  FolioAddress::StreetName_optional& FolioAddress::
  StreetName ()
  {
    return this->StreetName_;
  }

  void FolioAddress::
  StreetName (const StreetName_type& x)
  {
    this->StreetName_.set (x);
  }

  void FolioAddress::
  StreetName (const StreetName_optional& x)
  {
    this->StreetName_ = x;
  }

  void FolioAddress::
  StreetName (::std::unique_ptr< StreetName_type > x)
  {
    this->StreetName_.set (std::move (x));
  }

  const FolioAddress::StreetType_optional& FolioAddress::
  StreetType () const
  {
    return this->StreetType_;
  }

  FolioAddress::StreetType_optional& FolioAddress::
  StreetType ()
  {
    return this->StreetType_;
  }

  void FolioAddress::
  StreetType (const StreetType_type& x)
  {
    this->StreetType_.set (x);
  }

  void FolioAddress::
  StreetType (const StreetType_optional& x)
  {
    this->StreetType_ = x;
  }

  void FolioAddress::
  StreetType (::std::unique_ptr< StreetType_type > x)
  {
    this->StreetType_.set (std::move (x));
  }

  const FolioAddress::StreetDirectionSuffix_optional& FolioAddress::
  StreetDirectionSuffix () const
  {
    return this->StreetDirectionSuffix_;
  }

  FolioAddress::StreetDirectionSuffix_optional& FolioAddress::
  StreetDirectionSuffix ()
  {
    return this->StreetDirectionSuffix_;
  }

  void FolioAddress::
  StreetDirectionSuffix (const StreetDirectionSuffix_type& x)
  {
    this->StreetDirectionSuffix_.set (x);
  }

  void FolioAddress::
  StreetDirectionSuffix (const StreetDirectionSuffix_optional& x)
  {
    this->StreetDirectionSuffix_ = x;
  }

  void FolioAddress::
  StreetDirectionSuffix (::std::unique_ptr< StreetDirectionSuffix_type > x)
  {
    this->StreetDirectionSuffix_.set (std::move (x));
  }

  const FolioAddress::City_optional& FolioAddress::
  City () const
  {
    return this->City_;
  }

  FolioAddress::City_optional& FolioAddress::
  City ()
  {
    return this->City_;
  }

  void FolioAddress::
  City (const City_type& x)
  {
    this->City_.set (x);
  }

  void FolioAddress::
  City (const City_optional& x)
  {
    this->City_ = x;
  }

  void FolioAddress::
  City (::std::unique_ptr< City_type > x)
  {
    this->City_.set (std::move (x));
  }

  const FolioAddress::ProvinceState_optional& FolioAddress::
  ProvinceState () const
  {
    return this->ProvinceState_;
  }

  FolioAddress::ProvinceState_optional& FolioAddress::
  ProvinceState ()
  {
    return this->ProvinceState_;
  }

  void FolioAddress::
  ProvinceState (const ProvinceState_type& x)
  {
    this->ProvinceState_.set (x);
  }

  void FolioAddress::
  ProvinceState (const ProvinceState_optional& x)
  {
    this->ProvinceState_ = x;
  }

  void FolioAddress::
  ProvinceState (::std::unique_ptr< ProvinceState_type > x)
  {
    this->ProvinceState_.set (std::move (x));
  }

  const FolioAddress::PostalZip_optional& FolioAddress::
  PostalZip () const
  {
    return this->PostalZip_;
  }

  FolioAddress::PostalZip_optional& FolioAddress::
  PostalZip ()
  {
    return this->PostalZip_;
  }

  void FolioAddress::
  PostalZip (const PostalZip_type& x)
  {
    this->PostalZip_.set (x);
  }

  void FolioAddress::
  PostalZip (const PostalZip_optional& x)
  {
    this->PostalZip_ = x;
  }

  void FolioAddress::
  PostalZip (::std::unique_ptr< PostalZip_type > x)
  {
    this->PostalZip_.set (std::move (x));
  }

  const FolioAddress::MapReferenceNumber_optional& FolioAddress::
  MapReferenceNumber () const
  {
    return this->MapReferenceNumber_;
  }

  FolioAddress::MapReferenceNumber_optional& FolioAddress::
  MapReferenceNumber ()
  {
    return this->MapReferenceNumber_;
  }

  void FolioAddress::
  MapReferenceNumber (const MapReferenceNumber_type& x)
  {
    this->MapReferenceNumber_.set (x);
  }

  void FolioAddress::
  MapReferenceNumber (const MapReferenceNumber_optional& x)
  {
    this->MapReferenceNumber_ = x;
  }

  void FolioAddress::
  MapReferenceNumber (::std::unique_ptr< MapReferenceNumber_type > x)
  {
    this->MapReferenceNumber_.set (std::move (x));
  }


  // OwnershipGroupCollection
  // 

  const OwnershipGroupCollection::OwnershipGroup_sequence& OwnershipGroupCollection::
  OwnershipGroup () const
  {
    return this->OwnershipGroup_;
  }

  OwnershipGroupCollection::OwnershipGroup_sequence& OwnershipGroupCollection::
  OwnershipGroup ()
  {
    return this->OwnershipGroup_;
  }

  void OwnershipGroupCollection::
  OwnershipGroup (const OwnershipGroup_sequence& s)
  {
    this->OwnershipGroup_ = s;
  }


  // OwnershipGroup
  // 

  const OwnershipGroup::OwnershipGroupID_optional& OwnershipGroup::
  OwnershipGroupID () const
  {
    return this->OwnershipGroupID_;
  }

  OwnershipGroup::OwnershipGroupID_optional& OwnershipGroup::
  OwnershipGroupID ()
  {
    return this->OwnershipGroupID_;
  }

  void OwnershipGroup::
  OwnershipGroupID (const OwnershipGroupID_type& x)
  {
    this->OwnershipGroupID_.set (x);
  }

  void OwnershipGroup::
  OwnershipGroupID (const OwnershipGroupID_optional& x)
  {
    this->OwnershipGroupID_ = x;
  }

  void OwnershipGroup::
  OwnershipGroupID (::std::unique_ptr< OwnershipGroupID_type > x)
  {
    this->OwnershipGroupID_.set (std::move (x));
  }

  const OwnershipGroup::TenureCode_optional& OwnershipGroup::
  TenureCode () const
  {
    return this->TenureCode_;
  }

  OwnershipGroup::TenureCode_optional& OwnershipGroup::
  TenureCode ()
  {
    return this->TenureCode_;
  }

  void OwnershipGroup::
  TenureCode (const TenureCode_type& x)
  {
    this->TenureCode_.set (x);
  }

  void OwnershipGroup::
  TenureCode (const TenureCode_optional& x)
  {
    this->TenureCode_ = x;
  }

  void OwnershipGroup::
  TenureCode (::std::unique_ptr< TenureCode_type > x)
  {
    this->TenureCode_.set (std::move (x));
  }

  const OwnershipGroup::TenureDescription_optional& OwnershipGroup::
  TenureDescription () const
  {
    return this->TenureDescription_;
  }

  OwnershipGroup::TenureDescription_optional& OwnershipGroup::
  TenureDescription ()
  {
    return this->TenureDescription_;
  }

  void OwnershipGroup::
  TenureDescription (const TenureDescription_type& x)
  {
    this->TenureDescription_.set (x);
  }

  void OwnershipGroup::
  TenureDescription (const TenureDescription_optional& x)
  {
    this->TenureDescription_ = x;
  }

  void OwnershipGroup::
  TenureDescription (::std::unique_ptr< TenureDescription_type > x)
  {
    this->TenureDescription_.set (std::move (x));
  }

  const OwnershipGroup::AssessmentNoticeReturned_optional& OwnershipGroup::
  AssessmentNoticeReturned () const
  {
    return this->AssessmentNoticeReturned_;
  }

  OwnershipGroup::AssessmentNoticeReturned_optional& OwnershipGroup::
  AssessmentNoticeReturned ()
  {
    return this->AssessmentNoticeReturned_;
  }

  void OwnershipGroup::
  AssessmentNoticeReturned (const AssessmentNoticeReturned_type& x)
  {
    this->AssessmentNoticeReturned_.set (x);
  }

  void OwnershipGroup::
  AssessmentNoticeReturned (const AssessmentNoticeReturned_optional& x)
  {
    this->AssessmentNoticeReturned_ = x;
  }

  void OwnershipGroup::
  AssessmentNoticeReturned (::std::unique_ptr< AssessmentNoticeReturned_type > x)
  {
    this->AssessmentNoticeReturned_.set (std::move (x));
  }

  const OwnershipGroup::AssessmentNoticeSuppressed_optional& OwnershipGroup::
  AssessmentNoticeSuppressed () const
  {
    return this->AssessmentNoticeSuppressed_;
  }

  OwnershipGroup::AssessmentNoticeSuppressed_optional& OwnershipGroup::
  AssessmentNoticeSuppressed ()
  {
    return this->AssessmentNoticeSuppressed_;
  }

  void OwnershipGroup::
  AssessmentNoticeSuppressed (const AssessmentNoticeSuppressed_type& x)
  {
    this->AssessmentNoticeSuppressed_.set (x);
  }

  void OwnershipGroup::
  AssessmentNoticeSuppressed (const AssessmentNoticeSuppressed_optional& x)
  {
    this->AssessmentNoticeSuppressed_ = x;
  }

  void OwnershipGroup::
  AssessmentNoticeSuppressed (::std::unique_ptr< AssessmentNoticeSuppressed_type > x)
  {
    this->AssessmentNoticeSuppressed_.set (std::move (x));
  }

  const OwnershipGroup::ChangeType_optional& OwnershipGroup::
  ChangeType () const
  {
    return this->ChangeType_;
  }

  OwnershipGroup::ChangeType_optional& OwnershipGroup::
  ChangeType ()
  {
    return this->ChangeType_;
  }

  void OwnershipGroup::
  ChangeType (const ChangeType_type& x)
  {
    this->ChangeType_.set (x);
  }

  void OwnershipGroup::
  ChangeType (const ChangeType_optional& x)
  {
    this->ChangeType_ = x;
  }

  void OwnershipGroup::
  ChangeType (::std::unique_ptr< ChangeType_type > x)
  {
    this->ChangeType_.set (std::move (x));
  }

  const OwnershipGroup::ChangeTypeDescription_optional& OwnershipGroup::
  ChangeTypeDescription () const
  {
    return this->ChangeTypeDescription_;
  }

  OwnershipGroup::ChangeTypeDescription_optional& OwnershipGroup::
  ChangeTypeDescription ()
  {
    return this->ChangeTypeDescription_;
  }

  void OwnershipGroup::
  ChangeTypeDescription (const ChangeTypeDescription_type& x)
  {
    this->ChangeTypeDescription_.set (x);
  }

  void OwnershipGroup::
  ChangeTypeDescription (const ChangeTypeDescription_optional& x)
  {
    this->ChangeTypeDescription_ = x;
  }

  void OwnershipGroup::
  ChangeTypeDescription (::std::unique_ptr< ChangeTypeDescription_type > x)
  {
    this->ChangeTypeDescription_.set (std::move (x));
  }

  const OwnershipGroup::ChangeDate_optional& OwnershipGroup::
  ChangeDate () const
  {
    return this->ChangeDate_;
  }

  OwnershipGroup::ChangeDate_optional& OwnershipGroup::
  ChangeDate ()
  {
    return this->ChangeDate_;
  }

  void OwnershipGroup::
  ChangeDate (const ChangeDate_type& x)
  {
    this->ChangeDate_.set (x);
  }

  void OwnershipGroup::
  ChangeDate (const ChangeDate_optional& x)
  {
    this->ChangeDate_ = x;
  }

  void OwnershipGroup::
  ChangeDate (::std::unique_ptr< ChangeDate_type > x)
  {
    this->ChangeDate_.set (std::move (x));
  }

  const OwnershipGroup::ChangeSource_optional& OwnershipGroup::
  ChangeSource () const
  {
    return this->ChangeSource_;
  }

  OwnershipGroup::ChangeSource_optional& OwnershipGroup::
  ChangeSource ()
  {
    return this->ChangeSource_;
  }

  void OwnershipGroup::
  ChangeSource (const ChangeSource_type& x)
  {
    this->ChangeSource_.set (x);
  }

  void OwnershipGroup::
  ChangeSource (const ChangeSource_optional& x)
  {
    this->ChangeSource_ = x;
  }

  void OwnershipGroup::
  ChangeSource (::std::unique_ptr< ChangeSource_type > x)
  {
    this->ChangeSource_.set (std::move (x));
  }

  const OwnershipGroup::ChangeSourceDescription_optional& OwnershipGroup::
  ChangeSourceDescription () const
  {
    return this->ChangeSourceDescription_;
  }

  OwnershipGroup::ChangeSourceDescription_optional& OwnershipGroup::
  ChangeSourceDescription ()
  {
    return this->ChangeSourceDescription_;
  }

  void OwnershipGroup::
  ChangeSourceDescription (const ChangeSourceDescription_type& x)
  {
    this->ChangeSourceDescription_.set (x);
  }

  void OwnershipGroup::
  ChangeSourceDescription (const ChangeSourceDescription_optional& x)
  {
    this->ChangeSourceDescription_ = x;
  }

  void OwnershipGroup::
  ChangeSourceDescription (::std::unique_ptr< ChangeSourceDescription_type > x)
  {
    this->ChangeSourceDescription_.set (std::move (x));
  }

  const OwnershipGroup::Owners_optional& OwnershipGroup::
  Owners () const
  {
    return this->Owners_;
  }

  OwnershipGroup::Owners_optional& OwnershipGroup::
  Owners ()
  {
    return this->Owners_;
  }

  void OwnershipGroup::
  Owners (const Owners_type& x)
  {
    this->Owners_.set (x);
  }

  void OwnershipGroup::
  Owners (const Owners_optional& x)
  {
    this->Owners_ = x;
  }

  void OwnershipGroup::
  Owners (::std::unique_ptr< Owners_type > x)
  {
    this->Owners_.set (std::move (x));
  }

  const OwnershipGroup::FormattedMailingAddress_optional& OwnershipGroup::
  FormattedMailingAddress () const
  {
    return this->FormattedMailingAddress_;
  }

  OwnershipGroup::FormattedMailingAddress_optional& OwnershipGroup::
  FormattedMailingAddress ()
  {
    return this->FormattedMailingAddress_;
  }

  void OwnershipGroup::
  FormattedMailingAddress (const FormattedMailingAddress_type& x)
  {
    this->FormattedMailingAddress_.set (x);
  }

  void OwnershipGroup::
  FormattedMailingAddress (const FormattedMailingAddress_optional& x)
  {
    this->FormattedMailingAddress_ = x;
  }

  void OwnershipGroup::
  FormattedMailingAddress (::std::unique_ptr< FormattedMailingAddress_type > x)
  {
    this->FormattedMailingAddress_.set (std::move (x));
  }

  const OwnershipGroup::MailingAddress_optional& OwnershipGroup::
  MailingAddress () const
  {
    return this->MailingAddress_;
  }

  OwnershipGroup::MailingAddress_optional& OwnershipGroup::
  MailingAddress ()
  {
    return this->MailingAddress_;
  }

  void OwnershipGroup::
  MailingAddress (const MailingAddress_type& x)
  {
    this->MailingAddress_.set (x);
  }

  void OwnershipGroup::
  MailingAddress (const MailingAddress_optional& x)
  {
    this->MailingAddress_ = x;
  }

  void OwnershipGroup::
  MailingAddress (::std::unique_ptr< MailingAddress_type > x)
  {
    this->MailingAddress_.set (std::move (x));
  }


  // OwnerCollection
  // 

  const OwnerCollection::Owner_sequence& OwnerCollection::
  Owner () const
  {
    return this->Owner_;
  }

  OwnerCollection::Owner_sequence& OwnerCollection::
  Owner ()
  {
    return this->Owner_;
  }

  void OwnerCollection::
  Owner (const Owner_sequence& s)
  {
    this->Owner_ = s;
  }


  // Owner
  // 

  const Owner::FirstName_optional& Owner::
  FirstName () const
  {
    return this->FirstName_;
  }

  Owner::FirstName_optional& Owner::
  FirstName ()
  {
    return this->FirstName_;
  }

  void Owner::
  FirstName (const FirstName_type& x)
  {
    this->FirstName_.set (x);
  }

  void Owner::
  FirstName (const FirstName_optional& x)
  {
    this->FirstName_ = x;
  }

  void Owner::
  FirstName (::std::unique_ptr< FirstName_type > x)
  {
    this->FirstName_.set (std::move (x));
  }

  const Owner::MiddleName_optional& Owner::
  MiddleName () const
  {
    return this->MiddleName_;
  }

  Owner::MiddleName_optional& Owner::
  MiddleName ()
  {
    return this->MiddleName_;
  }

  void Owner::
  MiddleName (const MiddleName_type& x)
  {
    this->MiddleName_.set (x);
  }

  void Owner::
  MiddleName (const MiddleName_optional& x)
  {
    this->MiddleName_ = x;
  }

  void Owner::
  MiddleName (::std::unique_ptr< MiddleName_type > x)
  {
    this->MiddleName_.set (std::move (x));
  }

  const Owner::MiddleInitial_optional& Owner::
  MiddleInitial () const
  {
    return this->MiddleInitial_;
  }

  Owner::MiddleInitial_optional& Owner::
  MiddleInitial ()
  {
    return this->MiddleInitial_;
  }

  void Owner::
  MiddleInitial (const MiddleInitial_type& x)
  {
    this->MiddleInitial_.set (x);
  }

  void Owner::
  MiddleInitial (const MiddleInitial_optional& x)
  {
    this->MiddleInitial_ = x;
  }

  void Owner::
  MiddleInitial (::std::unique_ptr< MiddleInitial_type > x)
  {
    this->MiddleInitial_.set (std::move (x));
  }

  const Owner::CompanyOrLastName_type& Owner::
  CompanyOrLastName () const
  {
    return this->CompanyOrLastName_.get ();
  }

  Owner::CompanyOrLastName_type& Owner::
  CompanyOrLastName ()
  {
    return this->CompanyOrLastName_.get ();
  }

  void Owner::
  CompanyOrLastName (const CompanyOrLastName_type& x)
  {
    this->CompanyOrLastName_.set (x);
  }

  void Owner::
  CompanyOrLastName (::std::unique_ptr< CompanyOrLastName_type > x)
  {
    this->CompanyOrLastName_.set (std::move (x));
  }

  const Owner::OwnerSequenceID_optional& Owner::
  OwnerSequenceID () const
  {
    return this->OwnerSequenceID_;
  }

  Owner::OwnerSequenceID_optional& Owner::
  OwnerSequenceID ()
  {
    return this->OwnerSequenceID_;
  }

  void Owner::
  OwnerSequenceID (const OwnerSequenceID_type& x)
  {
    this->OwnerSequenceID_.set (x);
  }

  void Owner::
  OwnerSequenceID (const OwnerSequenceID_optional& x)
  {
    this->OwnerSequenceID_ = x;
  }

  void Owner::
  OwnerSequenceID (::std::unique_ptr< OwnerSequenceID_type > x)
  {
    this->OwnerSequenceID_.set (std::move (x));
  }

  const Owner::EquityType_optional& Owner::
  EquityType () const
  {
    return this->EquityType_;
  }

  Owner::EquityType_optional& Owner::
  EquityType ()
  {
    return this->EquityType_;
  }

  void Owner::
  EquityType (const EquityType_type& x)
  {
    this->EquityType_.set (x);
  }

  void Owner::
  EquityType (const EquityType_optional& x)
  {
    this->EquityType_ = x;
  }

  void Owner::
  EquityType (::std::unique_ptr< EquityType_type > x)
  {
    this->EquityType_.set (std::move (x));
  }

  const Owner::EquityTypeDescription_optional& Owner::
  EquityTypeDescription () const
  {
    return this->EquityTypeDescription_;
  }

  Owner::EquityTypeDescription_optional& Owner::
  EquityTypeDescription ()
  {
    return this->EquityTypeDescription_;
  }

  void Owner::
  EquityTypeDescription (const EquityTypeDescription_type& x)
  {
    this->EquityTypeDescription_.set (x);
  }

  void Owner::
  EquityTypeDescription (const EquityTypeDescription_optional& x)
  {
    this->EquityTypeDescription_ = x;
  }

  void Owner::
  EquityTypeDescription (::std::unique_ptr< EquityTypeDescription_type > x)
  {
    this->EquityTypeDescription_.set (std::move (x));
  }


  // MailingAddress
  // 

  const MailingAddress::Attention_optional& MailingAddress::
  Attention () const
  {
    return this->Attention_;
  }

  MailingAddress::Attention_optional& MailingAddress::
  Attention ()
  {
    return this->Attention_;
  }

  void MailingAddress::
  Attention (const Attention_type& x)
  {
    this->Attention_.set (x);
  }

  void MailingAddress::
  Attention (const Attention_optional& x)
  {
    this->Attention_ = x;
  }

  void MailingAddress::
  Attention (::std::unique_ptr< Attention_type > x)
  {
    this->Attention_.set (std::move (x));
  }

  const MailingAddress::CareOf_optional& MailingAddress::
  CareOf () const
  {
    return this->CareOf_;
  }

  MailingAddress::CareOf_optional& MailingAddress::
  CareOf ()
  {
    return this->CareOf_;
  }

  void MailingAddress::
  CareOf (const CareOf_type& x)
  {
    this->CareOf_.set (x);
  }

  void MailingAddress::
  CareOf (const CareOf_optional& x)
  {
    this->CareOf_ = x;
  }

  void MailingAddress::
  CareOf (::std::unique_ptr< CareOf_type > x)
  {
    this->CareOf_.set (std::move (x));
  }

  const MailingAddress::Floor_optional& MailingAddress::
  Floor () const
  {
    return this->Floor_;
  }

  MailingAddress::Floor_optional& MailingAddress::
  Floor ()
  {
    return this->Floor_;
  }

  void MailingAddress::
  Floor (const Floor_type& x)
  {
    this->Floor_.set (x);
  }

  void MailingAddress::
  Floor (const Floor_optional& x)
  {
    this->Floor_ = x;
  }

  void MailingAddress::
  Floor (::std::unique_ptr< Floor_type > x)
  {
    this->Floor_.set (std::move (x));
  }

  const MailingAddress::UnitNumber_optional& MailingAddress::
  UnitNumber () const
  {
    return this->UnitNumber_;
  }

  MailingAddress::UnitNumber_optional& MailingAddress::
  UnitNumber ()
  {
    return this->UnitNumber_;
  }

  void MailingAddress::
  UnitNumber (const UnitNumber_type& x)
  {
    this->UnitNumber_.set (x);
  }

  void MailingAddress::
  UnitNumber (const UnitNumber_optional& x)
  {
    this->UnitNumber_ = x;
  }

  void MailingAddress::
  UnitNumber (::std::unique_ptr< UnitNumber_type > x)
  {
    this->UnitNumber_.set (std::move (x));
  }

  const MailingAddress::StreetDirectionPrefix_optional& MailingAddress::
  StreetDirectionPrefix () const
  {
    return this->StreetDirectionPrefix_;
  }

  MailingAddress::StreetDirectionPrefix_optional& MailingAddress::
  StreetDirectionPrefix ()
  {
    return this->StreetDirectionPrefix_;
  }

  void MailingAddress::
  StreetDirectionPrefix (const StreetDirectionPrefix_type& x)
  {
    this->StreetDirectionPrefix_.set (x);
  }

  void MailingAddress::
  StreetDirectionPrefix (const StreetDirectionPrefix_optional& x)
  {
    this->StreetDirectionPrefix_ = x;
  }

  void MailingAddress::
  StreetDirectionPrefix (::std::unique_ptr< StreetDirectionPrefix_type > x)
  {
    this->StreetDirectionPrefix_.set (std::move (x));
  }

  const MailingAddress::StreetNumber_optional& MailingAddress::
  StreetNumber () const
  {
    return this->StreetNumber_;
  }

  MailingAddress::StreetNumber_optional& MailingAddress::
  StreetNumber ()
  {
    return this->StreetNumber_;
  }

  void MailingAddress::
  StreetNumber (const StreetNumber_type& x)
  {
    this->StreetNumber_.set (x);
  }

  void MailingAddress::
  StreetNumber (const StreetNumber_optional& x)
  {
    this->StreetNumber_ = x;
  }

  void MailingAddress::
  StreetNumber (::std::unique_ptr< StreetNumber_type > x)
  {
    this->StreetNumber_.set (std::move (x));
  }

  const MailingAddress::StreetName_optional& MailingAddress::
  StreetName () const
  {
    return this->StreetName_;
  }

  MailingAddress::StreetName_optional& MailingAddress::
  StreetName ()
  {
    return this->StreetName_;
  }

  void MailingAddress::
  StreetName (const StreetName_type& x)
  {
    this->StreetName_.set (x);
  }

  void MailingAddress::
  StreetName (const StreetName_optional& x)
  {
    this->StreetName_ = x;
  }

  void MailingAddress::
  StreetName (::std::unique_ptr< StreetName_type > x)
  {
    this->StreetName_.set (std::move (x));
  }

  const MailingAddress::StreetType_optional& MailingAddress::
  StreetType () const
  {
    return this->StreetType_;
  }

  MailingAddress::StreetType_optional& MailingAddress::
  StreetType ()
  {
    return this->StreetType_;
  }

  void MailingAddress::
  StreetType (const StreetType_type& x)
  {
    this->StreetType_.set (x);
  }

  void MailingAddress::
  StreetType (const StreetType_optional& x)
  {
    this->StreetType_ = x;
  }

  void MailingAddress::
  StreetType (::std::unique_ptr< StreetType_type > x)
  {
    this->StreetType_.set (std::move (x));
  }

  const MailingAddress::StreetDirectionSuffix_optional& MailingAddress::
  StreetDirectionSuffix () const
  {
    return this->StreetDirectionSuffix_;
  }

  MailingAddress::StreetDirectionSuffix_optional& MailingAddress::
  StreetDirectionSuffix ()
  {
    return this->StreetDirectionSuffix_;
  }

  void MailingAddress::
  StreetDirectionSuffix (const StreetDirectionSuffix_type& x)
  {
    this->StreetDirectionSuffix_.set (x);
  }

  void MailingAddress::
  StreetDirectionSuffix (const StreetDirectionSuffix_optional& x)
  {
    this->StreetDirectionSuffix_ = x;
  }

  void MailingAddress::
  StreetDirectionSuffix (::std::unique_ptr< StreetDirectionSuffix_type > x)
  {
    this->StreetDirectionSuffix_.set (std::move (x));
  }

  const MailingAddress::City_optional& MailingAddress::
  City () const
  {
    return this->City_;
  }

  MailingAddress::City_optional& MailingAddress::
  City ()
  {
    return this->City_;
  }

  void MailingAddress::
  City (const City_type& x)
  {
    this->City_.set (x);
  }

  void MailingAddress::
  City (const City_optional& x)
  {
    this->City_ = x;
  }

  void MailingAddress::
  City (::std::unique_ptr< City_type > x)
  {
    this->City_.set (std::move (x));
  }

  const MailingAddress::ProvinceState_optional& MailingAddress::
  ProvinceState () const
  {
    return this->ProvinceState_;
  }

  MailingAddress::ProvinceState_optional& MailingAddress::
  ProvinceState ()
  {
    return this->ProvinceState_;
  }

  void MailingAddress::
  ProvinceState (const ProvinceState_type& x)
  {
    this->ProvinceState_.set (x);
  }

  void MailingAddress::
  ProvinceState (const ProvinceState_optional& x)
  {
    this->ProvinceState_ = x;
  }

  void MailingAddress::
  ProvinceState (::std::unique_ptr< ProvinceState_type > x)
  {
    this->ProvinceState_.set (std::move (x));
  }

  const MailingAddress::Country_optional& MailingAddress::
  Country () const
  {
    return this->Country_;
  }

  MailingAddress::Country_optional& MailingAddress::
  Country ()
  {
    return this->Country_;
  }

  void MailingAddress::
  Country (const Country_type& x)
  {
    this->Country_.set (x);
  }

  void MailingAddress::
  Country (const Country_optional& x)
  {
    this->Country_ = x;
  }

  void MailingAddress::
  Country (::std::unique_ptr< Country_type > x)
  {
    this->Country_.set (std::move (x));
  }

  const MailingAddress::PostalZip_optional& MailingAddress::
  PostalZip () const
  {
    return this->PostalZip_;
  }

  MailingAddress::PostalZip_optional& MailingAddress::
  PostalZip ()
  {
    return this->PostalZip_;
  }

  void MailingAddress::
  PostalZip (const PostalZip_type& x)
  {
    this->PostalZip_.set (x);
  }

  void MailingAddress::
  PostalZip (const PostalZip_optional& x)
  {
    this->PostalZip_ = x;
  }

  void MailingAddress::
  PostalZip (::std::unique_ptr< PostalZip_type > x)
  {
    this->PostalZip_.set (std::move (x));
  }

  const MailingAddress::FreeformAddress_optional& MailingAddress::
  FreeformAddress () const
  {
    return this->FreeformAddress_;
  }

  MailingAddress::FreeformAddress_optional& MailingAddress::
  FreeformAddress ()
  {
    return this->FreeformAddress_;
  }

  void MailingAddress::
  FreeformAddress (const FreeformAddress_type& x)
  {
    this->FreeformAddress_.set (x);
  }

  void MailingAddress::
  FreeformAddress (const FreeformAddress_optional& x)
  {
    this->FreeformAddress_ = x;
  }

  void MailingAddress::
  FreeformAddress (::std::unique_ptr< FreeformAddress_type > x)
  {
    this->FreeformAddress_.set (std::move (x));
  }

  const MailingAddress::Compartment_optional& MailingAddress::
  Compartment () const
  {
    return this->Compartment_;
  }

  MailingAddress::Compartment_optional& MailingAddress::
  Compartment ()
  {
    return this->Compartment_;
  }

  void MailingAddress::
  Compartment (const Compartment_type& x)
  {
    this->Compartment_.set (x);
  }

  void MailingAddress::
  Compartment (const Compartment_optional& x)
  {
    this->Compartment_ = x;
  }

  void MailingAddress::
  Compartment (::std::unique_ptr< Compartment_type > x)
  {
    this->Compartment_.set (std::move (x));
  }

  const MailingAddress::DeliveryInstallationType_optional& MailingAddress::
  DeliveryInstallationType () const
  {
    return this->DeliveryInstallationType_;
  }

  MailingAddress::DeliveryInstallationType_optional& MailingAddress::
  DeliveryInstallationType ()
  {
    return this->DeliveryInstallationType_;
  }

  void MailingAddress::
  DeliveryInstallationType (const DeliveryInstallationType_type& x)
  {
    this->DeliveryInstallationType_.set (x);
  }

  void MailingAddress::
  DeliveryInstallationType (const DeliveryInstallationType_optional& x)
  {
    this->DeliveryInstallationType_ = x;
  }

  void MailingAddress::
  DeliveryInstallationType (::std::unique_ptr< DeliveryInstallationType_type > x)
  {
    this->DeliveryInstallationType_.set (std::move (x));
  }

  const MailingAddress::DeliveryInstallationTypeValue_optional& MailingAddress::
  DeliveryInstallationTypeValue () const
  {
    return this->DeliveryInstallationTypeValue_;
  }

  MailingAddress::DeliveryInstallationTypeValue_optional& MailingAddress::
  DeliveryInstallationTypeValue ()
  {
    return this->DeliveryInstallationTypeValue_;
  }

  void MailingAddress::
  DeliveryInstallationTypeValue (const DeliveryInstallationTypeValue_type& x)
  {
    this->DeliveryInstallationTypeValue_.set (x);
  }

  void MailingAddress::
  DeliveryInstallationTypeValue (const DeliveryInstallationTypeValue_optional& x)
  {
    this->DeliveryInstallationTypeValue_ = x;
  }

  void MailingAddress::
  DeliveryInstallationTypeValue (::std::unique_ptr< DeliveryInstallationTypeValue_type > x)
  {
    this->DeliveryInstallationTypeValue_.set (std::move (x));
  }

  const MailingAddress::ModeOfDelivery_optional& MailingAddress::
  ModeOfDelivery () const
  {
    return this->ModeOfDelivery_;
  }

  MailingAddress::ModeOfDelivery_optional& MailingAddress::
  ModeOfDelivery ()
  {
    return this->ModeOfDelivery_;
  }

  void MailingAddress::
  ModeOfDelivery (const ModeOfDelivery_type& x)
  {
    this->ModeOfDelivery_.set (x);
  }

  void MailingAddress::
  ModeOfDelivery (const ModeOfDelivery_optional& x)
  {
    this->ModeOfDelivery_ = x;
  }

  void MailingAddress::
  ModeOfDelivery (::std::unique_ptr< ModeOfDelivery_type > x)
  {
    this->ModeOfDelivery_.set (std::move (x));
  }

  const MailingAddress::ModeOfDeliveryValue_optional& MailingAddress::
  ModeOfDeliveryValue () const
  {
    return this->ModeOfDeliveryValue_;
  }

  MailingAddress::ModeOfDeliveryValue_optional& MailingAddress::
  ModeOfDeliveryValue ()
  {
    return this->ModeOfDeliveryValue_;
  }

  void MailingAddress::
  ModeOfDeliveryValue (const ModeOfDeliveryValue_type& x)
  {
    this->ModeOfDeliveryValue_.set (x);
  }

  void MailingAddress::
  ModeOfDeliveryValue (const ModeOfDeliveryValue_optional& x)
  {
    this->ModeOfDeliveryValue_ = x;
  }

  void MailingAddress::
  ModeOfDeliveryValue (::std::unique_ptr< ModeOfDeliveryValue_type > x)
  {
    this->ModeOfDeliveryValue_.set (std::move (x));
  }

  const MailingAddress::Site_optional& MailingAddress::
  Site () const
  {
    return this->Site_;
  }

  MailingAddress::Site_optional& MailingAddress::
  Site ()
  {
    return this->Site_;
  }

  void MailingAddress::
  Site (const Site_type& x)
  {
    this->Site_.set (x);
  }

  void MailingAddress::
  Site (const Site_optional& x)
  {
    this->Site_ = x;
  }

  void MailingAddress::
  Site (::std::unique_ptr< Site_type > x)
  {
    this->Site_.set (std::move (x));
  }

  const MailingAddress::BulkMailCode_optional& MailingAddress::
  BulkMailCode () const
  {
    return this->BulkMailCode_;
  }

  MailingAddress::BulkMailCode_optional& MailingAddress::
  BulkMailCode ()
  {
    return this->BulkMailCode_;
  }

  void MailingAddress::
  BulkMailCode (const BulkMailCode_type& x)
  {
    this->BulkMailCode_.set (x);
  }

  void MailingAddress::
  BulkMailCode (const BulkMailCode_optional& x)
  {
    this->BulkMailCode_ = x;
  }

  void MailingAddress::
  BulkMailCode (::std::unique_ptr< BulkMailCode_type > x)
  {
    this->BulkMailCode_.set (std::move (x));
  }


  // FormattedMailingAddress
  // 

  const FormattedMailingAddress::Line1_optional& FormattedMailingAddress::
  Line1 () const
  {
    return this->Line1_;
  }

  FormattedMailingAddress::Line1_optional& FormattedMailingAddress::
  Line1 ()
  {
    return this->Line1_;
  }

  void FormattedMailingAddress::
  Line1 (const Line1_type& x)
  {
    this->Line1_.set (x);
  }

  void FormattedMailingAddress::
  Line1 (const Line1_optional& x)
  {
    this->Line1_ = x;
  }

  void FormattedMailingAddress::
  Line1 (::std::unique_ptr< Line1_type > x)
  {
    this->Line1_.set (std::move (x));
  }

  const FormattedMailingAddress::Line2_optional& FormattedMailingAddress::
  Line2 () const
  {
    return this->Line2_;
  }

  FormattedMailingAddress::Line2_optional& FormattedMailingAddress::
  Line2 ()
  {
    return this->Line2_;
  }

  void FormattedMailingAddress::
  Line2 (const Line2_type& x)
  {
    this->Line2_.set (x);
  }

  void FormattedMailingAddress::
  Line2 (const Line2_optional& x)
  {
    this->Line2_ = x;
  }

  void FormattedMailingAddress::
  Line2 (::std::unique_ptr< Line2_type > x)
  {
    this->Line2_.set (std::move (x));
  }

  const FormattedMailingAddress::Line3_optional& FormattedMailingAddress::
  Line3 () const
  {
    return this->Line3_;
  }

  FormattedMailingAddress::Line3_optional& FormattedMailingAddress::
  Line3 ()
  {
    return this->Line3_;
  }

  void FormattedMailingAddress::
  Line3 (const Line3_type& x)
  {
    this->Line3_.set (x);
  }

  void FormattedMailingAddress::
  Line3 (const Line3_optional& x)
  {
    this->Line3_ = x;
  }

  void FormattedMailingAddress::
  Line3 (::std::unique_ptr< Line3_type > x)
  {
    this->Line3_.set (std::move (x));
  }

  const FormattedMailingAddress::Line4_optional& FormattedMailingAddress::
  Line4 () const
  {
    return this->Line4_;
  }

  FormattedMailingAddress::Line4_optional& FormattedMailingAddress::
  Line4 ()
  {
    return this->Line4_;
  }

  void FormattedMailingAddress::
  Line4 (const Line4_type& x)
  {
    this->Line4_.set (x);
  }

  void FormattedMailingAddress::
  Line4 (const Line4_optional& x)
  {
    this->Line4_ = x;
  }

  void FormattedMailingAddress::
  Line4 (::std::unique_ptr< Line4_type > x)
  {
    this->Line4_.set (std::move (x));
  }

  const FormattedMailingAddress::Line5_optional& FormattedMailingAddress::
  Line5 () const
  {
    return this->Line5_;
  }

  FormattedMailingAddress::Line5_optional& FormattedMailingAddress::
  Line5 ()
  {
    return this->Line5_;
  }

  void FormattedMailingAddress::
  Line5 (const Line5_type& x)
  {
    this->Line5_.set (x);
  }

  void FormattedMailingAddress::
  Line5 (const Line5_optional& x)
  {
    this->Line5_ = x;
  }

  void FormattedMailingAddress::
  Line5 (::std::unique_ptr< Line5_type > x)
  {
    this->Line5_.set (std::move (x));
  }

  const FormattedMailingAddress::Line6_optional& FormattedMailingAddress::
  Line6 () const
  {
    return this->Line6_;
  }

  FormattedMailingAddress::Line6_optional& FormattedMailingAddress::
  Line6 ()
  {
    return this->Line6_;
  }

  void FormattedMailingAddress::
  Line6 (const Line6_type& x)
  {
    this->Line6_.set (x);
  }

  void FormattedMailingAddress::
  Line6 (const Line6_optional& x)
  {
    this->Line6_ = x;
  }

  void FormattedMailingAddress::
  Line6 (::std::unique_ptr< Line6_type > x)
  {
    this->Line6_.set (std::move (x));
  }


  // String40
  // 


  // FormattedMailingAddressLine
  // 

  const FormattedMailingAddressLine::Action_optional& FormattedMailingAddressLine::
  Action () const
  {
    return this->Action_;
  }

  FormattedMailingAddressLine::Action_optional& FormattedMailingAddressLine::
  Action ()
  {
    return this->Action_;
  }

  void FormattedMailingAddressLine::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FormattedMailingAddressLine::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FormattedMailingAddressLine::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FormattedMailingAddressLine::OldValue_optional& FormattedMailingAddressLine::
  OldValue () const
  {
    return this->OldValue_;
  }

  FormattedMailingAddressLine::OldValue_optional& FormattedMailingAddressLine::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FormattedMailingAddressLine::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FormattedMailingAddressLine::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FormattedMailingAddressLine::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // LegalDescriptionCollection
  // 

  const LegalDescriptionCollection::LegalDescription_sequence& LegalDescriptionCollection::
  LegalDescription () const
  {
    return this->LegalDescription_;
  }

  LegalDescriptionCollection::LegalDescription_sequence& LegalDescriptionCollection::
  LegalDescription ()
  {
    return this->LegalDescription_;
  }

  void LegalDescriptionCollection::
  LegalDescription (const LegalDescription_sequence& s)
  {
    this->LegalDescription_ = s;
  }


  // LegalDescription
  // 

  const LegalDescription::FormattedLegalDescription_optional& LegalDescription::
  FormattedLegalDescription () const
  {
    return this->FormattedLegalDescription_;
  }

  LegalDescription::FormattedLegalDescription_optional& LegalDescription::
  FormattedLegalDescription ()
  {
    return this->FormattedLegalDescription_;
  }

  void LegalDescription::
  FormattedLegalDescription (const FormattedLegalDescription_type& x)
  {
    this->FormattedLegalDescription_.set (x);
  }

  void LegalDescription::
  FormattedLegalDescription (const FormattedLegalDescription_optional& x)
  {
    this->FormattedLegalDescription_ = x;
  }

  void LegalDescription::
  FormattedLegalDescription (::std::unique_ptr< FormattedLegalDescription_type > x)
  {
    this->FormattedLegalDescription_.set (std::move (x));
  }

  const LegalDescription::PID_optional& LegalDescription::
  PID () const
  {
    return this->PID_;
  }

  LegalDescription::PID_optional& LegalDescription::
  PID ()
  {
    return this->PID_;
  }

  void LegalDescription::
  PID (const PID_type& x)
  {
    this->PID_.set (x);
  }

  void LegalDescription::
  PID (const PID_optional& x)
  {
    this->PID_ = x;
  }

  void LegalDescription::
  PID (::std::unique_ptr< PID_type > x)
  {
    this->PID_.set (std::move (x));
  }

  const LegalDescription::Lot_optional& LegalDescription::
  Lot () const
  {
    return this->Lot_;
  }

  LegalDescription::Lot_optional& LegalDescription::
  Lot ()
  {
    return this->Lot_;
  }

  void LegalDescription::
  Lot (const Lot_type& x)
  {
    this->Lot_.set (x);
  }

  void LegalDescription::
  Lot (const Lot_optional& x)
  {
    this->Lot_ = x;
  }

  void LegalDescription::
  Lot (::std::unique_ptr< Lot_type > x)
  {
    this->Lot_.set (std::move (x));
  }

  const LegalDescription::StrataLot_optional& LegalDescription::
  StrataLot () const
  {
    return this->StrataLot_;
  }

  LegalDescription::StrataLot_optional& LegalDescription::
  StrataLot ()
  {
    return this->StrataLot_;
  }

  void LegalDescription::
  StrataLot (const StrataLot_type& x)
  {
    this->StrataLot_.set (x);
  }

  void LegalDescription::
  StrataLot (const StrataLot_optional& x)
  {
    this->StrataLot_ = x;
  }

  void LegalDescription::
  StrataLot (::std::unique_ptr< StrataLot_type > x)
  {
    this->StrataLot_.set (std::move (x));
  }

  const LegalDescription::Parcel_optional& LegalDescription::
  Parcel () const
  {
    return this->Parcel_;
  }

  LegalDescription::Parcel_optional& LegalDescription::
  Parcel ()
  {
    return this->Parcel_;
  }

  void LegalDescription::
  Parcel (const Parcel_type& x)
  {
    this->Parcel_.set (x);
  }

  void LegalDescription::
  Parcel (const Parcel_optional& x)
  {
    this->Parcel_ = x;
  }

  void LegalDescription::
  Parcel (::std::unique_ptr< Parcel_type > x)
  {
    this->Parcel_.set (std::move (x));
  }

  const LegalDescription::Block_optional& LegalDescription::
  Block () const
  {
    return this->Block_;
  }

  LegalDescription::Block_optional& LegalDescription::
  Block ()
  {
    return this->Block_;
  }

  void LegalDescription::
  Block (const Block_type& x)
  {
    this->Block_.set (x);
  }

  void LegalDescription::
  Block (const Block_optional& x)
  {
    this->Block_ = x;
  }

  void LegalDescription::
  Block (::std::unique_ptr< Block_type > x)
  {
    this->Block_.set (std::move (x));
  }

  const LegalDescription::SubBlock_optional& LegalDescription::
  SubBlock () const
  {
    return this->SubBlock_;
  }

  LegalDescription::SubBlock_optional& LegalDescription::
  SubBlock ()
  {
    return this->SubBlock_;
  }

  void LegalDescription::
  SubBlock (const SubBlock_type& x)
  {
    this->SubBlock_.set (x);
  }

  void LegalDescription::
  SubBlock (const SubBlock_optional& x)
  {
    this->SubBlock_ = x;
  }

  void LegalDescription::
  SubBlock (::std::unique_ptr< SubBlock_type > x)
  {
    this->SubBlock_.set (std::move (x));
  }

  const LegalDescription::Plan_optional& LegalDescription::
  Plan () const
  {
    return this->Plan_;
  }

  LegalDescription::Plan_optional& LegalDescription::
  Plan ()
  {
    return this->Plan_;
  }

  void LegalDescription::
  Plan (const Plan_type& x)
  {
    this->Plan_.set (x);
  }

  void LegalDescription::
  Plan (const Plan_optional& x)
  {
    this->Plan_ = x;
  }

  void LegalDescription::
  Plan (::std::unique_ptr< Plan_type > x)
  {
    this->Plan_.set (std::move (x));
  }

  const LegalDescription::SubLot_optional& LegalDescription::
  SubLot () const
  {
    return this->SubLot_;
  }

  LegalDescription::SubLot_optional& LegalDescription::
  SubLot ()
  {
    return this->SubLot_;
  }

  void LegalDescription::
  SubLot (const SubLot_type& x)
  {
    this->SubLot_.set (x);
  }

  void LegalDescription::
  SubLot (const SubLot_optional& x)
  {
    this->SubLot_ = x;
  }

  void LegalDescription::
  SubLot (::std::unique_ptr< SubLot_type > x)
  {
    this->SubLot_.set (std::move (x));
  }

  const LegalDescription::Part1_optional& LegalDescription::
  Part1 () const
  {
    return this->Part1_;
  }

  LegalDescription::Part1_optional& LegalDescription::
  Part1 ()
  {
    return this->Part1_;
  }

  void LegalDescription::
  Part1 (const Part1_type& x)
  {
    this->Part1_.set (x);
  }

  void LegalDescription::
  Part1 (const Part1_optional& x)
  {
    this->Part1_ = x;
  }

  void LegalDescription::
  Part1 (::std::unique_ptr< Part1_type > x)
  {
    this->Part1_.set (std::move (x));
  }

  const LegalDescription::Part2_optional& LegalDescription::
  Part2 () const
  {
    return this->Part2_;
  }

  LegalDescription::Part2_optional& LegalDescription::
  Part2 ()
  {
    return this->Part2_;
  }

  void LegalDescription::
  Part2 (const Part2_type& x)
  {
    this->Part2_.set (x);
  }

  void LegalDescription::
  Part2 (const Part2_optional& x)
  {
    this->Part2_ = x;
  }

  void LegalDescription::
  Part2 (::std::unique_ptr< Part2_type > x)
  {
    this->Part2_.set (std::move (x));
  }

  const LegalDescription::Part3_optional& LegalDescription::
  Part3 () const
  {
    return this->Part3_;
  }

  LegalDescription::Part3_optional& LegalDescription::
  Part3 ()
  {
    return this->Part3_;
  }

  void LegalDescription::
  Part3 (const Part3_type& x)
  {
    this->Part3_.set (x);
  }

  void LegalDescription::
  Part3 (const Part3_optional& x)
  {
    this->Part3_ = x;
  }

  void LegalDescription::
  Part3 (::std::unique_ptr< Part3_type > x)
  {
    this->Part3_.set (std::move (x));
  }

  const LegalDescription::Part4_optional& LegalDescription::
  Part4 () const
  {
    return this->Part4_;
  }

  LegalDescription::Part4_optional& LegalDescription::
  Part4 ()
  {
    return this->Part4_;
  }

  void LegalDescription::
  Part4 (const Part4_type& x)
  {
    this->Part4_.set (x);
  }

  void LegalDescription::
  Part4 (const Part4_optional& x)
  {
    this->Part4_ = x;
  }

  void LegalDescription::
  Part4 (::std::unique_ptr< Part4_type > x)
  {
    this->Part4_.set (std::move (x));
  }

  const LegalDescription::DistrictLot_optional& LegalDescription::
  DistrictLot () const
  {
    return this->DistrictLot_;
  }

  LegalDescription::DistrictLot_optional& LegalDescription::
  DistrictLot ()
  {
    return this->DistrictLot_;
  }

  void LegalDescription::
  DistrictLot (const DistrictLot_type& x)
  {
    this->DistrictLot_.set (x);
  }

  void LegalDescription::
  DistrictLot (const DistrictLot_optional& x)
  {
    this->DistrictLot_ = x;
  }

  void LegalDescription::
  DistrictLot (::std::unique_ptr< DistrictLot_type > x)
  {
    this->DistrictLot_.set (std::move (x));
  }

  const LegalDescription::LegalSubdivision_optional& LegalDescription::
  LegalSubdivision () const
  {
    return this->LegalSubdivision_;
  }

  LegalDescription::LegalSubdivision_optional& LegalDescription::
  LegalSubdivision ()
  {
    return this->LegalSubdivision_;
  }

  void LegalDescription::
  LegalSubdivision (const LegalSubdivision_type& x)
  {
    this->LegalSubdivision_.set (x);
  }

  void LegalDescription::
  LegalSubdivision (const LegalSubdivision_optional& x)
  {
    this->LegalSubdivision_ = x;
  }

  void LegalDescription::
  LegalSubdivision (::std::unique_ptr< LegalSubdivision_type > x)
  {
    this->LegalSubdivision_.set (std::move (x));
  }

  const LegalDescription::Section_optional& LegalDescription::
  Section () const
  {
    return this->Section_;
  }

  LegalDescription::Section_optional& LegalDescription::
  Section ()
  {
    return this->Section_;
  }

  void LegalDescription::
  Section (const Section_type& x)
  {
    this->Section_.set (x);
  }

  void LegalDescription::
  Section (const Section_optional& x)
  {
    this->Section_ = x;
  }

  void LegalDescription::
  Section (::std::unique_ptr< Section_type > x)
  {
    this->Section_.set (std::move (x));
  }

  const LegalDescription::Township_optional& LegalDescription::
  Township () const
  {
    return this->Township_;
  }

  LegalDescription::Township_optional& LegalDescription::
  Township ()
  {
    return this->Township_;
  }

  void LegalDescription::
  Township (const Township_type& x)
  {
    this->Township_.set (x);
  }

  void LegalDescription::
  Township (const Township_optional& x)
  {
    this->Township_ = x;
  }

  void LegalDescription::
  Township (::std::unique_ptr< Township_type > x)
  {
    this->Township_.set (std::move (x));
  }

  const LegalDescription::Range_optional& LegalDescription::
  Range () const
  {
    return this->Range_;
  }

  LegalDescription::Range_optional& LegalDescription::
  Range ()
  {
    return this->Range_;
  }

  void LegalDescription::
  Range (const Range_type& x)
  {
    this->Range_.set (x);
  }

  void LegalDescription::
  Range (const Range_optional& x)
  {
    this->Range_ = x;
  }

  void LegalDescription::
  Range (::std::unique_ptr< Range_type > x)
  {
    this->Range_.set (std::move (x));
  }

  const LegalDescription::Meridian_optional& LegalDescription::
  Meridian () const
  {
    return this->Meridian_;
  }

  LegalDescription::Meridian_optional& LegalDescription::
  Meridian ()
  {
    return this->Meridian_;
  }

  void LegalDescription::
  Meridian (const Meridian_type& x)
  {
    this->Meridian_.set (x);
  }

  void LegalDescription::
  Meridian (const Meridian_optional& x)
  {
    this->Meridian_ = x;
  }

  void LegalDescription::
  Meridian (::std::unique_ptr< Meridian_type > x)
  {
    this->Meridian_.set (std::move (x));
  }

  const LegalDescription::MeridianShort_optional& LegalDescription::
  MeridianShort () const
  {
    return this->MeridianShort_;
  }

  LegalDescription::MeridianShort_optional& LegalDescription::
  MeridianShort ()
  {
    return this->MeridianShort_;
  }

  void LegalDescription::
  MeridianShort (const MeridianShort_type& x)
  {
    this->MeridianShort_.set (x);
  }

  void LegalDescription::
  MeridianShort (const MeridianShort_optional& x)
  {
    this->MeridianShort_ = x;
  }

  void LegalDescription::
  MeridianShort (::std::unique_ptr< MeridianShort_type > x)
  {
    this->MeridianShort_.set (std::move (x));
  }

  const LegalDescription::BCAGroup_optional& LegalDescription::
  BCAGroup () const
  {
    return this->BCAGroup_;
  }

  LegalDescription::BCAGroup_optional& LegalDescription::
  BCAGroup ()
  {
    return this->BCAGroup_;
  }

  void LegalDescription::
  BCAGroup (const BCAGroup_type& x)
  {
    this->BCAGroup_.set (x);
  }

  void LegalDescription::
  BCAGroup (const BCAGroup_optional& x)
  {
    this->BCAGroup_ = x;
  }

  void LegalDescription::
  BCAGroup (::std::unique_ptr< BCAGroup_type > x)
  {
    this->BCAGroup_.set (std::move (x));
  }

  const LegalDescription::LandDistrict_optional& LegalDescription::
  LandDistrict () const
  {
    return this->LandDistrict_;
  }

  LegalDescription::LandDistrict_optional& LegalDescription::
  LandDistrict ()
  {
    return this->LandDistrict_;
  }

  void LegalDescription::
  LandDistrict (const LandDistrict_type& x)
  {
    this->LandDistrict_.set (x);
  }

  void LegalDescription::
  LandDistrict (const LandDistrict_optional& x)
  {
    this->LandDistrict_ = x;
  }

  void LegalDescription::
  LandDistrict (::std::unique_ptr< LandDistrict_type > x)
  {
    this->LandDistrict_.set (std::move (x));
  }

  const LegalDescription::LandDistrictDescription_optional& LegalDescription::
  LandDistrictDescription () const
  {
    return this->LandDistrictDescription_;
  }

  LegalDescription::LandDistrictDescription_optional& LegalDescription::
  LandDistrictDescription ()
  {
    return this->LandDistrictDescription_;
  }

  void LegalDescription::
  LandDistrictDescription (const LandDistrictDescription_type& x)
  {
    this->LandDistrictDescription_.set (x);
  }

  void LegalDescription::
  LandDistrictDescription (const LandDistrictDescription_optional& x)
  {
    this->LandDistrictDescription_ = x;
  }

  void LegalDescription::
  LandDistrictDescription (::std::unique_ptr< LandDistrictDescription_type > x)
  {
    this->LandDistrictDescription_.set (std::move (x));
  }

  const LegalDescription::Portion_optional& LegalDescription::
  Portion () const
  {
    return this->Portion_;
  }

  LegalDescription::Portion_optional& LegalDescription::
  Portion ()
  {
    return this->Portion_;
  }

  void LegalDescription::
  Portion (const Portion_type& x)
  {
    this->Portion_.set (x);
  }

  void LegalDescription::
  Portion (const Portion_optional& x)
  {
    this->Portion_ = x;
  }

  void LegalDescription::
  Portion (::std::unique_ptr< Portion_type > x)
  {
    this->Portion_.set (std::move (x));
  }

  const LegalDescription::ExceptPlan_optional& LegalDescription::
  ExceptPlan () const
  {
    return this->ExceptPlan_;
  }

  LegalDescription::ExceptPlan_optional& LegalDescription::
  ExceptPlan ()
  {
    return this->ExceptPlan_;
  }

  void LegalDescription::
  ExceptPlan (const ExceptPlan_type& x)
  {
    this->ExceptPlan_.set (x);
  }

  void LegalDescription::
  ExceptPlan (const ExceptPlan_optional& x)
  {
    this->ExceptPlan_ = x;
  }

  void LegalDescription::
  ExceptPlan (::std::unique_ptr< ExceptPlan_type > x)
  {
    this->ExceptPlan_.set (std::move (x));
  }

  const LegalDescription::FirstNationReserveNumber_optional& LegalDescription::
  FirstNationReserveNumber () const
  {
    return this->FirstNationReserveNumber_;
  }

  LegalDescription::FirstNationReserveNumber_optional& LegalDescription::
  FirstNationReserveNumber ()
  {
    return this->FirstNationReserveNumber_;
  }

  void LegalDescription::
  FirstNationReserveNumber (const FirstNationReserveNumber_type& x)
  {
    this->FirstNationReserveNumber_.set (x);
  }

  void LegalDescription::
  FirstNationReserveNumber (const FirstNationReserveNumber_optional& x)
  {
    this->FirstNationReserveNumber_ = x;
  }

  void LegalDescription::
  FirstNationReserveNumber (::std::unique_ptr< FirstNationReserveNumber_type > x)
  {
    this->FirstNationReserveNumber_.set (std::move (x));
  }

  const LegalDescription::FirstNationReserveDescription_optional& LegalDescription::
  FirstNationReserveDescription () const
  {
    return this->FirstNationReserveDescription_;
  }

  LegalDescription::FirstNationReserveDescription_optional& LegalDescription::
  FirstNationReserveDescription ()
  {
    return this->FirstNationReserveDescription_;
  }

  void LegalDescription::
  FirstNationReserveDescription (const FirstNationReserveDescription_type& x)
  {
    this->FirstNationReserveDescription_.set (x);
  }

  void LegalDescription::
  FirstNationReserveDescription (const FirstNationReserveDescription_optional& x)
  {
    this->FirstNationReserveDescription_ = x;
  }

  void LegalDescription::
  FirstNationReserveDescription (::std::unique_ptr< FirstNationReserveDescription_type > x)
  {
    this->FirstNationReserveDescription_.set (std::move (x));
  }

  const LegalDescription::LeaseLicenceNumber_optional& LegalDescription::
  LeaseLicenceNumber () const
  {
    return this->LeaseLicenceNumber_;
  }

  LegalDescription::LeaseLicenceNumber_optional& LegalDescription::
  LeaseLicenceNumber ()
  {
    return this->LeaseLicenceNumber_;
  }

  void LegalDescription::
  LeaseLicenceNumber (const LeaseLicenceNumber_type& x)
  {
    this->LeaseLicenceNumber_.set (x);
  }

  void LegalDescription::
  LeaseLicenceNumber (const LeaseLicenceNumber_optional& x)
  {
    this->LeaseLicenceNumber_ = x;
  }

  void LegalDescription::
  LeaseLicenceNumber (::std::unique_ptr< LeaseLicenceNumber_type > x)
  {
    this->LeaseLicenceNumber_.set (std::move (x));
  }

  const LegalDescription::LandBranchFileNumber_optional& LegalDescription::
  LandBranchFileNumber () const
  {
    return this->LandBranchFileNumber_;
  }

  LegalDescription::LandBranchFileNumber_optional& LegalDescription::
  LandBranchFileNumber ()
  {
    return this->LandBranchFileNumber_;
  }

  void LegalDescription::
  LandBranchFileNumber (const LandBranchFileNumber_type& x)
  {
    this->LandBranchFileNumber_.set (x);
  }

  void LegalDescription::
  LandBranchFileNumber (const LandBranchFileNumber_optional& x)
  {
    this->LandBranchFileNumber_ = x;
  }

  void LegalDescription::
  LandBranchFileNumber (::std::unique_ptr< LandBranchFileNumber_type > x)
  {
    this->LandBranchFileNumber_.set (std::move (x));
  }

  const LegalDescription::AirSpaceParcelNumber_optional& LegalDescription::
  AirSpaceParcelNumber () const
  {
    return this->AirSpaceParcelNumber_;
  }

  LegalDescription::AirSpaceParcelNumber_optional& LegalDescription::
  AirSpaceParcelNumber ()
  {
    return this->AirSpaceParcelNumber_;
  }

  void LegalDescription::
  AirSpaceParcelNumber (const AirSpaceParcelNumber_type& x)
  {
    this->AirSpaceParcelNumber_.set (x);
  }

  void LegalDescription::
  AirSpaceParcelNumber (const AirSpaceParcelNumber_optional& x)
  {
    this->AirSpaceParcelNumber_ = x;
  }

  void LegalDescription::
  AirSpaceParcelNumber (::std::unique_ptr< AirSpaceParcelNumber_type > x)
  {
    this->AirSpaceParcelNumber_.set (std::move (x));
  }

  const LegalDescription::LegalText_optional& LegalDescription::
  LegalText () const
  {
    return this->LegalText_;
  }

  LegalDescription::LegalText_optional& LegalDescription::
  LegalText ()
  {
    return this->LegalText_;
  }

  void LegalDescription::
  LegalText (const LegalText_type& x)
  {
    this->LegalText_.set (x);
  }

  void LegalDescription::
  LegalText (const LegalText_optional& x)
  {
    this->LegalText_ = x;
  }

  void LegalDescription::
  LegalText (::std::unique_ptr< LegalText_type > x)
  {
    this->LegalText_.set (std::move (x));
  }


  // LandCharacteristic
  // 

  const LandCharacteristic::LandCharacteristicCode_optional& LandCharacteristic::
  LandCharacteristicCode () const
  {
    return this->LandCharacteristicCode_;
  }

  LandCharacteristic::LandCharacteristicCode_optional& LandCharacteristic::
  LandCharacteristicCode ()
  {
    return this->LandCharacteristicCode_;
  }

  void LandCharacteristic::
  LandCharacteristicCode (const LandCharacteristicCode_type& x)
  {
    this->LandCharacteristicCode_.set (x);
  }

  void LandCharacteristic::
  LandCharacteristicCode (const LandCharacteristicCode_optional& x)
  {
    this->LandCharacteristicCode_ = x;
  }

  void LandCharacteristic::
  LandCharacteristicCode (::std::unique_ptr< LandCharacteristicCode_type > x)
  {
    this->LandCharacteristicCode_.set (std::move (x));
  }

  const LandCharacteristic::LandCharacteristicDescription_optional& LandCharacteristic::
  LandCharacteristicDescription () const
  {
    return this->LandCharacteristicDescription_;
  }

  LandCharacteristic::LandCharacteristicDescription_optional& LandCharacteristic::
  LandCharacteristicDescription ()
  {
    return this->LandCharacteristicDescription_;
  }

  void LandCharacteristic::
  LandCharacteristicDescription (const LandCharacteristicDescription_type& x)
  {
    this->LandCharacteristicDescription_.set (x);
  }

  void LandCharacteristic::
  LandCharacteristicDescription (const LandCharacteristicDescription_optional& x)
  {
    this->LandCharacteristicDescription_ = x;
  }

  void LandCharacteristic::
  LandCharacteristicDescription (::std::unique_ptr< LandCharacteristicDescription_type > x)
  {
    this->LandCharacteristicDescription_.set (std::move (x));
  }


  // LandCharacteristicCollection
  // 

  const LandCharacteristicCollection::LandCharacteristic_sequence& LandCharacteristicCollection::
  LandCharacteristic () const
  {
    return this->LandCharacteristic_;
  }

  LandCharacteristicCollection::LandCharacteristic_sequence& LandCharacteristicCollection::
  LandCharacteristic ()
  {
    return this->LandCharacteristic_;
  }

  void LandCharacteristicCollection::
  LandCharacteristic (const LandCharacteristic_sequence& s)
  {
    this->LandCharacteristic_ = s;
  }


  // ManufacturedHomeCollection
  // 

  const ManufacturedHomeCollection::ManufacturedHome_sequence& ManufacturedHomeCollection::
  ManufacturedHome () const
  {
    return this->ManufacturedHome_;
  }

  ManufacturedHomeCollection::ManufacturedHome_sequence& ManufacturedHomeCollection::
  ManufacturedHome ()
  {
    return this->ManufacturedHome_;
  }

  void ManufacturedHomeCollection::
  ManufacturedHome (const ManufacturedHome_sequence& s)
  {
    this->ManufacturedHome_ = s;
  }


  // ManufacturedHome
  // 

  const ManufacturedHome::MHRegistryNumber_optional& ManufacturedHome::
  MHRegistryNumber () const
  {
    return this->MHRegistryNumber_;
  }

  ManufacturedHome::MHRegistryNumber_optional& ManufacturedHome::
  MHRegistryNumber ()
  {
    return this->MHRegistryNumber_;
  }

  void ManufacturedHome::
  MHRegistryNumber (const MHRegistryNumber_type& x)
  {
    this->MHRegistryNumber_.set (x);
  }

  void ManufacturedHome::
  MHRegistryNumber (const MHRegistryNumber_optional& x)
  {
    this->MHRegistryNumber_ = x;
  }

  void ManufacturedHome::
  MHRegistryNumber (::std::unique_ptr< MHRegistryNumber_type > x)
  {
    this->MHRegistryNumber_.set (std::move (x));
  }

  const ManufacturedHome::MHBayNumber_optional& ManufacturedHome::
  MHBayNumber () const
  {
    return this->MHBayNumber_;
  }

  ManufacturedHome::MHBayNumber_optional& ManufacturedHome::
  MHBayNumber ()
  {
    return this->MHBayNumber_;
  }

  void ManufacturedHome::
  MHBayNumber (const MHBayNumber_type& x)
  {
    this->MHBayNumber_.set (x);
  }

  void ManufacturedHome::
  MHBayNumber (const MHBayNumber_optional& x)
  {
    this->MHBayNumber_ = x;
  }

  void ManufacturedHome::
  MHBayNumber (::std::unique_ptr< MHBayNumber_type > x)
  {
    this->MHBayNumber_.set (std::move (x));
  }

  const ManufacturedHome::MHPark_optional& ManufacturedHome::
  MHPark () const
  {
    return this->MHPark_;
  }

  ManufacturedHome::MHPark_optional& ManufacturedHome::
  MHPark ()
  {
    return this->MHPark_;
  }

  void ManufacturedHome::
  MHPark (const MHPark_type& x)
  {
    this->MHPark_.set (x);
  }

  void ManufacturedHome::
  MHPark (const MHPark_optional& x)
  {
    this->MHPark_ = x;
  }

  void ManufacturedHome::
  MHPark (::std::unique_ptr< MHPark_type > x)
  {
    this->MHPark_.set (std::move (x));
  }

  const ManufacturedHome::MHParkRollNumber_optional& ManufacturedHome::
  MHParkRollNumber () const
  {
    return this->MHParkRollNumber_;
  }

  ManufacturedHome::MHParkRollNumber_optional& ManufacturedHome::
  MHParkRollNumber ()
  {
    return this->MHParkRollNumber_;
  }

  void ManufacturedHome::
  MHParkRollNumber (const MHParkRollNumber_type& x)
  {
    this->MHParkRollNumber_.set (x);
  }

  void ManufacturedHome::
  MHParkRollNumber (const MHParkRollNumber_optional& x)
  {
    this->MHParkRollNumber_ = x;
  }

  void ManufacturedHome::
  MHParkRollNumber (::std::unique_ptr< MHParkRollNumber_type > x)
  {
    this->MHParkRollNumber_.set (std::move (x));
  }


  // FarmCollection
  // 

  const FarmCollection::Farm_sequence& FarmCollection::
  Farm () const
  {
    return this->Farm_;
  }

  FarmCollection::Farm_sequence& FarmCollection::
  Farm ()
  {
    return this->Farm_;
  }

  void FarmCollection::
  Farm (const Farm_sequence& s)
  {
    this->Farm_ = s;
  }


  // Farm
  // 

  const Farm::FarmNumber_sequence& Farm::
  FarmNumber () const
  {
    return this->FarmNumber_;
  }

  Farm::FarmNumber_sequence& Farm::
  FarmNumber ()
  {
    return this->FarmNumber_;
  }

  void Farm::
  FarmNumber (const FarmNumber_sequence& s)
  {
    this->FarmNumber_ = s;
  }


  // OilAndGasCollection
  // 

  const OilAndGasCollection::OilAndGas_sequence& OilAndGasCollection::
  OilAndGas () const
  {
    return this->OilAndGas_;
  }

  OilAndGasCollection::OilAndGas_sequence& OilAndGasCollection::
  OilAndGas ()
  {
    return this->OilAndGas_;
  }

  void OilAndGasCollection::
  OilAndGas (const OilAndGas_sequence& s)
  {
    this->OilAndGas_ = s;
  }


  // OilAndGas
  // 

  const OilAndGas::PipelineProjectNumber_optional& OilAndGas::
  PipelineProjectNumber () const
  {
    return this->PipelineProjectNumber_;
  }

  OilAndGas::PipelineProjectNumber_optional& OilAndGas::
  PipelineProjectNumber ()
  {
    return this->PipelineProjectNumber_;
  }

  void OilAndGas::
  PipelineProjectNumber (const PipelineProjectNumber_type& x)
  {
    this->PipelineProjectNumber_.set (x);
  }

  void OilAndGas::
  PipelineProjectNumber (const PipelineProjectNumber_optional& x)
  {
    this->PipelineProjectNumber_ = x;
  }

  void OilAndGas::
  PipelineProjectNumber (::std::unique_ptr< PipelineProjectNumber_type > x)
  {
    this->PipelineProjectNumber_.set (std::move (x));
  }


  // ManagedForestCollection
  // 

  const ManagedForestCollection::ManagedForest_sequence& ManagedForestCollection::
  ManagedForest () const
  {
    return this->ManagedForest_;
  }

  ManagedForestCollection::ManagedForest_sequence& ManagedForestCollection::
  ManagedForest ()
  {
    return this->ManagedForest_;
  }

  void ManagedForestCollection::
  ManagedForest (const ManagedForest_sequence& s)
  {
    this->ManagedForest_ = s;
  }


  // ManagedForest
  // 

  const ManagedForest::ManagedForestNumber_optional& ManagedForest::
  ManagedForestNumber () const
  {
    return this->ManagedForestNumber_;
  }

  ManagedForest::ManagedForestNumber_optional& ManagedForest::
  ManagedForestNumber ()
  {
    return this->ManagedForestNumber_;
  }

  void ManagedForest::
  ManagedForestNumber (const ManagedForestNumber_type& x)
  {
    this->ManagedForestNumber_.set (x);
  }

  void ManagedForest::
  ManagedForestNumber (const ManagedForestNumber_optional& x)
  {
    this->ManagedForestNumber_ = x;
  }

  void ManagedForest::
  ManagedForestNumber (::std::unique_ptr< ManagedForestNumber_type > x)
  {
    this->ManagedForestNumber_.set (std::move (x));
  }


  // FolioAmendmentCollection
  // 

  const FolioAmendmentCollection::Amendment_sequence& FolioAmendmentCollection::
  Amendment () const
  {
    return this->Amendment_;
  }

  FolioAmendmentCollection::Amendment_sequence& FolioAmendmentCollection::
  Amendment ()
  {
    return this->Amendment_;
  }

  void FolioAmendmentCollection::
  Amendment (const Amendment_sequence& s)
  {
    this->Amendment_ = s;
  }


  // FolioAmendment
  // 

  const FolioAmendment::AmendmentType_optional& FolioAmendment::
  AmendmentType () const
  {
    return this->AmendmentType_;
  }

  FolioAmendment::AmendmentType_optional& FolioAmendment::
  AmendmentType ()
  {
    return this->AmendmentType_;
  }

  void FolioAmendment::
  AmendmentType (const AmendmentType_type& x)
  {
    this->AmendmentType_.set (x);
  }

  void FolioAmendment::
  AmendmentType (const AmendmentType_optional& x)
  {
    this->AmendmentType_ = x;
  }

  void FolioAmendment::
  AmendmentType (::std::unique_ptr< AmendmentType_type > x)
  {
    this->AmendmentType_.set (std::move (x));
  }

  const FolioAmendment::AmendmentTypeDescription_optional& FolioAmendment::
  AmendmentTypeDescription () const
  {
    return this->AmendmentTypeDescription_;
  }

  FolioAmendment::AmendmentTypeDescription_optional& FolioAmendment::
  AmendmentTypeDescription ()
  {
    return this->AmendmentTypeDescription_;
  }

  void FolioAmendment::
  AmendmentTypeDescription (const AmendmentTypeDescription_type& x)
  {
    this->AmendmentTypeDescription_.set (x);
  }

  void FolioAmendment::
  AmendmentTypeDescription (const AmendmentTypeDescription_optional& x)
  {
    this->AmendmentTypeDescription_ = x;
  }

  void FolioAmendment::
  AmendmentTypeDescription (::std::unique_ptr< AmendmentTypeDescription_type > x)
  {
    this->AmendmentTypeDescription_.set (std::move (x));
  }

  const FolioAmendment::AmendmentReasonCode_optional& FolioAmendment::
  AmendmentReasonCode () const
  {
    return this->AmendmentReasonCode_;
  }

  FolioAmendment::AmendmentReasonCode_optional& FolioAmendment::
  AmendmentReasonCode ()
  {
    return this->AmendmentReasonCode_;
  }

  void FolioAmendment::
  AmendmentReasonCode (const AmendmentReasonCode_type& x)
  {
    this->AmendmentReasonCode_.set (x);
  }

  void FolioAmendment::
  AmendmentReasonCode (const AmendmentReasonCode_optional& x)
  {
    this->AmendmentReasonCode_ = x;
  }

  void FolioAmendment::
  AmendmentReasonCode (::std::unique_ptr< AmendmentReasonCode_type > x)
  {
    this->AmendmentReasonCode_.set (std::move (x));
  }

  const FolioAmendment::AmendmentReasonDescription_optional& FolioAmendment::
  AmendmentReasonDescription () const
  {
    return this->AmendmentReasonDescription_;
  }

  FolioAmendment::AmendmentReasonDescription_optional& FolioAmendment::
  AmendmentReasonDescription ()
  {
    return this->AmendmentReasonDescription_;
  }

  void FolioAmendment::
  AmendmentReasonDescription (const AmendmentReasonDescription_type& x)
  {
    this->AmendmentReasonDescription_.set (x);
  }

  void FolioAmendment::
  AmendmentReasonDescription (const AmendmentReasonDescription_optional& x)
  {
    this->AmendmentReasonDescription_ = x;
  }

  void FolioAmendment::
  AmendmentReasonDescription (::std::unique_ptr< AmendmentReasonDescription_type > x)
  {
    this->AmendmentReasonDescription_.set (std::move (x));
  }

  const FolioAmendment::SuppOccupancyDate_optional& FolioAmendment::
  SuppOccupancyDate () const
  {
    return this->SuppOccupancyDate_;
  }

  FolioAmendment::SuppOccupancyDate_optional& FolioAmendment::
  SuppOccupancyDate ()
  {
    return this->SuppOccupancyDate_;
  }

  void FolioAmendment::
  SuppOccupancyDate (const SuppOccupancyDate_type& x)
  {
    this->SuppOccupancyDate_.set (x);
  }

  void FolioAmendment::
  SuppOccupancyDate (const SuppOccupancyDate_optional& x)
  {
    this->SuppOccupancyDate_ = x;
  }

  void FolioAmendment::
  SuppOccupancyDate (::std::unique_ptr< SuppOccupancyDate_type > x)
  {
    this->SuppOccupancyDate_.set (std::move (x));
  }

  const FolioAmendment::SuppOccupancyCode_optional& FolioAmendment::
  SuppOccupancyCode () const
  {
    return this->SuppOccupancyCode_;
  }

  FolioAmendment::SuppOccupancyCode_optional& FolioAmendment::
  SuppOccupancyCode ()
  {
    return this->SuppOccupancyCode_;
  }

  void FolioAmendment::
  SuppOccupancyCode (const SuppOccupancyCode_type& x)
  {
    this->SuppOccupancyCode_.set (x);
  }

  void FolioAmendment::
  SuppOccupancyCode (const SuppOccupancyCode_optional& x)
  {
    this->SuppOccupancyCode_ = x;
  }

  void FolioAmendment::
  SuppOccupancyCode (::std::unique_ptr< SuppOccupancyCode_type > x)
  {
    this->SuppOccupancyCode_.set (std::move (x));
  }


  // SaleCollection
  // 

  const SaleCollection::Sale_sequence& SaleCollection::
  Sale () const
  {
    return this->Sale_;
  }

  SaleCollection::Sale_sequence& SaleCollection::
  Sale ()
  {
    return this->Sale_;
  }

  void SaleCollection::
  Sale (const Sale_sequence& s)
  {
    this->Sale_ = s;
  }


  // Sale
  // 

  const Sale::DocumentNumber_optional& Sale::
  DocumentNumber () const
  {
    return this->DocumentNumber_;
  }

  Sale::DocumentNumber_optional& Sale::
  DocumentNumber ()
  {
    return this->DocumentNumber_;
  }

  void Sale::
  DocumentNumber (const DocumentNumber_type& x)
  {
    this->DocumentNumber_.set (x);
  }

  void Sale::
  DocumentNumber (const DocumentNumber_optional& x)
  {
    this->DocumentNumber_ = x;
  }

  void Sale::
  DocumentNumber (::std::unique_ptr< DocumentNumber_type > x)
  {
    this->DocumentNumber_.set (std::move (x));
  }

  const Sale::ConveyanceDate_optional& Sale::
  ConveyanceDate () const
  {
    return this->ConveyanceDate_;
  }

  Sale::ConveyanceDate_optional& Sale::
  ConveyanceDate ()
  {
    return this->ConveyanceDate_;
  }

  void Sale::
  ConveyanceDate (const ConveyanceDate_type& x)
  {
    this->ConveyanceDate_.set (x);
  }

  void Sale::
  ConveyanceDate (const ConveyanceDate_optional& x)
  {
    this->ConveyanceDate_ = x;
  }

  void Sale::
  ConveyanceDate (::std::unique_ptr< ConveyanceDate_type > x)
  {
    this->ConveyanceDate_.set (std::move (x));
  }

  const Sale::ConveyancePrice_optional& Sale::
  ConveyancePrice () const
  {
    return this->ConveyancePrice_;
  }

  Sale::ConveyancePrice_optional& Sale::
  ConveyancePrice ()
  {
    return this->ConveyancePrice_;
  }

  void Sale::
  ConveyancePrice (const ConveyancePrice_type& x)
  {
    this->ConveyancePrice_.set (x);
  }

  void Sale::
  ConveyancePrice (const ConveyancePrice_optional& x)
  {
    this->ConveyancePrice_ = x;
  }

  void Sale::
  ConveyancePrice (::std::unique_ptr< ConveyancePrice_type > x)
  {
    this->ConveyancePrice_.set (std::move (x));
  }

  const Sale::ConveyanceType_optional& Sale::
  ConveyanceType () const
  {
    return this->ConveyanceType_;
  }

  Sale::ConveyanceType_optional& Sale::
  ConveyanceType ()
  {
    return this->ConveyanceType_;
  }

  void Sale::
  ConveyanceType (const ConveyanceType_type& x)
  {
    this->ConveyanceType_.set (x);
  }

  void Sale::
  ConveyanceType (const ConveyanceType_optional& x)
  {
    this->ConveyanceType_ = x;
  }

  void Sale::
  ConveyanceType (::std::unique_ptr< ConveyanceType_type > x)
  {
    this->ConveyanceType_.set (std::move (x));
  }

  const Sale::ConveyanceTypeDescription_optional& Sale::
  ConveyanceTypeDescription () const
  {
    return this->ConveyanceTypeDescription_;
  }

  Sale::ConveyanceTypeDescription_optional& Sale::
  ConveyanceTypeDescription ()
  {
    return this->ConveyanceTypeDescription_;
  }

  void Sale::
  ConveyanceTypeDescription (const ConveyanceTypeDescription_type& x)
  {
    this->ConveyanceTypeDescription_.set (x);
  }

  void Sale::
  ConveyanceTypeDescription (const ConveyanceTypeDescription_optional& x)
  {
    this->ConveyanceTypeDescription_ = x;
  }

  void Sale::
  ConveyanceTypeDescription (::std::unique_ptr< ConveyanceTypeDescription_type > x)
  {
    this->ConveyanceTypeDescription_.set (std::move (x));
  }

  const Sale::RejectReasonCode_optional& Sale::
  RejectReasonCode () const
  {
    return this->RejectReasonCode_;
  }

  Sale::RejectReasonCode_optional& Sale::
  RejectReasonCode ()
  {
    return this->RejectReasonCode_;
  }

  void Sale::
  RejectReasonCode (const RejectReasonCode_type& x)
  {
    this->RejectReasonCode_.set (x);
  }

  void Sale::
  RejectReasonCode (const RejectReasonCode_optional& x)
  {
    this->RejectReasonCode_ = x;
  }

  void Sale::
  RejectReasonCode (::std::unique_ptr< RejectReasonCode_type > x)
  {
    this->RejectReasonCode_.set (std::move (x));
  }

  const Sale::RejectReasonDescription_optional& Sale::
  RejectReasonDescription () const
  {
    return this->RejectReasonDescription_;
  }

  Sale::RejectReasonDescription_optional& Sale::
  RejectReasonDescription ()
  {
    return this->RejectReasonDescription_;
  }

  void Sale::
  RejectReasonDescription (const RejectReasonDescription_type& x)
  {
    this->RejectReasonDescription_.set (x);
  }

  void Sale::
  RejectReasonDescription (const RejectReasonDescription_optional& x)
  {
    this->RejectReasonDescription_ = x;
  }

  void Sale::
  RejectReasonDescription (::std::unique_ptr< RejectReasonDescription_type > x)
  {
    this->RejectReasonDescription_.set (std::move (x));
  }


  // FolioDescription
  // 

  const FolioDescription::Neighbourhood_optional& FolioDescription::
  Neighbourhood () const
  {
    return this->Neighbourhood_;
  }

  FolioDescription::Neighbourhood_optional& FolioDescription::
  Neighbourhood ()
  {
    return this->Neighbourhood_;
  }

  void FolioDescription::
  Neighbourhood (const Neighbourhood_type& x)
  {
    this->Neighbourhood_.set (x);
  }

  void FolioDescription::
  Neighbourhood (const Neighbourhood_optional& x)
  {
    this->Neighbourhood_ = x;
  }

  void FolioDescription::
  Neighbourhood (::std::unique_ptr< Neighbourhood_type > x)
  {
    this->Neighbourhood_.set (std::move (x));
  }

  const FolioDescription::ActualUseCode_optional& FolioDescription::
  ActualUseCode () const
  {
    return this->ActualUseCode_;
  }

  FolioDescription::ActualUseCode_optional& FolioDescription::
  ActualUseCode ()
  {
    return this->ActualUseCode_;
  }

  void FolioDescription::
  ActualUseCode (const ActualUseCode_type& x)
  {
    this->ActualUseCode_.set (x);
  }

  void FolioDescription::
  ActualUseCode (const ActualUseCode_optional& x)
  {
    this->ActualUseCode_ = x;
  }

  void FolioDescription::
  ActualUseCode (::std::unique_ptr< ActualUseCode_type > x)
  {
    this->ActualUseCode_.set (std::move (x));
  }

  const FolioDescription::ActualUseDescription_optional& FolioDescription::
  ActualUseDescription () const
  {
    return this->ActualUseDescription_;
  }

  FolioDescription::ActualUseDescription_optional& FolioDescription::
  ActualUseDescription ()
  {
    return this->ActualUseDescription_;
  }

  void FolioDescription::
  ActualUseDescription (const ActualUseDescription_type& x)
  {
    this->ActualUseDescription_.set (x);
  }

  void FolioDescription::
  ActualUseDescription (const ActualUseDescription_optional& x)
  {
    this->ActualUseDescription_ = x;
  }

  void FolioDescription::
  ActualUseDescription (::std::unique_ptr< ActualUseDescription_type > x)
  {
    this->ActualUseDescription_.set (std::move (x));
  }

  const FolioDescription::VacantFlag_optional& FolioDescription::
  VacantFlag () const
  {
    return this->VacantFlag_;
  }

  FolioDescription::VacantFlag_optional& FolioDescription::
  VacantFlag ()
  {
    return this->VacantFlag_;
  }

  void FolioDescription::
  VacantFlag (const VacantFlag_type& x)
  {
    this->VacantFlag_.set (x);
  }

  void FolioDescription::
  VacantFlag (const VacantFlag_optional& x)
  {
    this->VacantFlag_ = x;
  }

  void FolioDescription::
  VacantFlag (::std::unique_ptr< VacantFlag_type > x)
  {
    this->VacantFlag_.set (std::move (x));
  }

  const FolioDescription::BCTransitFlag_optional& FolioDescription::
  BCTransitFlag () const
  {
    return this->BCTransitFlag_;
  }

  FolioDescription::BCTransitFlag_optional& FolioDescription::
  BCTransitFlag ()
  {
    return this->BCTransitFlag_;
  }

  void FolioDescription::
  BCTransitFlag (const BCTransitFlag_type& x)
  {
    this->BCTransitFlag_.set (x);
  }

  void FolioDescription::
  BCTransitFlag (const BCTransitFlag_optional& x)
  {
    this->BCTransitFlag_ = x;
  }

  void FolioDescription::
  BCTransitFlag (::std::unique_ptr< BCTransitFlag_type > x)
  {
    this->BCTransitFlag_.set (std::move (x));
  }

  const FolioDescription::PoliceTaxFlag_optional& FolioDescription::
  PoliceTaxFlag () const
  {
    return this->PoliceTaxFlag_;
  }

  FolioDescription::PoliceTaxFlag_optional& FolioDescription::
  PoliceTaxFlag ()
  {
    return this->PoliceTaxFlag_;
  }

  void FolioDescription::
  PoliceTaxFlag (const PoliceTaxFlag_type& x)
  {
    this->PoliceTaxFlag_.set (x);
  }

  void FolioDescription::
  PoliceTaxFlag (const PoliceTaxFlag_optional& x)
  {
    this->PoliceTaxFlag_ = x;
  }

  void FolioDescription::
  PoliceTaxFlag (::std::unique_ptr< PoliceTaxFlag_type > x)
  {
    this->PoliceTaxFlag_.set (std::move (x));
  }

  const FolioDescription::ALRCode_optional& FolioDescription::
  ALRCode () const
  {
    return this->ALRCode_;
  }

  FolioDescription::ALRCode_optional& FolioDescription::
  ALRCode ()
  {
    return this->ALRCode_;
  }

  void FolioDescription::
  ALRCode (const ALRCode_type& x)
  {
    this->ALRCode_.set (x);
  }

  void FolioDescription::
  ALRCode (const ALRCode_optional& x)
  {
    this->ALRCode_ = x;
  }

  void FolioDescription::
  ALRCode (::std::unique_ptr< ALRCode_type > x)
  {
    this->ALRCode_.set (std::move (x));
  }

  const FolioDescription::ALRDescription_optional& FolioDescription::
  ALRDescription () const
  {
    return this->ALRDescription_;
  }

  FolioDescription::ALRDescription_optional& FolioDescription::
  ALRDescription ()
  {
    return this->ALRDescription_;
  }

  void FolioDescription::
  ALRDescription (const ALRDescription_type& x)
  {
    this->ALRDescription_.set (x);
  }

  void FolioDescription::
  ALRDescription (const ALRDescription_optional& x)
  {
    this->ALRDescription_ = x;
  }

  void FolioDescription::
  ALRDescription (::std::unique_ptr< ALRDescription_type > x)
  {
    this->ALRDescription_.set (std::move (x));
  }

  const FolioDescription::ParkingArea_optional& FolioDescription::
  ParkingArea () const
  {
    return this->ParkingArea_;
  }

  FolioDescription::ParkingArea_optional& FolioDescription::
  ParkingArea ()
  {
    return this->ParkingArea_;
  }

  void FolioDescription::
  ParkingArea (const ParkingArea_type& x)
  {
    this->ParkingArea_.set (x);
  }

  void FolioDescription::
  ParkingArea (const ParkingArea_optional& x)
  {
    this->ParkingArea_ = x;
  }

  void FolioDescription::
  ParkingArea (::std::unique_ptr< ParkingArea_type > x)
  {
    this->ParkingArea_.set (std::move (x));
  }

  const FolioDescription::LandMeasurement_optional& FolioDescription::
  LandMeasurement () const
  {
    return this->LandMeasurement_;
  }

  FolioDescription::LandMeasurement_optional& FolioDescription::
  LandMeasurement ()
  {
    return this->LandMeasurement_;
  }

  void FolioDescription::
  LandMeasurement (const LandMeasurement_type& x)
  {
    this->LandMeasurement_.set (x);
  }

  void FolioDescription::
  LandMeasurement (const LandMeasurement_optional& x)
  {
    this->LandMeasurement_ = x;
  }

  void FolioDescription::
  LandMeasurement (::std::unique_ptr< LandMeasurement_type > x)
  {
    this->LandMeasurement_.set (std::move (x));
  }

  const FolioDescription::SchoolDistrict_optional& FolioDescription::
  SchoolDistrict () const
  {
    return this->SchoolDistrict_;
  }

  FolioDescription::SchoolDistrict_optional& FolioDescription::
  SchoolDistrict ()
  {
    return this->SchoolDistrict_;
  }

  void FolioDescription::
  SchoolDistrict (const SchoolDistrict_type& x)
  {
    this->SchoolDistrict_.set (x);
  }

  void FolioDescription::
  SchoolDistrict (const SchoolDistrict_optional& x)
  {
    this->SchoolDistrict_ = x;
  }

  void FolioDescription::
  SchoolDistrict (::std::unique_ptr< SchoolDistrict_type > x)
  {
    this->SchoolDistrict_.set (std::move (x));
  }

  const FolioDescription::RegionalDistrict_optional& FolioDescription::
  RegionalDistrict () const
  {
    return this->RegionalDistrict_;
  }

  FolioDescription::RegionalDistrict_optional& FolioDescription::
  RegionalDistrict ()
  {
    return this->RegionalDistrict_;
  }

  void FolioDescription::
  RegionalDistrict (const RegionalDistrict_type& x)
  {
    this->RegionalDistrict_.set (x);
  }

  void FolioDescription::
  RegionalDistrict (const RegionalDistrict_optional& x)
  {
    this->RegionalDistrict_ = x;
  }

  void FolioDescription::
  RegionalDistrict (::std::unique_ptr< RegionalDistrict_type > x)
  {
    this->RegionalDistrict_.set (std::move (x));
  }

  const FolioDescription::RegionalHospitalDistrict_optional& FolioDescription::
  RegionalHospitalDistrict () const
  {
    return this->RegionalHospitalDistrict_;
  }

  FolioDescription::RegionalHospitalDistrict_optional& FolioDescription::
  RegionalHospitalDistrict ()
  {
    return this->RegionalHospitalDistrict_;
  }

  void FolioDescription::
  RegionalHospitalDistrict (const RegionalHospitalDistrict_type& x)
  {
    this->RegionalHospitalDistrict_.set (x);
  }

  void FolioDescription::
  RegionalHospitalDistrict (const RegionalHospitalDistrict_optional& x)
  {
    this->RegionalHospitalDistrict_ = x;
  }

  void FolioDescription::
  RegionalHospitalDistrict (::std::unique_ptr< RegionalHospitalDistrict_type > x)
  {
    this->RegionalHospitalDistrict_.set (std::move (x));
  }

  const FolioDescription::PredominantManualClass_optional& FolioDescription::
  PredominantManualClass () const
  {
    return this->PredominantManualClass_;
  }

  FolioDescription::PredominantManualClass_optional& FolioDescription::
  PredominantManualClass ()
  {
    return this->PredominantManualClass_;
  }

  void FolioDescription::
  PredominantManualClass (const PredominantManualClass_type& x)
  {
    this->PredominantManualClass_.set (x);
  }

  void FolioDescription::
  PredominantManualClass (const PredominantManualClass_optional& x)
  {
    this->PredominantManualClass_ = x;
  }

  void FolioDescription::
  PredominantManualClass (::std::unique_ptr< PredominantManualClass_type > x)
  {
    this->PredominantManualClass_.set (std::move (x));
  }


  // LandMeasurement
  // 

  const LandMeasurement::LandDimensionType_optional& LandMeasurement::
  LandDimensionType () const
  {
    return this->LandDimensionType_;
  }

  LandMeasurement::LandDimensionType_optional& LandMeasurement::
  LandDimensionType ()
  {
    return this->LandDimensionType_;
  }

  void LandMeasurement::
  LandDimensionType (const LandDimensionType_type& x)
  {
    this->LandDimensionType_.set (x);
  }

  void LandMeasurement::
  LandDimensionType (const LandDimensionType_optional& x)
  {
    this->LandDimensionType_ = x;
  }

  void LandMeasurement::
  LandDimensionType (::std::unique_ptr< LandDimensionType_type > x)
  {
    this->LandDimensionType_.set (std::move (x));
  }

  const LandMeasurement::LandDimensionTypeDescription_optional& LandMeasurement::
  LandDimensionTypeDescription () const
  {
    return this->LandDimensionTypeDescription_;
  }

  LandMeasurement::LandDimensionTypeDescription_optional& LandMeasurement::
  LandDimensionTypeDescription ()
  {
    return this->LandDimensionTypeDescription_;
  }

  void LandMeasurement::
  LandDimensionTypeDescription (const LandDimensionTypeDescription_type& x)
  {
    this->LandDimensionTypeDescription_.set (x);
  }

  void LandMeasurement::
  LandDimensionTypeDescription (const LandDimensionTypeDescription_optional& x)
  {
    this->LandDimensionTypeDescription_ = x;
  }

  void LandMeasurement::
  LandDimensionTypeDescription (::std::unique_ptr< LandDimensionTypeDescription_type > x)
  {
    this->LandDimensionTypeDescription_.set (std::move (x));
  }

  const LandMeasurement::LandDimension_optional& LandMeasurement::
  LandDimension () const
  {
    return this->LandDimension_;
  }

  LandMeasurement::LandDimension_optional& LandMeasurement::
  LandDimension ()
  {
    return this->LandDimension_;
  }

  void LandMeasurement::
  LandDimension (const LandDimension_type& x)
  {
    this->LandDimension_.set (x);
  }

  void LandMeasurement::
  LandDimension (const LandDimension_optional& x)
  {
    this->LandDimension_ = x;
  }

  void LandMeasurement::
  LandDimension (::std::unique_ptr< LandDimension_type > x)
  {
    this->LandDimension_.set (std::move (x));
  }

  const LandMeasurement::LandWidth_optional& LandMeasurement::
  LandWidth () const
  {
    return this->LandWidth_;
  }

  LandMeasurement::LandWidth_optional& LandMeasurement::
  LandWidth ()
  {
    return this->LandWidth_;
  }

  void LandMeasurement::
  LandWidth (const LandWidth_type& x)
  {
    this->LandWidth_.set (x);
  }

  void LandMeasurement::
  LandWidth (const LandWidth_optional& x)
  {
    this->LandWidth_ = x;
  }

  void LandMeasurement::
  LandWidth (::std::unique_ptr< LandWidth_type > x)
  {
    this->LandWidth_.set (std::move (x));
  }

  const LandMeasurement::LandDepth_optional& LandMeasurement::
  LandDepth () const
  {
    return this->LandDepth_;
  }

  LandMeasurement::LandDepth_optional& LandMeasurement::
  LandDepth ()
  {
    return this->LandDepth_;
  }

  void LandMeasurement::
  LandDepth (const LandDepth_type& x)
  {
    this->LandDepth_.set (x);
  }

  void LandMeasurement::
  LandDepth (const LandDepth_optional& x)
  {
    this->LandDepth_ = x;
  }

  void LandMeasurement::
  LandDepth (::std::unique_ptr< LandDepth_type > x)
  {
    this->LandDepth_.set (std::move (x));
  }


  // Neighbourhood
  // 

  const Neighbourhood::NeighbourhoodCode_optional& Neighbourhood::
  NeighbourhoodCode () const
  {
    return this->NeighbourhoodCode_;
  }

  Neighbourhood::NeighbourhoodCode_optional& Neighbourhood::
  NeighbourhoodCode ()
  {
    return this->NeighbourhoodCode_;
  }

  void Neighbourhood::
  NeighbourhoodCode (const NeighbourhoodCode_type& x)
  {
    this->NeighbourhoodCode_.set (x);
  }

  void Neighbourhood::
  NeighbourhoodCode (const NeighbourhoodCode_optional& x)
  {
    this->NeighbourhoodCode_ = x;
  }

  void Neighbourhood::
  NeighbourhoodCode (::std::unique_ptr< NeighbourhoodCode_type > x)
  {
    this->NeighbourhoodCode_.set (std::move (x));
  }

  const Neighbourhood::NeighbourhoodDescription_optional& Neighbourhood::
  NeighbourhoodDescription () const
  {
    return this->NeighbourhoodDescription_;
  }

  Neighbourhood::NeighbourhoodDescription_optional& Neighbourhood::
  NeighbourhoodDescription ()
  {
    return this->NeighbourhoodDescription_;
  }

  void Neighbourhood::
  NeighbourhoodDescription (const NeighbourhoodDescription_type& x)
  {
    this->NeighbourhoodDescription_.set (x);
  }

  void Neighbourhood::
  NeighbourhoodDescription (const NeighbourhoodDescription_optional& x)
  {
    this->NeighbourhoodDescription_ = x;
  }

  void Neighbourhood::
  NeighbourhoodDescription (::std::unique_ptr< NeighbourhoodDescription_type > x)
  {
    this->NeighbourhoodDescription_.set (std::move (x));
  }


  // SpecialDistrict
  // 

  const SpecialDistrict::DistrictCode_optional& SpecialDistrict::
  DistrictCode () const
  {
    return this->DistrictCode_;
  }

  SpecialDistrict::DistrictCode_optional& SpecialDistrict::
  DistrictCode ()
  {
    return this->DistrictCode_;
  }

  void SpecialDistrict::
  DistrictCode (const DistrictCode_type& x)
  {
    this->DistrictCode_.set (x);
  }

  void SpecialDistrict::
  DistrictCode (const DistrictCode_optional& x)
  {
    this->DistrictCode_ = x;
  }

  void SpecialDistrict::
  DistrictCode (::std::unique_ptr< DistrictCode_type > x)
  {
    this->DistrictCode_.set (std::move (x));
  }

  const SpecialDistrict::DistrictDescription_optional& SpecialDistrict::
  DistrictDescription () const
  {
    return this->DistrictDescription_;
  }

  SpecialDistrict::DistrictDescription_optional& SpecialDistrict::
  DistrictDescription ()
  {
    return this->DistrictDescription_;
  }

  void SpecialDistrict::
  DistrictDescription (const DistrictDescription_type& x)
  {
    this->DistrictDescription_.set (x);
  }

  void SpecialDistrict::
  DistrictDescription (const DistrictDescription_optional& x)
  {
    this->DistrictDescription_ = x;
  }

  void SpecialDistrict::
  DistrictDescription (::std::unique_ptr< DistrictDescription_type > x)
  {
    this->DistrictDescription_.set (std::move (x));
  }


  // ManualClass
  // 

  const ManualClass::ManualClassCode_optional& ManualClass::
  ManualClassCode () const
  {
    return this->ManualClassCode_;
  }

  ManualClass::ManualClassCode_optional& ManualClass::
  ManualClassCode ()
  {
    return this->ManualClassCode_;
  }

  void ManualClass::
  ManualClassCode (const ManualClassCode_type& x)
  {
    this->ManualClassCode_.set (x);
  }

  void ManualClass::
  ManualClassCode (const ManualClassCode_optional& x)
  {
    this->ManualClassCode_ = x;
  }

  void ManualClass::
  ManualClassCode (::std::unique_ptr< ManualClassCode_type > x)
  {
    this->ManualClassCode_.set (std::move (x));
  }

  const ManualClass::ManualClassDescription_optional& ManualClass::
  ManualClassDescription () const
  {
    return this->ManualClassDescription_;
  }

  ManualClass::ManualClassDescription_optional& ManualClass::
  ManualClassDescription ()
  {
    return this->ManualClassDescription_;
  }

  void ManualClass::
  ManualClassDescription (const ManualClassDescription_type& x)
  {
    this->ManualClassDescription_.set (x);
  }

  void ManualClass::
  ManualClassDescription (const ManualClassDescription_optional& x)
  {
    this->ManualClassDescription_ = x;
  }

  void ManualClass::
  ManualClassDescription (::std::unique_ptr< ManualClassDescription_type > x)
  {
    this->ManualClassDescription_.set (std::move (x));
  }

  const ManualClass::PercentDeviation_optional& ManualClass::
  PercentDeviation () const
  {
    return this->PercentDeviation_;
  }

  ManualClass::PercentDeviation_optional& ManualClass::
  PercentDeviation ()
  {
    return this->PercentDeviation_;
  }

  void ManualClass::
  PercentDeviation (const PercentDeviation_type& x)
  {
    this->PercentDeviation_.set (x);
  }

  void ManualClass::
  PercentDeviation (const PercentDeviation_optional& x)
  {
    this->PercentDeviation_ = x;
  }

  void ManualClass::
  PercentDeviation (::std::unique_ptr< PercentDeviation_type > x)
  {
    this->PercentDeviation_.set (std::move (x));
  }


  // MinorTaxing
  // 

  const MinorTaxing::ElectoralAreas_optional& MinorTaxing::
  ElectoralAreas () const
  {
    return this->ElectoralAreas_;
  }

  MinorTaxing::ElectoralAreas_optional& MinorTaxing::
  ElectoralAreas ()
  {
    return this->ElectoralAreas_;
  }

  void MinorTaxing::
  ElectoralAreas (const ElectoralAreas_type& x)
  {
    this->ElectoralAreas_.set (x);
  }

  void MinorTaxing::
  ElectoralAreas (const ElectoralAreas_optional& x)
  {
    this->ElectoralAreas_ = x;
  }

  void MinorTaxing::
  ElectoralAreas (::std::unique_ptr< ElectoralAreas_type > x)
  {
    this->ElectoralAreas_.set (std::move (x));
  }

  const MinorTaxing::ServiceAreas_optional& MinorTaxing::
  ServiceAreas () const
  {
    return this->ServiceAreas_;
  }

  MinorTaxing::ServiceAreas_optional& MinorTaxing::
  ServiceAreas ()
  {
    return this->ServiceAreas_;
  }

  void MinorTaxing::
  ServiceAreas (const ServiceAreas_type& x)
  {
    this->ServiceAreas_.set (x);
  }

  void MinorTaxing::
  ServiceAreas (const ServiceAreas_optional& x)
  {
    this->ServiceAreas_ = x;
  }

  void MinorTaxing::
  ServiceAreas (::std::unique_ptr< ServiceAreas_type > x)
  {
    this->ServiceAreas_.set (std::move (x));
  }

  const MinorTaxing::Defined_optional& MinorTaxing::
  Defined () const
  {
    return this->Defined_;
  }

  MinorTaxing::Defined_optional& MinorTaxing::
  Defined ()
  {
    return this->Defined_;
  }

  void MinorTaxing::
  Defined (const Defined_type& x)
  {
    this->Defined_.set (x);
  }

  void MinorTaxing::
  Defined (const Defined_optional& x)
  {
    this->Defined_ = x;
  }

  void MinorTaxing::
  Defined (::std::unique_ptr< Defined_type > x)
  {
    this->Defined_.set (std::move (x));
  }

  const MinorTaxing::SpecifiedRegional_optional& MinorTaxing::
  SpecifiedRegional () const
  {
    return this->SpecifiedRegional_;
  }

  MinorTaxing::SpecifiedRegional_optional& MinorTaxing::
  SpecifiedRegional ()
  {
    return this->SpecifiedRegional_;
  }

  void MinorTaxing::
  SpecifiedRegional (const SpecifiedRegional_type& x)
  {
    this->SpecifiedRegional_.set (x);
  }

  void MinorTaxing::
  SpecifiedRegional (const SpecifiedRegional_optional& x)
  {
    this->SpecifiedRegional_ = x;
  }

  void MinorTaxing::
  SpecifiedRegional (::std::unique_ptr< SpecifiedRegional_type > x)
  {
    this->SpecifiedRegional_.set (std::move (x));
  }

  const MinorTaxing::SpecifiedMunicipal_optional& MinorTaxing::
  SpecifiedMunicipal () const
  {
    return this->SpecifiedMunicipal_;
  }

  MinorTaxing::SpecifiedMunicipal_optional& MinorTaxing::
  SpecifiedMunicipal ()
  {
    return this->SpecifiedMunicipal_;
  }

  void MinorTaxing::
  SpecifiedMunicipal (const SpecifiedMunicipal_type& x)
  {
    this->SpecifiedMunicipal_.set (x);
  }

  void MinorTaxing::
  SpecifiedMunicipal (const SpecifiedMunicipal_optional& x)
  {
    this->SpecifiedMunicipal_ = x;
  }

  void MinorTaxing::
  SpecifiedMunicipal (::std::unique_ptr< SpecifiedMunicipal_type > x)
  {
    this->SpecifiedMunicipal_.set (std::move (x));
  }

  const MinorTaxing::LocalAreas_optional& MinorTaxing::
  LocalAreas () const
  {
    return this->LocalAreas_;
  }

  MinorTaxing::LocalAreas_optional& MinorTaxing::
  LocalAreas ()
  {
    return this->LocalAreas_;
  }

  void MinorTaxing::
  LocalAreas (const LocalAreas_type& x)
  {
    this->LocalAreas_.set (x);
  }

  void MinorTaxing::
  LocalAreas (const LocalAreas_optional& x)
  {
    this->LocalAreas_ = x;
  }

  void MinorTaxing::
  LocalAreas (::std::unique_ptr< LocalAreas_type > x)
  {
    this->LocalAreas_.set (std::move (x));
  }

  const MinorTaxing::GeneralServices_optional& MinorTaxing::
  GeneralServices () const
  {
    return this->GeneralServices_;
  }

  MinorTaxing::GeneralServices_optional& MinorTaxing::
  GeneralServices ()
  {
    return this->GeneralServices_;
  }

  void MinorTaxing::
  GeneralServices (const GeneralServices_type& x)
  {
    this->GeneralServices_.set (x);
  }

  void MinorTaxing::
  GeneralServices (const GeneralServices_optional& x)
  {
    this->GeneralServices_ = x;
  }

  void MinorTaxing::
  GeneralServices (::std::unique_ptr< GeneralServices_type > x)
  {
    this->GeneralServices_.set (std::move (x));
  }

  const MinorTaxing::ImprovementDistricts_optional& MinorTaxing::
  ImprovementDistricts () const
  {
    return this->ImprovementDistricts_;
  }

  MinorTaxing::ImprovementDistricts_optional& MinorTaxing::
  ImprovementDistricts ()
  {
    return this->ImprovementDistricts_;
  }

  void MinorTaxing::
  ImprovementDistricts (const ImprovementDistricts_type& x)
  {
    this->ImprovementDistricts_.set (x);
  }

  void MinorTaxing::
  ImprovementDistricts (const ImprovementDistricts_optional& x)
  {
    this->ImprovementDistricts_ = x;
  }

  void MinorTaxing::
  ImprovementDistricts (::std::unique_ptr< ImprovementDistricts_type > x)
  {
    this->ImprovementDistricts_.set (std::move (x));
  }

  const MinorTaxing::IslandsTrusts_optional& MinorTaxing::
  IslandsTrusts () const
  {
    return this->IslandsTrusts_;
  }

  MinorTaxing::IslandsTrusts_optional& MinorTaxing::
  IslandsTrusts ()
  {
    return this->IslandsTrusts_;
  }

  void MinorTaxing::
  IslandsTrusts (const IslandsTrusts_type& x)
  {
    this->IslandsTrusts_.set (x);
  }

  void MinorTaxing::
  IslandsTrusts (const IslandsTrusts_optional& x)
  {
    this->IslandsTrusts_ = x;
  }

  void MinorTaxing::
  IslandsTrusts (::std::unique_ptr< IslandsTrusts_type > x)
  {
    this->IslandsTrusts_.set (std::move (x));
  }


  // MinorTaxingJurisdictionCollection
  // 

  const MinorTaxingJurisdictionCollection::MinorTaxingJurisdiction_sequence& MinorTaxingJurisdictionCollection::
  MinorTaxingJurisdiction () const
  {
    return this->MinorTaxingJurisdiction_;
  }

  MinorTaxingJurisdictionCollection::MinorTaxingJurisdiction_sequence& MinorTaxingJurisdictionCollection::
  MinorTaxingJurisdiction ()
  {
    return this->MinorTaxingJurisdiction_;
  }

  void MinorTaxingJurisdictionCollection::
  MinorTaxingJurisdiction (const MinorTaxingJurisdiction_sequence& s)
  {
    this->MinorTaxingJurisdiction_ = s;
  }


  // MinorTaxingJurisdiction
  // 

  const MinorTaxingJurisdiction::MinorTaxingCode_optional& MinorTaxingJurisdiction::
  MinorTaxingCode () const
  {
    return this->MinorTaxingCode_;
  }

  MinorTaxingJurisdiction::MinorTaxingCode_optional& MinorTaxingJurisdiction::
  MinorTaxingCode ()
  {
    return this->MinorTaxingCode_;
  }

  void MinorTaxingJurisdiction::
  MinorTaxingCode (const MinorTaxingCode_type& x)
  {
    this->MinorTaxingCode_.set (x);
  }

  void MinorTaxingJurisdiction::
  MinorTaxingCode (const MinorTaxingCode_optional& x)
  {
    this->MinorTaxingCode_ = x;
  }

  void MinorTaxingJurisdiction::
  MinorTaxingCode (::std::unique_ptr< MinorTaxingCode_type > x)
  {
    this->MinorTaxingCode_.set (std::move (x));
  }

  const MinorTaxingJurisdiction::MinorTaxingCodeShort_optional& MinorTaxingJurisdiction::
  MinorTaxingCodeShort () const
  {
    return this->MinorTaxingCodeShort_;
  }

  MinorTaxingJurisdiction::MinorTaxingCodeShort_optional& MinorTaxingJurisdiction::
  MinorTaxingCodeShort ()
  {
    return this->MinorTaxingCodeShort_;
  }

  void MinorTaxingJurisdiction::
  MinorTaxingCodeShort (const MinorTaxingCodeShort_type& x)
  {
    this->MinorTaxingCodeShort_.set (x);
  }

  void MinorTaxingJurisdiction::
  MinorTaxingCodeShort (const MinorTaxingCodeShort_optional& x)
  {
    this->MinorTaxingCodeShort_ = x;
  }

  void MinorTaxingJurisdiction::
  MinorTaxingCodeShort (::std::unique_ptr< MinorTaxingCodeShort_type > x)
  {
    this->MinorTaxingCodeShort_.set (std::move (x));
  }

  const MinorTaxingJurisdiction::MinorTaxingDescription_optional& MinorTaxingJurisdiction::
  MinorTaxingDescription () const
  {
    return this->MinorTaxingDescription_;
  }

  MinorTaxingJurisdiction::MinorTaxingDescription_optional& MinorTaxingJurisdiction::
  MinorTaxingDescription ()
  {
    return this->MinorTaxingDescription_;
  }

  void MinorTaxingJurisdiction::
  MinorTaxingDescription (const MinorTaxingDescription_type& x)
  {
    this->MinorTaxingDescription_.set (x);
  }

  void MinorTaxingJurisdiction::
  MinorTaxingDescription (const MinorTaxingDescription_optional& x)
  {
    this->MinorTaxingDescription_ = x;
  }

  void MinorTaxingJurisdiction::
  MinorTaxingDescription (::std::unique_ptr< MinorTaxingDescription_type > x)
  {
    this->MinorTaxingDescription_.set (std::move (x));
  }


  // PropertyValues
  // 

  const PropertyValues::GeneralValues_optional& PropertyValues::
  GeneralValues () const
  {
    return this->GeneralValues_;
  }

  PropertyValues::GeneralValues_optional& PropertyValues::
  GeneralValues ()
  {
    return this->GeneralValues_;
  }

  void PropertyValues::
  GeneralValues (const GeneralValues_type& x)
  {
    this->GeneralValues_.set (x);
  }

  void PropertyValues::
  GeneralValues (const GeneralValues_optional& x)
  {
    this->GeneralValues_ = x;
  }

  void PropertyValues::
  GeneralValues (::std::unique_ptr< GeneralValues_type > x)
  {
    this->GeneralValues_.set (std::move (x));
  }

  const PropertyValues::BCTransitValues_optional& PropertyValues::
  BCTransitValues () const
  {
    return this->BCTransitValues_;
  }

  PropertyValues::BCTransitValues_optional& PropertyValues::
  BCTransitValues ()
  {
    return this->BCTransitValues_;
  }

  void PropertyValues::
  BCTransitValues (const BCTransitValues_type& x)
  {
    this->BCTransitValues_.set (x);
  }

  void PropertyValues::
  BCTransitValues (const BCTransitValues_optional& x)
  {
    this->BCTransitValues_ = x;
  }

  void PropertyValues::
  BCTransitValues (::std::unique_ptr< BCTransitValues_type > x)
  {
    this->BCTransitValues_.set (std::move (x));
  }

  const PropertyValues::SchoolValues_optional& PropertyValues::
  SchoolValues () const
  {
    return this->SchoolValues_;
  }

  PropertyValues::SchoolValues_optional& PropertyValues::
  SchoolValues ()
  {
    return this->SchoolValues_;
  }

  void PropertyValues::
  SchoolValues (const SchoolValues_type& x)
  {
    this->SchoolValues_.set (x);
  }

  void PropertyValues::
  SchoolValues (const SchoolValues_optional& x)
  {
    this->SchoolValues_ = x;
  }

  void PropertyValues::
  SchoolValues (::std::unique_ptr< SchoolValues_type > x)
  {
    this->SchoolValues_.set (std::move (x));
  }

  const PropertyValues::TaxExemptValues_optional& PropertyValues::
  TaxExemptValues () const
  {
    return this->TaxExemptValues_;
  }

  PropertyValues::TaxExemptValues_optional& PropertyValues::
  TaxExemptValues ()
  {
    return this->TaxExemptValues_;
  }

  void PropertyValues::
  TaxExemptValues (const TaxExemptValues_type& x)
  {
    this->TaxExemptValues_.set (x);
  }

  void PropertyValues::
  TaxExemptValues (const TaxExemptValues_optional& x)
  {
    this->TaxExemptValues_ = x;
  }

  void PropertyValues::
  TaxExemptValues (::std::unique_ptr< TaxExemptValues_type > x)
  {
    this->TaxExemptValues_.set (std::move (x));
  }


  // TaxExemptValuesCollection
  // 

  const TaxExemptValuesCollection::TaxExemptPropertyClassValues_sequence& TaxExemptValuesCollection::
  TaxExemptPropertyClassValues () const
  {
    return this->TaxExemptPropertyClassValues_;
  }

  TaxExemptValuesCollection::TaxExemptPropertyClassValues_sequence& TaxExemptValuesCollection::
  TaxExemptPropertyClassValues ()
  {
    return this->TaxExemptPropertyClassValues_;
  }

  void TaxExemptValuesCollection::
  TaxExemptPropertyClassValues (const TaxExemptPropertyClassValues_sequence& s)
  {
    this->TaxExemptPropertyClassValues_ = s;
  }


  // TaxExemptPropertyClassValues
  // 

  const TaxExemptPropertyClassValues::TaxExemptCode_type& TaxExemptPropertyClassValues::
  TaxExemptCode () const
  {
    return this->TaxExemptCode_.get ();
  }

  TaxExemptPropertyClassValues::TaxExemptCode_type& TaxExemptPropertyClassValues::
  TaxExemptCode ()
  {
    return this->TaxExemptCode_.get ();
  }

  void TaxExemptPropertyClassValues::
  TaxExemptCode (const TaxExemptCode_type& x)
  {
    this->TaxExemptCode_.set (x);
  }

  void TaxExemptPropertyClassValues::
  TaxExemptCode (::std::unique_ptr< TaxExemptCode_type > x)
  {
    this->TaxExemptCode_.set (std::move (x));
  }

  const TaxExemptPropertyClassValues::TaxExemptDescription_optional& TaxExemptPropertyClassValues::
  TaxExemptDescription () const
  {
    return this->TaxExemptDescription_;
  }

  TaxExemptPropertyClassValues::TaxExemptDescription_optional& TaxExemptPropertyClassValues::
  TaxExemptDescription ()
  {
    return this->TaxExemptDescription_;
  }

  void TaxExemptPropertyClassValues::
  TaxExemptDescription (const TaxExemptDescription_type& x)
  {
    this->TaxExemptDescription_.set (x);
  }

  void TaxExemptPropertyClassValues::
  TaxExemptDescription (const TaxExemptDescription_optional& x)
  {
    this->TaxExemptDescription_ = x;
  }

  void TaxExemptPropertyClassValues::
  TaxExemptDescription (::std::unique_ptr< TaxExemptDescription_type > x)
  {
    this->TaxExemptDescription_.set (std::move (x));
  }

  const TaxExemptPropertyClassValues::PropertyClassCode_type& TaxExemptPropertyClassValues::
  PropertyClassCode () const
  {
    return this->PropertyClassCode_.get ();
  }

  TaxExemptPropertyClassValues::PropertyClassCode_type& TaxExemptPropertyClassValues::
  PropertyClassCode ()
  {
    return this->PropertyClassCode_.get ();
  }

  void TaxExemptPropertyClassValues::
  PropertyClassCode (const PropertyClassCode_type& x)
  {
    this->PropertyClassCode_.set (x);
  }

  void TaxExemptPropertyClassValues::
  PropertyClassCode (::std::unique_ptr< PropertyClassCode_type > x)
  {
    this->PropertyClassCode_.set (std::move (x));
  }

  const TaxExemptPropertyClassValues::PropertyClassDescription_optional& TaxExemptPropertyClassValues::
  PropertyClassDescription () const
  {
    return this->PropertyClassDescription_;
  }

  TaxExemptPropertyClassValues::PropertyClassDescription_optional& TaxExemptPropertyClassValues::
  PropertyClassDescription ()
  {
    return this->PropertyClassDescription_;
  }

  void TaxExemptPropertyClassValues::
  PropertyClassDescription (const PropertyClassDescription_type& x)
  {
    this->PropertyClassDescription_.set (x);
  }

  void TaxExemptPropertyClassValues::
  PropertyClassDescription (const PropertyClassDescription_optional& x)
  {
    this->PropertyClassDescription_ = x;
  }

  void TaxExemptPropertyClassValues::
  PropertyClassDescription (::std::unique_ptr< PropertyClassDescription_type > x)
  {
    this->PropertyClassDescription_.set (std::move (x));
  }

  const TaxExemptPropertyClassValues::LandValue_type& TaxExemptPropertyClassValues::
  LandValue () const
  {
    return this->LandValue_.get ();
  }

  TaxExemptPropertyClassValues::LandValue_type& TaxExemptPropertyClassValues::
  LandValue ()
  {
    return this->LandValue_.get ();
  }

  void TaxExemptPropertyClassValues::
  LandValue (const LandValue_type& x)
  {
    this->LandValue_.set (x);
  }

  const TaxExemptPropertyClassValues::ImprovementValue_type& TaxExemptPropertyClassValues::
  ImprovementValue () const
  {
    return this->ImprovementValue_.get ();
  }

  TaxExemptPropertyClassValues::ImprovementValue_type& TaxExemptPropertyClassValues::
  ImprovementValue ()
  {
    return this->ImprovementValue_.get ();
  }

  void TaxExemptPropertyClassValues::
  ImprovementValue (const ImprovementValue_type& x)
  {
    this->ImprovementValue_.set (x);
  }


  // PropertyClassValuesCollection
  // 

  const PropertyClassValuesCollection::PropertyClassValues_sequence& PropertyClassValuesCollection::
  PropertyClassValues () const
  {
    return this->PropertyClassValues_;
  }

  PropertyClassValuesCollection::PropertyClassValues_sequence& PropertyClassValuesCollection::
  PropertyClassValues ()
  {
    return this->PropertyClassValues_;
  }

  void PropertyClassValuesCollection::
  PropertyClassValues (const PropertyClassValues_sequence& s)
  {
    this->PropertyClassValues_ = s;
  }


  // PropertyClassValues
  // 

  const PropertyClassValues::PropertyClassCode_type& PropertyClassValues::
  PropertyClassCode () const
  {
    return this->PropertyClassCode_.get ();
  }

  PropertyClassValues::PropertyClassCode_type& PropertyClassValues::
  PropertyClassCode ()
  {
    return this->PropertyClassCode_.get ();
  }

  void PropertyClassValues::
  PropertyClassCode (const PropertyClassCode_type& x)
  {
    this->PropertyClassCode_.set (x);
  }

  void PropertyClassValues::
  PropertyClassCode (::std::unique_ptr< PropertyClassCode_type > x)
  {
    this->PropertyClassCode_.set (std::move (x));
  }

  const PropertyClassValues::PropertyClassDescription_optional& PropertyClassValues::
  PropertyClassDescription () const
  {
    return this->PropertyClassDescription_;
  }

  PropertyClassValues::PropertyClassDescription_optional& PropertyClassValues::
  PropertyClassDescription ()
  {
    return this->PropertyClassDescription_;
  }

  void PropertyClassValues::
  PropertyClassDescription (const PropertyClassDescription_type& x)
  {
    this->PropertyClassDescription_.set (x);
  }

  void PropertyClassValues::
  PropertyClassDescription (const PropertyClassDescription_optional& x)
  {
    this->PropertyClassDescription_ = x;
  }

  void PropertyClassValues::
  PropertyClassDescription (::std::unique_ptr< PropertyClassDescription_type > x)
  {
    this->PropertyClassDescription_.set (std::move (x));
  }

  const PropertyClassValues::PropertySubClassCode_optional& PropertyClassValues::
  PropertySubClassCode () const
  {
    return this->PropertySubClassCode_;
  }

  PropertyClassValues::PropertySubClassCode_optional& PropertyClassValues::
  PropertySubClassCode ()
  {
    return this->PropertySubClassCode_;
  }

  void PropertyClassValues::
  PropertySubClassCode (const PropertySubClassCode_type& x)
  {
    this->PropertySubClassCode_.set (x);
  }

  void PropertyClassValues::
  PropertySubClassCode (const PropertySubClassCode_optional& x)
  {
    this->PropertySubClassCode_ = x;
  }

  void PropertyClassValues::
  PropertySubClassCode (::std::unique_ptr< PropertySubClassCode_type > x)
  {
    this->PropertySubClassCode_.set (std::move (x));
  }

  const PropertyClassValues::PropertySubClassDescription_optional& PropertyClassValues::
  PropertySubClassDescription () const
  {
    return this->PropertySubClassDescription_;
  }

  PropertyClassValues::PropertySubClassDescription_optional& PropertyClassValues::
  PropertySubClassDescription ()
  {
    return this->PropertySubClassDescription_;
  }

  void PropertyClassValues::
  PropertySubClassDescription (const PropertySubClassDescription_type& x)
  {
    this->PropertySubClassDescription_.set (x);
  }

  void PropertyClassValues::
  PropertySubClassDescription (const PropertySubClassDescription_optional& x)
  {
    this->PropertySubClassDescription_ = x;
  }

  void PropertyClassValues::
  PropertySubClassDescription (::std::unique_ptr< PropertySubClassDescription_type > x)
  {
    this->PropertySubClassDescription_.set (std::move (x));
  }

  const PropertyClassValues::GrossValues_optional& PropertyClassValues::
  GrossValues () const
  {
    return this->GrossValues_;
  }

  PropertyClassValues::GrossValues_optional& PropertyClassValues::
  GrossValues ()
  {
    return this->GrossValues_;
  }

  void PropertyClassValues::
  GrossValues (const GrossValues_type& x)
  {
    this->GrossValues_.set (x);
  }

  void PropertyClassValues::
  GrossValues (const GrossValues_optional& x)
  {
    this->GrossValues_ = x;
  }

  void PropertyClassValues::
  GrossValues (::std::unique_ptr< GrossValues_type > x)
  {
    this->GrossValues_.set (std::move (x));
  }

  const PropertyClassValues::TaxExemptValues_optional& PropertyClassValues::
  TaxExemptValues () const
  {
    return this->TaxExemptValues_;
  }

  PropertyClassValues::TaxExemptValues_optional& PropertyClassValues::
  TaxExemptValues ()
  {
    return this->TaxExemptValues_;
  }

  void PropertyClassValues::
  TaxExemptValues (const TaxExemptValues_type& x)
  {
    this->TaxExemptValues_.set (x);
  }

  void PropertyClassValues::
  TaxExemptValues (const TaxExemptValues_optional& x)
  {
    this->TaxExemptValues_ = x;
  }

  void PropertyClassValues::
  TaxExemptValues (::std::unique_ptr< TaxExemptValues_type > x)
  {
    this->TaxExemptValues_.set (std::move (x));
  }

  const PropertyClassValues::NetValues_optional& PropertyClassValues::
  NetValues () const
  {
    return this->NetValues_;
  }

  PropertyClassValues::NetValues_optional& PropertyClassValues::
  NetValues ()
  {
    return this->NetValues_;
  }

  void PropertyClassValues::
  NetValues (const NetValues_type& x)
  {
    this->NetValues_.set (x);
  }

  void PropertyClassValues::
  NetValues (const NetValues_optional& x)
  {
    this->NetValues_ = x;
  }

  void PropertyClassValues::
  NetValues (::std::unique_ptr< NetValues_type > x)
  {
    this->NetValues_.set (std::move (x));
  }


  // PropertyClassCode
  // 


  // PropertySubClassCode
  // 


  // Valuation
  // 

  const Valuation::LandValue_type& Valuation::
  LandValue () const
  {
    return this->LandValue_.get ();
  }

  Valuation::LandValue_type& Valuation::
  LandValue ()
  {
    return this->LandValue_.get ();
  }

  void Valuation::
  LandValue (const LandValue_type& x)
  {
    this->LandValue_.set (x);
  }

  const Valuation::ImprovementValue_type& Valuation::
  ImprovementValue () const
  {
    return this->ImprovementValue_.get ();
  }

  Valuation::ImprovementValue_type& Valuation::
  ImprovementValue ()
  {
    return this->ImprovementValue_.get ();
  }

  void Valuation::
  ImprovementValue (const ImprovementValue_type& x)
  {
    this->ImprovementValue_.set (x);
  }


  // FolioIntegerItem
  // 

  const FolioIntegerItem::Action_optional& FolioIntegerItem::
  Action () const
  {
    return this->Action_;
  }

  FolioIntegerItem::Action_optional& FolioIntegerItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioIntegerItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioIntegerItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioIntegerItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioIntegerItem::OldValue_optional& FolioIntegerItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioIntegerItem::OldValue_optional& FolioIntegerItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioIntegerItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioIntegerItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }


  // FolioBooleanItem
  // 

  const FolioBooleanItem::Action_optional& FolioBooleanItem::
  Action () const
  {
    return this->Action_;
  }

  FolioBooleanItem::Action_optional& FolioBooleanItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioBooleanItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioBooleanItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioBooleanItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioBooleanItem::OldValue_optional& FolioBooleanItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioBooleanItem::OldValue_optional& FolioBooleanItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioBooleanItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioBooleanItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }


  // FolioDecimalItem
  // 

  const FolioDecimalItem::Action_optional& FolioDecimalItem::
  Action () const
  {
    return this->Action_;
  }

  FolioDecimalItem::Action_optional& FolioDecimalItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioDecimalItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioDecimalItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioDecimalItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioDecimalItem::OldValue_optional& FolioDecimalItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioDecimalItem::OldValue_optional& FolioDecimalItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioDecimalItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioDecimalItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }


  // FolioDateItem
  // 

  const FolioDateItem::Action_optional& FolioDateItem::
  Action () const
  {
    return this->Action_;
  }

  FolioDateItem::Action_optional& FolioDateItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioDateItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioDateItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioDateItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioDateItem::OldValue_optional& FolioDateItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioDateItem::OldValue_optional& FolioDateItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioDateItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioDateItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioDateItem::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // UniqueID
  // 


  // FolioUniqueIDItem
  // 

  const FolioUniqueIDItem::Action_optional& FolioUniqueIDItem::
  Action () const
  {
    return this->Action_;
  }

  FolioUniqueIDItem::Action_optional& FolioUniqueIDItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioUniqueIDItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioUniqueIDItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioUniqueIDItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioUniqueIDItem::OldValue_optional& FolioUniqueIDItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioUniqueIDItem::OldValue_optional& FolioUniqueIDItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioUniqueIDItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioUniqueIDItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioUniqueIDItem::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // LookupCode
  // 


  // FolioLookupCodeItem
  // 

  const FolioLookupCodeItem::Action_optional& FolioLookupCodeItem::
  Action () const
  {
    return this->Action_;
  }

  FolioLookupCodeItem::Action_optional& FolioLookupCodeItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioLookupCodeItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioLookupCodeItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioLookupCodeItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioLookupCodeItem::OldValue_optional& FolioLookupCodeItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioLookupCodeItem::OldValue_optional& FolioLookupCodeItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioLookupCodeItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioLookupCodeItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioLookupCodeItem::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // Character
  // 


  // FolioCharacterItem
  // 

  const FolioCharacterItem::Action_optional& FolioCharacterItem::
  Action () const
  {
    return this->Action_;
  }

  FolioCharacterItem::Action_optional& FolioCharacterItem::
  Action ()
  {
    return this->Action_;
  }

  void FolioCharacterItem::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioCharacterItem::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioCharacterItem::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioCharacterItem::OldValue_optional& FolioCharacterItem::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioCharacterItem::OldValue_optional& FolioCharacterItem::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioCharacterItem::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioCharacterItem::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioCharacterItem::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // String255
  // 


  // FolioString255Item
  // 

  const FolioString255Item::Action_optional& FolioString255Item::
  Action () const
  {
    return this->Action_;
  }

  FolioString255Item::Action_optional& FolioString255Item::
  Action ()
  {
    return this->Action_;
  }

  void FolioString255Item::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioString255Item::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioString255Item::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioString255Item::OldValue_optional& FolioString255Item::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioString255Item::OldValue_optional& FolioString255Item::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioString255Item::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioString255Item::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioString255Item::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // String1024
  // 


  // FolioString1024Item
  // 

  const FolioString1024Item::Action_optional& FolioString1024Item::
  Action () const
  {
    return this->Action_;
  }

  FolioString1024Item::Action_optional& FolioString1024Item::
  Action ()
  {
    return this->Action_;
  }

  void FolioString1024Item::
  Action (const Action_type& x)
  {
    this->Action_.set (x);
  }

  void FolioString1024Item::
  Action (const Action_optional& x)
  {
    this->Action_ = x;
  }

  void FolioString1024Item::
  Action (::std::unique_ptr< Action_type > x)
  {
    this->Action_.set (std::move (x));
  }

  const FolioString1024Item::OldValue_optional& FolioString1024Item::
  OldValue () const
  {
    return this->OldValue_;
  }

  FolioString1024Item::OldValue_optional& FolioString1024Item::
  OldValue ()
  {
    return this->OldValue_;
  }

  void FolioString1024Item::
  OldValue (const OldValue_type& x)
  {
    this->OldValue_.set (x);
  }

  void FolioString1024Item::
  OldValue (const OldValue_optional& x)
  {
    this->OldValue_ = x;
  }

  void FolioString1024Item::
  OldValue (::std::unique_ptr< OldValue_type > x)
  {
    this->OldValue_.set (std::move (x));
  }


  // ActionCode
  // 

  ActionCode::
  ActionCode (value v)
  : ::xml_schema::string (_xsd_ActionCode_literals_[v])
  {
  }

  ActionCode::
  ActionCode (const char* v)
  : ::xml_schema::string (v)
  {
  }

  ActionCode::
  ActionCode (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  ActionCode::
  ActionCode (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  ActionCode::
  ActionCode (const ActionCode& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  ActionCode& ActionCode::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_ActionCode_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace dataadvice
{
  // DataAdvice
  //

  const DataAdvice::Version_type DataAdvice::Version_default_value_ (
    "1.3");

  DataAdvice::
  DataAdvice (const RollYear_type& RollYear,
              const OwnershipYear_type& OwnershipYear,
              const RunType_type& RunType,
              const StartDate_type& StartDate,
              const EndDate_type& EndDate,
              const RequestID_type& RequestID,
              const OrderID_type& OrderID,
              const RunDate_type& RunDate)
  : ::xml_schema::type (),
    RollYear_ (RollYear, this),
    OwnershipYear_ (OwnershipYear, this),
    RunType_ (RunType, this),
    StartDate_ (StartDate, this),
    EndDate_ (EndDate, this),
    AssessmentAreas_ (this),
    ReportSummary_ (this),
    Version_ (Version_default_value (), this),
    RequestID_ (RequestID, this),
    OrderID_ (OrderID, this),
    RunDate_ (RunDate, this)
  {
  }

  DataAdvice::
  DataAdvice (const DataAdvice& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RollYear_ (x.RollYear_, f, this),
    OwnershipYear_ (x.OwnershipYear_, f, this),
    RunType_ (x.RunType_, f, this),
    StartDate_ (x.StartDate_, f, this),
    EndDate_ (x.EndDate_, f, this),
    AssessmentAreas_ (x.AssessmentAreas_, f, this),
    ReportSummary_ (x.ReportSummary_, f, this),
    Version_ (x.Version_, f, this),
    RequestID_ (x.RequestID_, f, this),
    OrderID_ (x.OrderID_, f, this),
    RunDate_ (x.RunDate_, f, this)
  {
  }

  DataAdvice::
  DataAdvice (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RollYear_ (this),
    OwnershipYear_ (this),
    RunType_ (this),
    StartDate_ (this),
    EndDate_ (this),
    AssessmentAreas_ (this),
    ReportSummary_ (this),
    Version_ (this),
    RequestID_ (this),
    OrderID_ (this),
    RunDate_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DataAdvice::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RollYear
      //
      if (n.name () == "RollYear" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!RollYear_.present ())
        {
          this->RollYear_.set (RollYear_traits::create (i, f, this));
          continue;
        }
      }

      // OwnershipYear
      //
      if (n.name () == "OwnershipYear" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!OwnershipYear_.present ())
        {
          this->OwnershipYear_.set (OwnershipYear_traits::create (i, f, this));
          continue;
        }
      }

      // RunType
      //
      if (n.name () == "RunType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RunType_type > r (
          RunType_traits::create (i, f, this));

        if (!RunType_.present ())
        {
          this->RunType_.set (::std::move (r));
          continue;
        }
      }

      // StartDate
      //
      if (n.name () == "StartDate" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StartDate_type > r (
          StartDate_traits::create (i, f, this));

        if (!StartDate_.present ())
        {
          this->StartDate_.set (::std::move (r));
          continue;
        }
      }

      // EndDate
      //
      if (n.name () == "EndDate" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< EndDate_type > r (
          EndDate_traits::create (i, f, this));

        if (!EndDate_.present ())
        {
          this->EndDate_.set (::std::move (r));
          continue;
        }
      }

      // AssessmentAreas
      //
      if (n.name () == "AssessmentAreas" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentAreas_type > r (
          AssessmentAreas_traits::create (i, f, this));

        if (!this->AssessmentAreas_)
        {
          this->AssessmentAreas_.set (::std::move (r));
          continue;
        }
      }

      // ReportSummary
      //
      if (n.name () == "ReportSummary" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ReportSummary_type > r (
          ReportSummary_traits::create (i, f, this));

        if (!this->ReportSummary_)
        {
          this->ReportSummary_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!RollYear_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RollYear",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!OwnershipYear_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "OwnershipYear",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!RunType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RunType",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!StartDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "StartDate",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!EndDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "EndDate",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Version" && n.namespace_ ().empty ())
      {
        this->Version_.set (Version_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "RequestID" && n.namespace_ ().empty ())
      {
        this->RequestID_.set (RequestID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OrderID" && n.namespace_ ().empty ())
      {
        this->OrderID_.set (OrderID_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "RunDate" && n.namespace_ ().empty ())
      {
        this->RunDate_.set (RunDate_traits::create (i, f, this));
        continue;
      }
    }

    if (!Version_.present ())
    {
      this->Version_.set (Version_default_value ());
    }

    if (!RequestID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "RequestID",
        "");
    }

    if (!OrderID_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "OrderID",
        "");
    }

    if (!RunDate_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "RunDate",
        "");
    }
  }

  DataAdvice* DataAdvice::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DataAdvice (*this, f, c);
  }

  DataAdvice& DataAdvice::
  operator= (const DataAdvice& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->RollYear_ = x.RollYear_;
      this->OwnershipYear_ = x.OwnershipYear_;
      this->RunType_ = x.RunType_;
      this->StartDate_ = x.StartDate_;
      this->EndDate_ = x.EndDate_;
      this->AssessmentAreas_ = x.AssessmentAreas_;
      this->ReportSummary_ = x.ReportSummary_;
      this->Version_ = x.Version_;
      this->RequestID_ = x.RequestID_;
      this->OrderID_ = x.OrderID_;
      this->RunDate_ = x.RunDate_;
    }

    return *this;
  }

  DataAdvice::
  ~DataAdvice ()
  {
  }

  // Version
  //

  Version::
  Version ()
  : ::xml_schema::string ()
  {
  }

  Version::
  Version (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Version::
  Version (const Version& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Version::
  Version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Version::
  Version (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Version::
  Version (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Version* Version::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Version (*this, f, c);
  }

  Version::
  ~Version ()
  {
  }

  // RunType
  //

  RunType::
  RunType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_RunType_convert ();
  }

  RunType::
  RunType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_RunType_convert ();
  }

  RunType::
  RunType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_RunType_convert ();
  }

  RunType* RunType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RunType (*this, f, c);
  }

  RunType::value RunType::
  _xsd_RunType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_RunType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_RunType_indexes_,
                      _xsd_RunType_indexes_ + 10,
                      *this,
                      c));

    if (i == _xsd_RunType_indexes_ + 10 || _xsd_RunType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const RunType::
  _xsd_RunType_literals_[10] =
  {
    "COMP",
    "REVD",
    "RVSP",
    "GRNT",
    "SUPP",
    "PAAB",
    "DECISION",
    "MONTHLY",
    "WEEKLY",
    "OTHER"
  };

  const RunType::value RunType::
  _xsd_RunType_indexes_[10] =
  {
    ::dataadvice::RunType::COMP,
    ::dataadvice::RunType::DECISION,
    ::dataadvice::RunType::GRNT,
    ::dataadvice::RunType::MONTHLY,
    ::dataadvice::RunType::OTHER,
    ::dataadvice::RunType::PAAB,
    ::dataadvice::RunType::REVD,
    ::dataadvice::RunType::RVSP,
    ::dataadvice::RunType::SUPP,
    ::dataadvice::RunType::WEEKLY
  };

  // DeliverySummary
  //

  DeliverySummary::
  DeliverySummary ()
  : ::xml_schema::type (),
    TotalFolioCount_ (this),
    TaxableFolioCount_ (this),
    TaxExemptFolioCount_ (this),
    TotalGrossValues_ (this),
    TotalTaxExemptValues_ (this),
    TotalNetValues_ (this),
    GeneralValues_ (this),
    BCTransitValues_ (this),
    SchoolValues_ (this),
    AmendmentReasonCounts_ (this),
    DeleteReasonCounts_ (this)
  {
  }

  DeliverySummary::
  DeliverySummary (const DeliverySummary& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TotalFolioCount_ (x.TotalFolioCount_, f, this),
    TaxableFolioCount_ (x.TaxableFolioCount_, f, this),
    TaxExemptFolioCount_ (x.TaxExemptFolioCount_, f, this),
    TotalGrossValues_ (x.TotalGrossValues_, f, this),
    TotalTaxExemptValues_ (x.TotalTaxExemptValues_, f, this),
    TotalNetValues_ (x.TotalNetValues_, f, this),
    GeneralValues_ (x.GeneralValues_, f, this),
    BCTransitValues_ (x.BCTransitValues_, f, this),
    SchoolValues_ (x.SchoolValues_, f, this),
    AmendmentReasonCounts_ (x.AmendmentReasonCounts_, f, this),
    DeleteReasonCounts_ (x.DeleteReasonCounts_, f, this)
  {
  }

  DeliverySummary::
  DeliverySummary (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TotalFolioCount_ (this),
    TaxableFolioCount_ (this),
    TaxExemptFolioCount_ (this),
    TotalGrossValues_ (this),
    TotalTaxExemptValues_ (this),
    TotalNetValues_ (this),
    GeneralValues_ (this),
    BCTransitValues_ (this),
    SchoolValues_ (this),
    AmendmentReasonCounts_ (this),
    DeleteReasonCounts_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeliverySummary::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TotalFolioCount
      //
      if (n.name () == "TotalFolioCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!this->TotalFolioCount_)
        {
          this->TotalFolioCount_.set (TotalFolioCount_traits::create (i, f, this));
          continue;
        }
      }

      // TaxableFolioCount
      //
      if (n.name () == "TaxableFolioCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!this->TaxableFolioCount_)
        {
          this->TaxableFolioCount_.set (TaxableFolioCount_traits::create (i, f, this));
          continue;
        }
      }

      // TaxExemptFolioCount
      //
      if (n.name () == "TaxExemptFolioCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!this->TaxExemptFolioCount_)
        {
          this->TaxExemptFolioCount_.set (TaxExemptFolioCount_traits::create (i, f, this));
          continue;
        }
      }

      // TotalGrossValues
      //
      if (n.name () == "TotalGrossValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TotalGrossValues_type > r (
          TotalGrossValues_traits::create (i, f, this));

        if (!this->TotalGrossValues_)
        {
          this->TotalGrossValues_.set (::std::move (r));
          continue;
        }
      }

      // TotalTaxExemptValues
      //
      if (n.name () == "TotalTaxExemptValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TotalTaxExemptValues_type > r (
          TotalTaxExemptValues_traits::create (i, f, this));

        if (!this->TotalTaxExemptValues_)
        {
          this->TotalTaxExemptValues_.set (::std::move (r));
          continue;
        }
      }

      // TotalNetValues
      //
      if (n.name () == "TotalNetValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TotalNetValues_type > r (
          TotalNetValues_traits::create (i, f, this));

        if (!this->TotalNetValues_)
        {
          this->TotalNetValues_.set (::std::move (r));
          continue;
        }
      }

      // GeneralValues
      //
      if (n.name () == "GeneralValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< GeneralValues_type > r (
          GeneralValues_traits::create (i, f, this));

        if (!this->GeneralValues_)
        {
          this->GeneralValues_.set (::std::move (r));
          continue;
        }
      }

      // BCTransitValues
      //
      if (n.name () == "BCTransitValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< BCTransitValues_type > r (
          BCTransitValues_traits::create (i, f, this));

        if (!this->BCTransitValues_)
        {
          this->BCTransitValues_.set (::std::move (r));
          continue;
        }
      }

      // SchoolValues
      //
      if (n.name () == "SchoolValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SchoolValues_type > r (
          SchoolValues_traits::create (i, f, this));

        if (!this->SchoolValues_)
        {
          this->SchoolValues_.set (::std::move (r));
          continue;
        }
      }

      // AmendmentReasonCounts
      //
      if (n.name () == "AmendmentReasonCounts" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentReasonCounts_type > r (
          AmendmentReasonCounts_traits::create (i, f, this));

        if (!this->AmendmentReasonCounts_)
        {
          this->AmendmentReasonCounts_.set (::std::move (r));
          continue;
        }
      }

      // DeleteReasonCounts
      //
      if (n.name () == "DeleteReasonCounts" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeleteReasonCounts_type > r (
          DeleteReasonCounts_traits::create (i, f, this));

        if (!this->DeleteReasonCounts_)
        {
          this->DeleteReasonCounts_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  DeliverySummary* DeliverySummary::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeliverySummary (*this, f, c);
  }

  DeliverySummary& DeliverySummary::
  operator= (const DeliverySummary& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->TotalFolioCount_ = x.TotalFolioCount_;
      this->TaxableFolioCount_ = x.TaxableFolioCount_;
      this->TaxExemptFolioCount_ = x.TaxExemptFolioCount_;
      this->TotalGrossValues_ = x.TotalGrossValues_;
      this->TotalTaxExemptValues_ = x.TotalTaxExemptValues_;
      this->TotalNetValues_ = x.TotalNetValues_;
      this->GeneralValues_ = x.GeneralValues_;
      this->BCTransitValues_ = x.BCTransitValues_;
      this->SchoolValues_ = x.SchoolValues_;
      this->AmendmentReasonCounts_ = x.AmendmentReasonCounts_;
      this->DeleteReasonCounts_ = x.DeleteReasonCounts_;
    }

    return *this;
  }

  DeliverySummary::
  ~DeliverySummary ()
  {
  }

  // AmendmentReasonCountCollection
  //

  AmendmentReasonCountCollection::
  AmendmentReasonCountCollection ()
  : ::xml_schema::type (),
    AmendmentReasonCount_ (this)
  {
  }

  AmendmentReasonCountCollection::
  AmendmentReasonCountCollection (const AmendmentReasonCountCollection& x,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AmendmentReasonCount_ (x.AmendmentReasonCount_, f, this)
  {
  }

  AmendmentReasonCountCollection::
  AmendmentReasonCountCollection (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f,
                                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AmendmentReasonCount_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AmendmentReasonCountCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AmendmentReasonCount
      //
      if (n.name () == "AmendmentReasonCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentReasonCount_type > r (
          AmendmentReasonCount_traits::create (i, f, this));

        this->AmendmentReasonCount_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AmendmentReasonCountCollection* AmendmentReasonCountCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AmendmentReasonCountCollection (*this, f, c);
  }

  AmendmentReasonCountCollection& AmendmentReasonCountCollection::
  operator= (const AmendmentReasonCountCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AmendmentReasonCount_ = x.AmendmentReasonCount_;
    }

    return *this;
  }

  AmendmentReasonCountCollection::
  ~AmendmentReasonCountCollection ()
  {
  }

  // AmendmentReasonCount
  //

  AmendmentReasonCount::
  AmendmentReasonCount (const AmendmentReasonCode_type& AmendmentReasonCode,
                        const FolioCount_type& FolioCount)
  : ::xml_schema::type (),
    AmendmentReasonCode_ (AmendmentReasonCode, this),
    AmendmentReasonDescription_ (this),
    FolioCount_ (FolioCount, this)
  {
  }

  AmendmentReasonCount::
  AmendmentReasonCount (const AmendmentReasonCount& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AmendmentReasonCode_ (x.AmendmentReasonCode_, f, this),
    AmendmentReasonDescription_ (x.AmendmentReasonDescription_, f, this),
    FolioCount_ (x.FolioCount_, f, this)
  {
  }

  AmendmentReasonCount::
  AmendmentReasonCount (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AmendmentReasonCode_ (this),
    AmendmentReasonDescription_ (this),
    FolioCount_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AmendmentReasonCount::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AmendmentReasonCode
      //
      if (n.name () == "AmendmentReasonCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentReasonCode_type > r (
          AmendmentReasonCode_traits::create (i, f, this));

        if (!AmendmentReasonCode_.present ())
        {
          this->AmendmentReasonCode_.set (::std::move (r));
          continue;
        }
      }

      // AmendmentReasonDescription
      //
      if (n.name () == "AmendmentReasonDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentReasonDescription_type > r (
          AmendmentReasonDescription_traits::create (i, f, this));

        if (!this->AmendmentReasonDescription_)
        {
          this->AmendmentReasonDescription_.set (::std::move (r));
          continue;
        }
      }

      // FolioCount
      //
      if (n.name () == "FolioCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!FolioCount_.present ())
        {
          this->FolioCount_.set (FolioCount_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!AmendmentReasonCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AmendmentReasonCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!FolioCount_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FolioCount",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  AmendmentReasonCount* AmendmentReasonCount::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AmendmentReasonCount (*this, f, c);
  }

  AmendmentReasonCount& AmendmentReasonCount::
  operator= (const AmendmentReasonCount& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AmendmentReasonCode_ = x.AmendmentReasonCode_;
      this->AmendmentReasonDescription_ = x.AmendmentReasonDescription_;
      this->FolioCount_ = x.FolioCount_;
    }

    return *this;
  }

  AmendmentReasonCount::
  ~AmendmentReasonCount ()
  {
  }

  // DeleteReasonCountCollection
  //

  DeleteReasonCountCollection::
  DeleteReasonCountCollection ()
  : ::xml_schema::type (),
    DeleteReasonCount_ (this)
  {
  }

  DeleteReasonCountCollection::
  DeleteReasonCountCollection (const DeleteReasonCountCollection& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DeleteReasonCount_ (x.DeleteReasonCount_, f, this)
  {
  }

  DeleteReasonCountCollection::
  DeleteReasonCountCollection (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DeleteReasonCount_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeleteReasonCountCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DeleteReasonCount
      //
      if (n.name () == "DeleteReasonCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeleteReasonCount_type > r (
          DeleteReasonCount_traits::create (i, f, this));

        this->DeleteReasonCount_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  DeleteReasonCountCollection* DeleteReasonCountCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeleteReasonCountCollection (*this, f, c);
  }

  DeleteReasonCountCollection& DeleteReasonCountCollection::
  operator= (const DeleteReasonCountCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DeleteReasonCount_ = x.DeleteReasonCount_;
    }

    return *this;
  }

  DeleteReasonCountCollection::
  ~DeleteReasonCountCollection ()
  {
  }

  // DeleteReasonCount
  //

  DeleteReasonCount::
  DeleteReasonCount (const DeleteReasonCode_type& DeleteReasonCode,
                     const FolioCount_type& FolioCount)
  : ::xml_schema::type (),
    DeleteReasonCode_ (DeleteReasonCode, this),
    DeleteReasonDescription_ (this),
    FolioCount_ (FolioCount, this)
  {
  }

  DeleteReasonCount::
  DeleteReasonCount (const DeleteReasonCount& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    DeleteReasonCode_ (x.DeleteReasonCode_, f, this),
    DeleteReasonDescription_ (x.DeleteReasonDescription_, f, this),
    FolioCount_ (x.FolioCount_, f, this)
  {
  }

  DeleteReasonCount::
  DeleteReasonCount (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    DeleteReasonCode_ (this),
    DeleteReasonDescription_ (this),
    FolioCount_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DeleteReasonCount::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DeleteReasonCode
      //
      if (n.name () == "DeleteReasonCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeleteReasonCode_type > r (
          DeleteReasonCode_traits::create (i, f, this));

        if (!DeleteReasonCode_.present ())
        {
          this->DeleteReasonCode_.set (::std::move (r));
          continue;
        }
      }

      // DeleteReasonDescription
      //
      if (n.name () == "DeleteReasonDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeleteReasonDescription_type > r (
          DeleteReasonDescription_traits::create (i, f, this));

        if (!this->DeleteReasonDescription_)
        {
          this->DeleteReasonDescription_.set (::std::move (r));
          continue;
        }
      }

      // FolioCount
      //
      if (n.name () == "FolioCount" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!FolioCount_.present ())
        {
          this->FolioCount_.set (FolioCount_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!DeleteReasonCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "DeleteReasonCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!FolioCount_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "FolioCount",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  DeleteReasonCount* DeleteReasonCount::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class DeleteReasonCount (*this, f, c);
  }

  DeleteReasonCount& DeleteReasonCount::
  operator= (const DeleteReasonCount& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->DeleteReasonCode_ = x.DeleteReasonCode_;
      this->DeleteReasonDescription_ = x.DeleteReasonDescription_;
      this->FolioCount_ = x.FolioCount_;
    }

    return *this;
  }

  DeleteReasonCount::
  ~DeleteReasonCount ()
  {
  }

  // AssessmentAreaCollection
  //

  AssessmentAreaCollection::
  AssessmentAreaCollection ()
  : ::xml_schema::type (),
    AssessmentArea_ (this)
  {
  }

  AssessmentAreaCollection::
  AssessmentAreaCollection (const AssessmentAreaCollection& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AssessmentArea_ (x.AssessmentArea_, f, this)
  {
  }

  AssessmentAreaCollection::
  AssessmentAreaCollection (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AssessmentArea_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AssessmentAreaCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AssessmentArea
      //
      if (n.name () == "AssessmentArea" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentArea_type > r (
          AssessmentArea_traits::create (i, f, this));

        this->AssessmentArea_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  AssessmentAreaCollection* AssessmentAreaCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AssessmentAreaCollection (*this, f, c);
  }

  AssessmentAreaCollection& AssessmentAreaCollection::
  operator= (const AssessmentAreaCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AssessmentArea_ = x.AssessmentArea_;
    }

    return *this;
  }

  AssessmentAreaCollection::
  ~AssessmentAreaCollection ()
  {
  }

  // AssessmentArea
  //

  AssessmentArea::
  AssessmentArea (const AssessmentAreaCode_type& AssessmentAreaCode)
  : ::xml_schema::type (),
    AssessmentAreaCode_ (AssessmentAreaCode, this),
    AssessmentAreaDescription_ (this),
    Jurisdictions_ (this),
    AreaSummary_ (this)
  {
  }

  AssessmentArea::
  AssessmentArea (const AssessmentArea& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AssessmentAreaCode_ (x.AssessmentAreaCode_, f, this),
    AssessmentAreaDescription_ (x.AssessmentAreaDescription_, f, this),
    Jurisdictions_ (x.Jurisdictions_, f, this),
    AreaSummary_ (x.AreaSummary_, f, this)
  {
  }

  AssessmentArea::
  AssessmentArea (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AssessmentAreaCode_ (this),
    AssessmentAreaDescription_ (this),
    Jurisdictions_ (this),
    AreaSummary_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void AssessmentArea::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AssessmentAreaCode
      //
      if (n.name () == "AssessmentAreaCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentAreaCode_type > r (
          AssessmentAreaCode_traits::create (i, f, this));

        if (!AssessmentAreaCode_.present ())
        {
          this->AssessmentAreaCode_.set (::std::move (r));
          continue;
        }
      }

      // AssessmentAreaDescription
      //
      if (n.name () == "AssessmentAreaDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentAreaDescription_type > r (
          AssessmentAreaDescription_traits::create (i, f, this));

        if (!this->AssessmentAreaDescription_)
        {
          this->AssessmentAreaDescription_.set (::std::move (r));
          continue;
        }
      }

      // Jurisdictions
      //
      if (n.name () == "Jurisdictions" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Jurisdictions_type > r (
          Jurisdictions_traits::create (i, f, this));

        if (!this->Jurisdictions_)
        {
          this->Jurisdictions_.set (::std::move (r));
          continue;
        }
      }

      // AreaSummary
      //
      if (n.name () == "AreaSummary" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AreaSummary_type > r (
          AreaSummary_traits::create (i, f, this));

        if (!this->AreaSummary_)
        {
          this->AreaSummary_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!AssessmentAreaCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AssessmentAreaCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  AssessmentArea* AssessmentArea::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AssessmentArea (*this, f, c);
  }

  AssessmentArea& AssessmentArea::
  operator= (const AssessmentArea& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AssessmentAreaCode_ = x.AssessmentAreaCode_;
      this->AssessmentAreaDescription_ = x.AssessmentAreaDescription_;
      this->Jurisdictions_ = x.Jurisdictions_;
      this->AreaSummary_ = x.AreaSummary_;
    }

    return *this;
  }

  AssessmentArea::
  ~AssessmentArea ()
  {
  }

  // AssessmentAreaCode
  //

  AssessmentAreaCode::
  AssessmentAreaCode ()
  : ::xml_schema::string ()
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const AssessmentAreaCode& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  AssessmentAreaCode::
  AssessmentAreaCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  AssessmentAreaCode* AssessmentAreaCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class AssessmentAreaCode (*this, f, c);
  }

  AssessmentAreaCode::
  ~AssessmentAreaCode ()
  {
  }

  // JurisdictionCollection
  //

  JurisdictionCollection::
  JurisdictionCollection ()
  : ::xml_schema::type (),
    Jurisdiction_ (this)
  {
  }

  JurisdictionCollection::
  JurisdictionCollection (const JurisdictionCollection& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Jurisdiction_ (x.Jurisdiction_, f, this)
  {
  }

  JurisdictionCollection::
  JurisdictionCollection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Jurisdiction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void JurisdictionCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Jurisdiction
      //
      if (n.name () == "Jurisdiction" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Jurisdiction_type > r (
          Jurisdiction_traits::create (i, f, this));

        this->Jurisdiction_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  JurisdictionCollection* JurisdictionCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class JurisdictionCollection (*this, f, c);
  }

  JurisdictionCollection& JurisdictionCollection::
  operator= (const JurisdictionCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Jurisdiction_ = x.Jurisdiction_;
    }

    return *this;
  }

  JurisdictionCollection::
  ~JurisdictionCollection ()
  {
  }

  // Jurisdiction
  //

  Jurisdiction::
  Jurisdiction (const JurisdictionCode_type& JurisdictionCode)
  : ::xml_schema::type (),
    JurisdictionCode_ (JurisdictionCode, this),
    JurisdictionDescription_ (this),
    FolioRecords_ (this),
    JurisdictionSummary_ (this)
  {
  }

  Jurisdiction::
  Jurisdiction (const Jurisdiction& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    JurisdictionCode_ (x.JurisdictionCode_, f, this),
    JurisdictionDescription_ (x.JurisdictionDescription_, f, this),
    FolioRecords_ (x.FolioRecords_, f, this),
    JurisdictionSummary_ (x.JurisdictionSummary_, f, this)
  {
  }

  Jurisdiction::
  Jurisdiction (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    JurisdictionCode_ (this),
    JurisdictionDescription_ (this),
    FolioRecords_ (this),
    JurisdictionSummary_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Jurisdiction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // JurisdictionCode
      //
      if (n.name () == "JurisdictionCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< JurisdictionCode_type > r (
          JurisdictionCode_traits::create (i, f, this));

        if (!JurisdictionCode_.present ())
        {
          this->JurisdictionCode_.set (::std::move (r));
          continue;
        }
      }

      // JurisdictionDescription
      //
      if (n.name () == "JurisdictionDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< JurisdictionDescription_type > r (
          JurisdictionDescription_traits::create (i, f, this));

        if (!this->JurisdictionDescription_)
        {
          this->JurisdictionDescription_.set (::std::move (r));
          continue;
        }
      }

      // FolioRecords
      //
      if (n.name () == "FolioRecords" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioRecords_type > r (
          FolioRecords_traits::create (i, f, this));

        if (!this->FolioRecords_)
        {
          this->FolioRecords_.set (::std::move (r));
          continue;
        }
      }

      // JurisdictionSummary
      //
      if (n.name () == "JurisdictionSummary" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< JurisdictionSummary_type > r (
          JurisdictionSummary_traits::create (i, f, this));

        if (!this->JurisdictionSummary_)
        {
          this->JurisdictionSummary_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!JurisdictionCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "JurisdictionCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  Jurisdiction* Jurisdiction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Jurisdiction (*this, f, c);
  }

  Jurisdiction& Jurisdiction::
  operator= (const Jurisdiction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->JurisdictionCode_ = x.JurisdictionCode_;
      this->JurisdictionDescription_ = x.JurisdictionDescription_;
      this->FolioRecords_ = x.FolioRecords_;
      this->JurisdictionSummary_ = x.JurisdictionSummary_;
    }

    return *this;
  }

  Jurisdiction::
  ~Jurisdiction ()
  {
  }

  // JurisdictionCode
  //

  JurisdictionCode::
  JurisdictionCode ()
  : ::xml_schema::string ()
  {
  }

  JurisdictionCode::
  JurisdictionCode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  JurisdictionCode::
  JurisdictionCode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  JurisdictionCode::
  JurisdictionCode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  JurisdictionCode::
  JurisdictionCode (const JurisdictionCode& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  JurisdictionCode::
  JurisdictionCode (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  JurisdictionCode::
  JurisdictionCode (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  JurisdictionCode::
  JurisdictionCode (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  JurisdictionCode* JurisdictionCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class JurisdictionCode (*this, f, c);
  }

  JurisdictionCode::
  ~JurisdictionCode ()
  {
  }

  // FolioGroupValues
  //

  FolioGroupValues::
  FolioGroupValues (const LandValue_type& LandValue,
                    const ImprovementValue_type& ImprovementValue)
  : ::xml_schema::type (),
    LandValue_ (LandValue, this),
    ImprovementValue_ (ImprovementValue, this),
    ParkingAreaValue_ (this)
  {
  }

  FolioGroupValues::
  FolioGroupValues (const FolioGroupValues& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    LandValue_ (x.LandValue_, f, this),
    ImprovementValue_ (x.ImprovementValue_, f, this),
    ParkingAreaValue_ (x.ParkingAreaValue_, f, this)
  {
  }

  FolioGroupValues::
  FolioGroupValues (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    LandValue_ (this),
    ImprovementValue_ (this),
    ParkingAreaValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioGroupValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LandValue
      //
      if (n.name () == "LandValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!LandValue_.present ())
        {
          this->LandValue_.set (LandValue_traits::create (i, f, this));
          continue;
        }
      }

      // ImprovementValue
      //
      if (n.name () == "ImprovementValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!ImprovementValue_.present ())
        {
          this->ImprovementValue_.set (ImprovementValue_traits::create (i, f, this));
          continue;
        }
      }

      // ParkingAreaValue
      //
      if (n.name () == "ParkingAreaValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!this->ParkingAreaValue_)
        {
          this->ParkingAreaValue_.set (ParkingAreaValue_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!LandValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LandValue",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!ImprovementValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ImprovementValue",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  FolioGroupValues* FolioGroupValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioGroupValues (*this, f, c);
  }

  FolioGroupValues& FolioGroupValues::
  operator= (const FolioGroupValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->LandValue_ = x.LandValue_;
      this->ImprovementValue_ = x.ImprovementValue_;
      this->ParkingAreaValue_ = x.ParkingAreaValue_;
    }

    return *this;
  }

  FolioGroupValues::
  ~FolioGroupValues ()
  {
  }

  // FolioRecordCollection
  //

  FolioRecordCollection::
  FolioRecordCollection ()
  : ::xml_schema::type (),
    FolioRecord_ (this)
  {
  }

  FolioRecordCollection::
  FolioRecordCollection (const FolioRecordCollection& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FolioRecord_ (x.FolioRecord_, f, this)
  {
  }

  FolioRecordCollection::
  FolioRecordCollection (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FolioRecord_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioRecordCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FolioRecord
      //
      if (n.name () == "FolioRecord" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioRecord_type > r (
          FolioRecord_traits::create (i, f, this));

        this->FolioRecord_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FolioRecordCollection* FolioRecordCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioRecordCollection (*this, f, c);
  }

  FolioRecordCollection& FolioRecordCollection::
  operator= (const FolioRecordCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FolioRecord_ = x.FolioRecord_;
    }

    return *this;
  }

  FolioRecordCollection::
  ~FolioRecordCollection ()
  {
  }

  // FolioRecord
  //

  FolioRecord::
  FolioRecord (const RollNumber_type& RollNumber)
  : ::xml_schema::type (),
    RollNumber_ (RollNumber, this),
    FolioStatus_ (this),
    FolioStatusDescription_ (this),
    FolioAction_ (this),
    FolioAddresses_ (this),
    OwnershipGroups_ (this),
    LegalDescriptions_ (this),
    FolioDescription_ (this),
    Sales_ (this),
    Values_ (this),
    Amendments_ (this),
    MinorTaxing_ (this),
    Farms_ (this),
    ManufacturedHomes_ (this),
    ManagedForests_ (this),
    OilAndGas_ (this),
    LandCharacteristics_ (this)
  {
  }

  FolioRecord::
  FolioRecord (::std::unique_ptr< RollNumber_type > RollNumber)
  : ::xml_schema::type (),
    RollNumber_ (std::move (RollNumber), this),
    FolioStatus_ (this),
    FolioStatusDescription_ (this),
    FolioAction_ (this),
    FolioAddresses_ (this),
    OwnershipGroups_ (this),
    LegalDescriptions_ (this),
    FolioDescription_ (this),
    Sales_ (this),
    Values_ (this),
    Amendments_ (this),
    MinorTaxing_ (this),
    Farms_ (this),
    ManufacturedHomes_ (this),
    ManagedForests_ (this),
    OilAndGas_ (this),
    LandCharacteristics_ (this)
  {
  }

  FolioRecord::
  FolioRecord (const FolioRecord& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    RollNumber_ (x.RollNumber_, f, this),
    FolioStatus_ (x.FolioStatus_, f, this),
    FolioStatusDescription_ (x.FolioStatusDescription_, f, this),
    FolioAction_ (x.FolioAction_, f, this),
    FolioAddresses_ (x.FolioAddresses_, f, this),
    OwnershipGroups_ (x.OwnershipGroups_, f, this),
    LegalDescriptions_ (x.LegalDescriptions_, f, this),
    FolioDescription_ (x.FolioDescription_, f, this),
    Sales_ (x.Sales_, f, this),
    Values_ (x.Values_, f, this),
    Amendments_ (x.Amendments_, f, this),
    MinorTaxing_ (x.MinorTaxing_, f, this),
    Farms_ (x.Farms_, f, this),
    ManufacturedHomes_ (x.ManufacturedHomes_, f, this),
    ManagedForests_ (x.ManagedForests_, f, this),
    OilAndGas_ (x.OilAndGas_, f, this),
    LandCharacteristics_ (x.LandCharacteristics_, f, this)
  {
  }

  FolioRecord::
  FolioRecord (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    RollNumber_ (this),
    FolioStatus_ (this),
    FolioStatusDescription_ (this),
    FolioAction_ (this),
    FolioAddresses_ (this),
    OwnershipGroups_ (this),
    LegalDescriptions_ (this),
    FolioDescription_ (this),
    Sales_ (this),
    Values_ (this),
    Amendments_ (this),
    MinorTaxing_ (this),
    Farms_ (this),
    ManufacturedHomes_ (this),
    ManagedForests_ (this),
    OilAndGas_ (this),
    LandCharacteristics_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioRecord::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // RollNumber
      //
      if (n.name () == "RollNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RollNumber_type > r (
          RollNumber_traits::create (i, f, this));

        if (!RollNumber_.present ())
        {
          this->RollNumber_.set (::std::move (r));
          continue;
        }
      }

      // FolioStatus
      //
      if (n.name () == "FolioStatus" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioStatus_type > r (
          FolioStatus_traits::create (i, f, this));

        if (!this->FolioStatus_)
        {
          this->FolioStatus_.set (::std::move (r));
          continue;
        }
      }

      // FolioStatusDescription
      //
      if (n.name () == "FolioStatusDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioStatusDescription_type > r (
          FolioStatusDescription_traits::create (i, f, this));

        if (!this->FolioStatusDescription_)
        {
          this->FolioStatusDescription_.set (::std::move (r));
          continue;
        }
      }

      // FolioAction
      //
      if (n.name () == "FolioAction" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioAction_type > r (
          FolioAction_traits::create (i, f, this));

        if (!this->FolioAction_)
        {
          this->FolioAction_.set (::std::move (r));
          continue;
        }
      }

      // FolioAddresses
      //
      if (n.name () == "FolioAddresses" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioAddresses_type > r (
          FolioAddresses_traits::create (i, f, this));

        if (!this->FolioAddresses_)
        {
          this->FolioAddresses_.set (::std::move (r));
          continue;
        }
      }

      // OwnershipGroups
      //
      if (n.name () == "OwnershipGroups" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< OwnershipGroups_type > r (
          OwnershipGroups_traits::create (i, f, this));

        if (!this->OwnershipGroups_)
        {
          this->OwnershipGroups_.set (::std::move (r));
          continue;
        }
      }

      // LegalDescriptions
      //
      if (n.name () == "LegalDescriptions" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LegalDescriptions_type > r (
          LegalDescriptions_traits::create (i, f, this));

        if (!this->LegalDescriptions_)
        {
          this->LegalDescriptions_.set (::std::move (r));
          continue;
        }
      }

      // FolioDescription
      //
      if (n.name () == "FolioDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioDescription_type > r (
          FolioDescription_traits::create (i, f, this));

        if (!this->FolioDescription_)
        {
          this->FolioDescription_.set (::std::move (r));
          continue;
        }
      }

      // Sales
      //
      if (n.name () == "Sales" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Sales_type > r (
          Sales_traits::create (i, f, this));

        if (!this->Sales_)
        {
          this->Sales_.set (::std::move (r));
          continue;
        }
      }

      // Values
      //
      if (n.name () == "Values" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Values_type > r (
          Values_traits::create (i, f, this));

        if (!this->Values_)
        {
          this->Values_.set (::std::move (r));
          continue;
        }
      }

      // Amendments
      //
      if (n.name () == "Amendments" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Amendments_type > r (
          Amendments_traits::create (i, f, this));

        if (!this->Amendments_)
        {
          this->Amendments_.set (::std::move (r));
          continue;
        }
      }

      // MinorTaxing
      //
      if (n.name () == "MinorTaxing" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MinorTaxing_type > r (
          MinorTaxing_traits::create (i, f, this));

        if (!this->MinorTaxing_)
        {
          this->MinorTaxing_.set (::std::move (r));
          continue;
        }
      }

      // Farms
      //
      if (n.name () == "Farms" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Farms_type > r (
          Farms_traits::create (i, f, this));

        if (!this->Farms_)
        {
          this->Farms_.set (::std::move (r));
          continue;
        }
      }

      // ManufacturedHomes
      //
      if (n.name () == "ManufacturedHomes" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManufacturedHomes_type > r (
          ManufacturedHomes_traits::create (i, f, this));

        if (!this->ManufacturedHomes_)
        {
          this->ManufacturedHomes_.set (::std::move (r));
          continue;
        }
      }

      // ManagedForests
      //
      if (n.name () == "ManagedForests" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManagedForests_type > r (
          ManagedForests_traits::create (i, f, this));

        if (!this->ManagedForests_)
        {
          this->ManagedForests_.set (::std::move (r));
          continue;
        }
      }

      // OilAndGas
      //
      if (n.name () == "OilAndGas" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< OilAndGas_type > r (
          OilAndGas_traits::create (i, f, this));

        if (!this->OilAndGas_)
        {
          this->OilAndGas_.set (::std::move (r));
          continue;
        }
      }

      // LandCharacteristics
      //
      if (n.name () == "LandCharacteristics" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandCharacteristics_type > r (
          LandCharacteristics_traits::create (i, f, this));

        if (!this->LandCharacteristics_)
        {
          this->LandCharacteristics_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!RollNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RollNumber",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  FolioRecord* FolioRecord::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioRecord (*this, f, c);
  }

  FolioRecord& FolioRecord::
  operator= (const FolioRecord& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->RollNumber_ = x.RollNumber_;
      this->FolioStatus_ = x.FolioStatus_;
      this->FolioStatusDescription_ = x.FolioStatusDescription_;
      this->FolioAction_ = x.FolioAction_;
      this->FolioAddresses_ = x.FolioAddresses_;
      this->OwnershipGroups_ = x.OwnershipGroups_;
      this->LegalDescriptions_ = x.LegalDescriptions_;
      this->FolioDescription_ = x.FolioDescription_;
      this->Sales_ = x.Sales_;
      this->Values_ = x.Values_;
      this->Amendments_ = x.Amendments_;
      this->MinorTaxing_ = x.MinorTaxing_;
      this->Farms_ = x.Farms_;
      this->ManufacturedHomes_ = x.ManufacturedHomes_;
      this->ManagedForests_ = x.ManagedForests_;
      this->OilAndGas_ = x.OilAndGas_;
      this->LandCharacteristics_ = x.LandCharacteristics_;
    }

    return *this;
  }

  FolioRecord::
  ~FolioRecord ()
  {
  }

  // String32
  //

  String32::
  String32 ()
  : ::xml_schema::string ()
  {
  }

  String32::
  String32 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String32::
  String32 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String32::
  String32 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String32::
  String32 (const String32& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  String32::
  String32 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  String32::
  String32 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  String32::
  String32 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  String32* String32::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String32 (*this, f, c);
  }

  String32::
  ~String32 ()
  {
  }

  // FolioRollNumber
  //

  FolioRollNumber::
  FolioRollNumber ()
  : ::dataadvice::String32 (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioRollNumber::
  FolioRollNumber (const char* _xsd_string_base)
  : ::dataadvice::String32 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioRollNumber::
  FolioRollNumber (const ::std::string& _xsd_string_base)
  : ::dataadvice::String32 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioRollNumber::
  FolioRollNumber (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::String32 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioRollNumber::
  FolioRollNumber (const FolioRollNumber& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::String32 (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioRollNumber::
  FolioRollNumber (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::String32 (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioRollNumber::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioRollNumber* FolioRollNumber::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioRollNumber (*this, f, c);
  }

  FolioRollNumber& FolioRollNumber::
  operator= (const FolioRollNumber& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::String32& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioRollNumber::
  ~FolioRollNumber ()
  {
  }

  // FolioAction
  //

  FolioAction::
  FolioAction ()
  : ::xml_schema::type (),
    FolioAdd_ (this),
    FolioDelete_ (this)
  {
  }

  FolioAction::
  FolioAction (const FolioAction& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FolioAdd_ (x.FolioAdd_, f, this),
    FolioDelete_ (x.FolioDelete_, f, this)
  {
  }

  FolioAction::
  FolioAction (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FolioAdd_ (this),
    FolioDelete_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioAction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FolioAdd
      //
      if (n.name () == "FolioAdd" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioAdd_type > r (
          FolioAdd_traits::create (i, f, this));

        if (!this->FolioAdd_)
        {
          this->FolioAdd_.set (::std::move (r));
          continue;
        }
      }

      // FolioDelete
      //
      if (n.name () == "FolioDelete" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioDelete_type > r (
          FolioDelete_traits::create (i, f, this));

        if (!this->FolioDelete_)
        {
          this->FolioDelete_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FolioAction* FolioAction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioAction (*this, f, c);
  }

  FolioAction& FolioAction::
  operator= (const FolioAction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FolioAdd_ = x.FolioAdd_;
      this->FolioDelete_ = x.FolioDelete_;
    }

    return *this;
  }

  FolioAction::
  ~FolioAction ()
  {
  }

  // FolioAdd
  //

  FolioAdd::
  FolioAdd ()
  : ::xml_schema::type (),
    FolioRenumber_ (this)
  {
  }

  FolioAdd::
  FolioAdd (const FolioAdd& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FolioRenumber_ (x.FolioRenumber_, f, this)
  {
  }

  FolioAdd::
  FolioAdd (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FolioRenumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioAdd::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FolioRenumber
      //
      if (n.name () == "FolioRenumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioRenumber_type > r (
          FolioRenumber_traits::create (i, f, this));

        if (!this->FolioRenumber_)
        {
          this->FolioRenumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FolioAdd* FolioAdd::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioAdd (*this, f, c);
  }

  FolioAdd& FolioAdd::
  operator= (const FolioAdd& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FolioRenumber_ = x.FolioRenumber_;
    }

    return *this;
  }

  FolioAdd::
  ~FolioAdd ()
  {
  }

  // FolioDelete
  //

  FolioDelete::
  FolioDelete ()
  : ::xml_schema::type (),
    FolioRenumber_ (this),
    DeleteReasonCode_ (this),
    DeleteReasonDescription_ (this)
  {
  }

  FolioDelete::
  FolioDelete (const FolioDelete& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    FolioRenumber_ (x.FolioRenumber_, f, this),
    DeleteReasonCode_ (x.DeleteReasonCode_, f, this),
    DeleteReasonDescription_ (x.DeleteReasonDescription_, f, this)
  {
  }

  FolioDelete::
  FolioDelete (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    FolioRenumber_ (this),
    DeleteReasonCode_ (this),
    DeleteReasonDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioDelete::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FolioRenumber
      //
      if (n.name () == "FolioRenumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioRenumber_type > r (
          FolioRenumber_traits::create (i, f, this));

        if (!this->FolioRenumber_)
        {
          this->FolioRenumber_.set (::std::move (r));
          continue;
        }
      }

      // DeleteReasonCode
      //
      if (n.name () == "DeleteReasonCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeleteReasonCode_type > r (
          DeleteReasonCode_traits::create (i, f, this));

        if (!this->DeleteReasonCode_)
        {
          this->DeleteReasonCode_.set (::std::move (r));
          continue;
        }
      }

      // DeleteReasonDescription
      //
      if (n.name () == "DeleteReasonDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeleteReasonDescription_type > r (
          DeleteReasonDescription_traits::create (i, f, this));

        if (!this->DeleteReasonDescription_)
        {
          this->DeleteReasonDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FolioDelete* FolioDelete::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioDelete (*this, f, c);
  }

  FolioDelete& FolioDelete::
  operator= (const FolioDelete& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->FolioRenumber_ = x.FolioRenumber_;
      this->DeleteReasonCode_ = x.DeleteReasonCode_;
      this->DeleteReasonDescription_ = x.DeleteReasonDescription_;
    }

    return *this;
  }

  FolioDelete::
  ~FolioDelete ()
  {
  }

  // FolioRenumber
  //

  FolioRenumber::
  FolioRenumber (const AssessmentAreaCode_type& AssessmentAreaCode,
                 const JurisdictionCode_type& JurisdictionCode,
                 const RollNumber_type& RollNumber)
  : ::xml_schema::type (),
    AssessmentAreaCode_ (AssessmentAreaCode, this),
    AssessmentAreaDescription_ (this),
    JurisdictionCode_ (JurisdictionCode, this),
    JurisdictionDescription_ (this),
    RollNumber_ (RollNumber, this)
  {
  }

  FolioRenumber::
  FolioRenumber (const FolioRenumber& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    AssessmentAreaCode_ (x.AssessmentAreaCode_, f, this),
    AssessmentAreaDescription_ (x.AssessmentAreaDescription_, f, this),
    JurisdictionCode_ (x.JurisdictionCode_, f, this),
    JurisdictionDescription_ (x.JurisdictionDescription_, f, this),
    RollNumber_ (x.RollNumber_, f, this)
  {
  }

  FolioRenumber::
  FolioRenumber (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    AssessmentAreaCode_ (this),
    AssessmentAreaDescription_ (this),
    JurisdictionCode_ (this),
    JurisdictionDescription_ (this),
    RollNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void FolioRenumber::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AssessmentAreaCode
      //
      if (n.name () == "AssessmentAreaCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentAreaCode_type > r (
          AssessmentAreaCode_traits::create (i, f, this));

        if (!AssessmentAreaCode_.present ())
        {
          this->AssessmentAreaCode_.set (::std::move (r));
          continue;
        }
      }

      // AssessmentAreaDescription
      //
      if (n.name () == "AssessmentAreaDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentAreaDescription_type > r (
          AssessmentAreaDescription_traits::create (i, f, this));

        if (!this->AssessmentAreaDescription_)
        {
          this->AssessmentAreaDescription_.set (::std::move (r));
          continue;
        }
      }

      // JurisdictionCode
      //
      if (n.name () == "JurisdictionCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< JurisdictionCode_type > r (
          JurisdictionCode_traits::create (i, f, this));

        if (!JurisdictionCode_.present ())
        {
          this->JurisdictionCode_.set (::std::move (r));
          continue;
        }
      }

      // JurisdictionDescription
      //
      if (n.name () == "JurisdictionDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< JurisdictionDescription_type > r (
          JurisdictionDescription_traits::create (i, f, this));

        if (!this->JurisdictionDescription_)
        {
          this->JurisdictionDescription_.set (::std::move (r));
          continue;
        }
      }

      // RollNumber
      //
      if (n.name () == "RollNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RollNumber_type > r (
          RollNumber_traits::create (i, f, this));

        if (!RollNumber_.present ())
        {
          this->RollNumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!AssessmentAreaCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "AssessmentAreaCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!JurisdictionCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "JurisdictionCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!RollNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RollNumber",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  FolioRenumber* FolioRenumber::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioRenumber (*this, f, c);
  }

  FolioRenumber& FolioRenumber::
  operator= (const FolioRenumber& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->AssessmentAreaCode_ = x.AssessmentAreaCode_;
      this->AssessmentAreaDescription_ = x.AssessmentAreaDescription_;
      this->JurisdictionCode_ = x.JurisdictionCode_;
      this->JurisdictionDescription_ = x.JurisdictionDescription_;
      this->RollNumber_ = x.RollNumber_;
    }

    return *this;
  }

  FolioRenumber::
  ~FolioRenumber ()
  {
  }

  // FolioItemGroup
  //

  FolioItemGroup::
  FolioItemGroup ()
  : ::xml_schema::type (),
    Action_ (this)
  {
  }

  FolioItemGroup::
  FolioItemGroup (const FolioItemGroup& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Action_ (x.Action_, f, this)
  {
  }

  FolioItemGroup::
  FolioItemGroup (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Action_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioItemGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioItemGroup* FolioItemGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioItemGroup (*this, f, c);
  }

  FolioItemGroup& FolioItemGroup::
  operator= (const FolioItemGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->Action_ = x.Action_;
    }

    return *this;
  }

  FolioItemGroup::
  ~FolioItemGroup ()
  {
  }

  // FolioAddressCollection
  //

  FolioAddressCollection::
  FolioAddressCollection ()
  : ::dataadvice::FolioItemGroup (),
    FolioAddress_ (this)
  {
  }

  FolioAddressCollection::
  FolioAddressCollection (const FolioAddressCollection& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    FolioAddress_ (x.FolioAddress_, f, this)
  {
  }

  FolioAddressCollection::
  FolioAddressCollection (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    FolioAddress_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FolioAddressCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FolioAddress
      //
      if (n.name () == "FolioAddress" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FolioAddress_type > r (
          FolioAddress_traits::create (i, f, this));

        this->FolioAddress_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FolioAddressCollection* FolioAddressCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioAddressCollection (*this, f, c);
  }

  FolioAddressCollection& FolioAddressCollection::
  operator= (const FolioAddressCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->FolioAddress_ = x.FolioAddress_;
    }

    return *this;
  }

  FolioAddressCollection::
  ~FolioAddressCollection ()
  {
  }

  // FolioAddress
  //

  FolioAddress::
  FolioAddress ()
  : ::dataadvice::FolioItemGroup (),
    PrimaryFlag_ (this),
    UnitNumber_ (this),
    StreetNumber_ (this),
    StreetDirectionPrefix_ (this),
    StreetName_ (this),
    StreetType_ (this),
    StreetDirectionSuffix_ (this),
    City_ (this),
    ProvinceState_ (this),
    PostalZip_ (this),
    MapReferenceNumber_ (this)
  {
  }

  FolioAddress::
  FolioAddress (const FolioAddress& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    PrimaryFlag_ (x.PrimaryFlag_, f, this),
    UnitNumber_ (x.UnitNumber_, f, this),
    StreetNumber_ (x.StreetNumber_, f, this),
    StreetDirectionPrefix_ (x.StreetDirectionPrefix_, f, this),
    StreetName_ (x.StreetName_, f, this),
    StreetType_ (x.StreetType_, f, this),
    StreetDirectionSuffix_ (x.StreetDirectionSuffix_, f, this),
    City_ (x.City_, f, this),
    ProvinceState_ (x.ProvinceState_, f, this),
    PostalZip_ (x.PostalZip_, f, this),
    MapReferenceNumber_ (x.MapReferenceNumber_, f, this)
  {
  }

  FolioAddress::
  FolioAddress (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    PrimaryFlag_ (this),
    UnitNumber_ (this),
    StreetNumber_ (this),
    StreetDirectionPrefix_ (this),
    StreetName_ (this),
    StreetType_ (this),
    StreetDirectionSuffix_ (this),
    City_ (this),
    ProvinceState_ (this),
    PostalZip_ (this),
    MapReferenceNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FolioAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PrimaryFlag
      //
      if (n.name () == "PrimaryFlag" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PrimaryFlag_type > r (
          PrimaryFlag_traits::create (i, f, this));

        if (!this->PrimaryFlag_)
        {
          this->PrimaryFlag_.set (::std::move (r));
          continue;
        }
      }

      // UnitNumber
      //
      if (n.name () == "UnitNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< UnitNumber_type > r (
          UnitNumber_traits::create (i, f, this));

        if (!this->UnitNumber_)
        {
          this->UnitNumber_.set (::std::move (r));
          continue;
        }
      }

      // StreetNumber
      //
      if (n.name () == "StreetNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetNumber_type > r (
          StreetNumber_traits::create (i, f, this));

        if (!this->StreetNumber_)
        {
          this->StreetNumber_.set (::std::move (r));
          continue;
        }
      }

      // StreetDirectionPrefix
      //
      if (n.name () == "StreetDirectionPrefix" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetDirectionPrefix_type > r (
          StreetDirectionPrefix_traits::create (i, f, this));

        if (!this->StreetDirectionPrefix_)
        {
          this->StreetDirectionPrefix_.set (::std::move (r));
          continue;
        }
      }

      // StreetName
      //
      if (n.name () == "StreetName" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetName_type > r (
          StreetName_traits::create (i, f, this));

        if (!this->StreetName_)
        {
          this->StreetName_.set (::std::move (r));
          continue;
        }
      }

      // StreetType
      //
      if (n.name () == "StreetType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetType_type > r (
          StreetType_traits::create (i, f, this));

        if (!this->StreetType_)
        {
          this->StreetType_.set (::std::move (r));
          continue;
        }
      }

      // StreetDirectionSuffix
      //
      if (n.name () == "StreetDirectionSuffix" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetDirectionSuffix_type > r (
          StreetDirectionSuffix_traits::create (i, f, this));

        if (!this->StreetDirectionSuffix_)
        {
          this->StreetDirectionSuffix_.set (::std::move (r));
          continue;
        }
      }

      // City
      //
      if (n.name () == "City" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< City_type > r (
          City_traits::create (i, f, this));

        if (!this->City_)
        {
          this->City_.set (::std::move (r));
          continue;
        }
      }

      // ProvinceState
      //
      if (n.name () == "ProvinceState" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ProvinceState_type > r (
          ProvinceState_traits::create (i, f, this));

        if (!this->ProvinceState_)
        {
          this->ProvinceState_.set (::std::move (r));
          continue;
        }
      }

      // PostalZip
      //
      if (n.name () == "PostalZip" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PostalZip_type > r (
          PostalZip_traits::create (i, f, this));

        if (!this->PostalZip_)
        {
          this->PostalZip_.set (::std::move (r));
          continue;
        }
      }

      // MapReferenceNumber
      //
      if (n.name () == "MapReferenceNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MapReferenceNumber_type > r (
          MapReferenceNumber_traits::create (i, f, this));

        if (!this->MapReferenceNumber_)
        {
          this->MapReferenceNumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FolioAddress* FolioAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioAddress (*this, f, c);
  }

  FolioAddress& FolioAddress::
  operator= (const FolioAddress& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->PrimaryFlag_ = x.PrimaryFlag_;
      this->UnitNumber_ = x.UnitNumber_;
      this->StreetNumber_ = x.StreetNumber_;
      this->StreetDirectionPrefix_ = x.StreetDirectionPrefix_;
      this->StreetName_ = x.StreetName_;
      this->StreetType_ = x.StreetType_;
      this->StreetDirectionSuffix_ = x.StreetDirectionSuffix_;
      this->City_ = x.City_;
      this->ProvinceState_ = x.ProvinceState_;
      this->PostalZip_ = x.PostalZip_;
      this->MapReferenceNumber_ = x.MapReferenceNumber_;
    }

    return *this;
  }

  FolioAddress::
  ~FolioAddress ()
  {
  }

  // OwnershipGroupCollection
  //

  OwnershipGroupCollection::
  OwnershipGroupCollection ()
  : ::dataadvice::FolioItemGroup (),
    OwnershipGroup_ (this)
  {
  }

  OwnershipGroupCollection::
  OwnershipGroupCollection (const OwnershipGroupCollection& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    OwnershipGroup_ (x.OwnershipGroup_, f, this)
  {
  }

  OwnershipGroupCollection::
  OwnershipGroupCollection (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    OwnershipGroup_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OwnershipGroupCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OwnershipGroup
      //
      if (n.name () == "OwnershipGroup" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< OwnershipGroup_type > r (
          OwnershipGroup_traits::create (i, f, this));

        this->OwnershipGroup_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  OwnershipGroupCollection* OwnershipGroupCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OwnershipGroupCollection (*this, f, c);
  }

  OwnershipGroupCollection& OwnershipGroupCollection::
  operator= (const OwnershipGroupCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->OwnershipGroup_ = x.OwnershipGroup_;
    }

    return *this;
  }

  OwnershipGroupCollection::
  ~OwnershipGroupCollection ()
  {
  }

  // OwnershipGroup
  //

  OwnershipGroup::
  OwnershipGroup ()
  : ::dataadvice::FolioItemGroup (),
    OwnershipGroupID_ (this),
    TenureCode_ (this),
    TenureDescription_ (this),
    AssessmentNoticeReturned_ (this),
    AssessmentNoticeSuppressed_ (this),
    ChangeType_ (this),
    ChangeTypeDescription_ (this),
    ChangeDate_ (this),
    ChangeSource_ (this),
    ChangeSourceDescription_ (this),
    Owners_ (this),
    FormattedMailingAddress_ (this),
    MailingAddress_ (this)
  {
  }

  OwnershipGroup::
  OwnershipGroup (const OwnershipGroup& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    OwnershipGroupID_ (x.OwnershipGroupID_, f, this),
    TenureCode_ (x.TenureCode_, f, this),
    TenureDescription_ (x.TenureDescription_, f, this),
    AssessmentNoticeReturned_ (x.AssessmentNoticeReturned_, f, this),
    AssessmentNoticeSuppressed_ (x.AssessmentNoticeSuppressed_, f, this),
    ChangeType_ (x.ChangeType_, f, this),
    ChangeTypeDescription_ (x.ChangeTypeDescription_, f, this),
    ChangeDate_ (x.ChangeDate_, f, this),
    ChangeSource_ (x.ChangeSource_, f, this),
    ChangeSourceDescription_ (x.ChangeSourceDescription_, f, this),
    Owners_ (x.Owners_, f, this),
    FormattedMailingAddress_ (x.FormattedMailingAddress_, f, this),
    MailingAddress_ (x.MailingAddress_, f, this)
  {
  }

  OwnershipGroup::
  OwnershipGroup (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    OwnershipGroupID_ (this),
    TenureCode_ (this),
    TenureDescription_ (this),
    AssessmentNoticeReturned_ (this),
    AssessmentNoticeSuppressed_ (this),
    ChangeType_ (this),
    ChangeTypeDescription_ (this),
    ChangeDate_ (this),
    ChangeSource_ (this),
    ChangeSourceDescription_ (this),
    Owners_ (this),
    FormattedMailingAddress_ (this),
    MailingAddress_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OwnershipGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OwnershipGroupID
      //
      if (n.name () == "OwnershipGroupID" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< OwnershipGroupID_type > r (
          OwnershipGroupID_traits::create (i, f, this));

        if (!this->OwnershipGroupID_)
        {
          this->OwnershipGroupID_.set (::std::move (r));
          continue;
        }
      }

      // TenureCode
      //
      if (n.name () == "TenureCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TenureCode_type > r (
          TenureCode_traits::create (i, f, this));

        if (!this->TenureCode_)
        {
          this->TenureCode_.set (::std::move (r));
          continue;
        }
      }

      // TenureDescription
      //
      if (n.name () == "TenureDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TenureDescription_type > r (
          TenureDescription_traits::create (i, f, this));

        if (!this->TenureDescription_)
        {
          this->TenureDescription_.set (::std::move (r));
          continue;
        }
      }

      // AssessmentNoticeReturned
      //
      if (n.name () == "AssessmentNoticeReturned" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentNoticeReturned_type > r (
          AssessmentNoticeReturned_traits::create (i, f, this));

        if (!this->AssessmentNoticeReturned_)
        {
          this->AssessmentNoticeReturned_.set (::std::move (r));
          continue;
        }
      }

      // AssessmentNoticeSuppressed
      //
      if (n.name () == "AssessmentNoticeSuppressed" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AssessmentNoticeSuppressed_type > r (
          AssessmentNoticeSuppressed_traits::create (i, f, this));

        if (!this->AssessmentNoticeSuppressed_)
        {
          this->AssessmentNoticeSuppressed_.set (::std::move (r));
          continue;
        }
      }

      // ChangeType
      //
      if (n.name () == "ChangeType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ChangeType_type > r (
          ChangeType_traits::create (i, f, this));

        if (!this->ChangeType_)
        {
          this->ChangeType_.set (::std::move (r));
          continue;
        }
      }

      // ChangeTypeDescription
      //
      if (n.name () == "ChangeTypeDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ChangeTypeDescription_type > r (
          ChangeTypeDescription_traits::create (i, f, this));

        if (!this->ChangeTypeDescription_)
        {
          this->ChangeTypeDescription_.set (::std::move (r));
          continue;
        }
      }

      // ChangeDate
      //
      if (n.name () == "ChangeDate" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ChangeDate_type > r (
          ChangeDate_traits::create (i, f, this));

        if (!this->ChangeDate_)
        {
          this->ChangeDate_.set (::std::move (r));
          continue;
        }
      }

      // ChangeSource
      //
      if (n.name () == "ChangeSource" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ChangeSource_type > r (
          ChangeSource_traits::create (i, f, this));

        if (!this->ChangeSource_)
        {
          this->ChangeSource_.set (::std::move (r));
          continue;
        }
      }

      // ChangeSourceDescription
      //
      if (n.name () == "ChangeSourceDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ChangeSourceDescription_type > r (
          ChangeSourceDescription_traits::create (i, f, this));

        if (!this->ChangeSourceDescription_)
        {
          this->ChangeSourceDescription_.set (::std::move (r));
          continue;
        }
      }

      // Owners
      //
      if (n.name () == "Owners" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Owners_type > r (
          Owners_traits::create (i, f, this));

        if (!this->Owners_)
        {
          this->Owners_.set (::std::move (r));
          continue;
        }
      }

      // FormattedMailingAddress
      //
      if (n.name () == "FormattedMailingAddress" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FormattedMailingAddress_type > r (
          FormattedMailingAddress_traits::create (i, f, this));

        if (!this->FormattedMailingAddress_)
        {
          this->FormattedMailingAddress_.set (::std::move (r));
          continue;
        }
      }

      // MailingAddress
      //
      if (n.name () == "MailingAddress" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MailingAddress_type > r (
          MailingAddress_traits::create (i, f, this));

        if (!this->MailingAddress_)
        {
          this->MailingAddress_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OwnershipGroup* OwnershipGroup::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OwnershipGroup (*this, f, c);
  }

  OwnershipGroup& OwnershipGroup::
  operator= (const OwnershipGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->OwnershipGroupID_ = x.OwnershipGroupID_;
      this->TenureCode_ = x.TenureCode_;
      this->TenureDescription_ = x.TenureDescription_;
      this->AssessmentNoticeReturned_ = x.AssessmentNoticeReturned_;
      this->AssessmentNoticeSuppressed_ = x.AssessmentNoticeSuppressed_;
      this->ChangeType_ = x.ChangeType_;
      this->ChangeTypeDescription_ = x.ChangeTypeDescription_;
      this->ChangeDate_ = x.ChangeDate_;
      this->ChangeSource_ = x.ChangeSource_;
      this->ChangeSourceDescription_ = x.ChangeSourceDescription_;
      this->Owners_ = x.Owners_;
      this->FormattedMailingAddress_ = x.FormattedMailingAddress_;
      this->MailingAddress_ = x.MailingAddress_;
    }

    return *this;
  }

  OwnershipGroup::
  ~OwnershipGroup ()
  {
  }

  // OwnerCollection
  //

  OwnerCollection::
  OwnerCollection ()
  : ::dataadvice::FolioItemGroup (),
    Owner_ (this)
  {
  }

  OwnerCollection::
  OwnerCollection (const OwnerCollection& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Owner_ (x.Owner_, f, this)
  {
  }

  OwnerCollection::
  OwnerCollection (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Owner_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OwnerCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Owner
      //
      if (n.name () == "Owner" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Owner_type > r (
          Owner_traits::create (i, f, this));

        this->Owner_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  OwnerCollection* OwnerCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OwnerCollection (*this, f, c);
  }

  OwnerCollection& OwnerCollection::
  operator= (const OwnerCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Owner_ = x.Owner_;
    }

    return *this;
  }

  OwnerCollection::
  ~OwnerCollection ()
  {
  }

  // Owner
  //

  Owner::
  Owner (const CompanyOrLastName_type& CompanyOrLastName)
  : ::dataadvice::FolioItemGroup (),
    FirstName_ (this),
    MiddleName_ (this),
    MiddleInitial_ (this),
    CompanyOrLastName_ (CompanyOrLastName, this),
    OwnerSequenceID_ (this),
    EquityType_ (this),
    EquityTypeDescription_ (this)
  {
  }

  Owner::
  Owner (::std::unique_ptr< CompanyOrLastName_type > CompanyOrLastName)
  : ::dataadvice::FolioItemGroup (),
    FirstName_ (this),
    MiddleName_ (this),
    MiddleInitial_ (this),
    CompanyOrLastName_ (std::move (CompanyOrLastName), this),
    OwnerSequenceID_ (this),
    EquityType_ (this),
    EquityTypeDescription_ (this)
  {
  }

  Owner::
  Owner (const Owner& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    FirstName_ (x.FirstName_, f, this),
    MiddleName_ (x.MiddleName_, f, this),
    MiddleInitial_ (x.MiddleInitial_, f, this),
    CompanyOrLastName_ (x.CompanyOrLastName_, f, this),
    OwnerSequenceID_ (x.OwnerSequenceID_, f, this),
    EquityType_ (x.EquityType_, f, this),
    EquityTypeDescription_ (x.EquityTypeDescription_, f, this)
  {
  }

  Owner::
  Owner (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    FirstName_ (this),
    MiddleName_ (this),
    MiddleInitial_ (this),
    CompanyOrLastName_ (this),
    OwnerSequenceID_ (this),
    EquityType_ (this),
    EquityTypeDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Owner::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FirstName
      //
      if (n.name () == "FirstName" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FirstName_type > r (
          FirstName_traits::create (i, f, this));

        if (!this->FirstName_)
        {
          this->FirstName_.set (::std::move (r));
          continue;
        }
      }

      // MiddleName
      //
      if (n.name () == "MiddleName" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MiddleName_type > r (
          MiddleName_traits::create (i, f, this));

        if (!this->MiddleName_)
        {
          this->MiddleName_.set (::std::move (r));
          continue;
        }
      }

      // MiddleInitial
      //
      if (n.name () == "MiddleInitial" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MiddleInitial_type > r (
          MiddleInitial_traits::create (i, f, this));

        if (!this->MiddleInitial_)
        {
          this->MiddleInitial_.set (::std::move (r));
          continue;
        }
      }

      // CompanyOrLastName
      //
      if (n.name () == "CompanyOrLastName" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< CompanyOrLastName_type > r (
          CompanyOrLastName_traits::create (i, f, this));

        if (!CompanyOrLastName_.present ())
        {
          this->CompanyOrLastName_.set (::std::move (r));
          continue;
        }
      }

      // OwnerSequenceID
      //
      if (n.name () == "OwnerSequenceID" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< OwnerSequenceID_type > r (
          OwnerSequenceID_traits::create (i, f, this));

        if (!this->OwnerSequenceID_)
        {
          this->OwnerSequenceID_.set (::std::move (r));
          continue;
        }
      }

      // EquityType
      //
      if (n.name () == "EquityType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< EquityType_type > r (
          EquityType_traits::create (i, f, this));

        if (!this->EquityType_)
        {
          this->EquityType_.set (::std::move (r));
          continue;
        }
      }

      // EquityTypeDescription
      //
      if (n.name () == "EquityTypeDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< EquityTypeDescription_type > r (
          EquityTypeDescription_traits::create (i, f, this));

        if (!this->EquityTypeDescription_)
        {
          this->EquityTypeDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!CompanyOrLastName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CompanyOrLastName",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  Owner* Owner::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Owner (*this, f, c);
  }

  Owner& Owner::
  operator= (const Owner& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->FirstName_ = x.FirstName_;
      this->MiddleName_ = x.MiddleName_;
      this->MiddleInitial_ = x.MiddleInitial_;
      this->CompanyOrLastName_ = x.CompanyOrLastName_;
      this->OwnerSequenceID_ = x.OwnerSequenceID_;
      this->EquityType_ = x.EquityType_;
      this->EquityTypeDescription_ = x.EquityTypeDescription_;
    }

    return *this;
  }

  Owner::
  ~Owner ()
  {
  }

  // MailingAddress
  //

  MailingAddress::
  MailingAddress ()
  : ::dataadvice::FolioItemGroup (),
    Attention_ (this),
    CareOf_ (this),
    Floor_ (this),
    UnitNumber_ (this),
    StreetDirectionPrefix_ (this),
    StreetNumber_ (this),
    StreetName_ (this),
    StreetType_ (this),
    StreetDirectionSuffix_ (this),
    City_ (this),
    ProvinceState_ (this),
    Country_ (this),
    PostalZip_ (this),
    FreeformAddress_ (this),
    Compartment_ (this),
    DeliveryInstallationType_ (this),
    DeliveryInstallationTypeValue_ (this),
    ModeOfDelivery_ (this),
    ModeOfDeliveryValue_ (this),
    Site_ (this),
    BulkMailCode_ (this)
  {
  }

  MailingAddress::
  MailingAddress (const MailingAddress& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Attention_ (x.Attention_, f, this),
    CareOf_ (x.CareOf_, f, this),
    Floor_ (x.Floor_, f, this),
    UnitNumber_ (x.UnitNumber_, f, this),
    StreetDirectionPrefix_ (x.StreetDirectionPrefix_, f, this),
    StreetNumber_ (x.StreetNumber_, f, this),
    StreetName_ (x.StreetName_, f, this),
    StreetType_ (x.StreetType_, f, this),
    StreetDirectionSuffix_ (x.StreetDirectionSuffix_, f, this),
    City_ (x.City_, f, this),
    ProvinceState_ (x.ProvinceState_, f, this),
    Country_ (x.Country_, f, this),
    PostalZip_ (x.PostalZip_, f, this),
    FreeformAddress_ (x.FreeformAddress_, f, this),
    Compartment_ (x.Compartment_, f, this),
    DeliveryInstallationType_ (x.DeliveryInstallationType_, f, this),
    DeliveryInstallationTypeValue_ (x.DeliveryInstallationTypeValue_, f, this),
    ModeOfDelivery_ (x.ModeOfDelivery_, f, this),
    ModeOfDeliveryValue_ (x.ModeOfDeliveryValue_, f, this),
    Site_ (x.Site_, f, this),
    BulkMailCode_ (x.BulkMailCode_, f, this)
  {
  }

  MailingAddress::
  MailingAddress (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Attention_ (this),
    CareOf_ (this),
    Floor_ (this),
    UnitNumber_ (this),
    StreetDirectionPrefix_ (this),
    StreetNumber_ (this),
    StreetName_ (this),
    StreetType_ (this),
    StreetDirectionSuffix_ (this),
    City_ (this),
    ProvinceState_ (this),
    Country_ (this),
    PostalZip_ (this),
    FreeformAddress_ (this),
    Compartment_ (this),
    DeliveryInstallationType_ (this),
    DeliveryInstallationTypeValue_ (this),
    ModeOfDelivery_ (this),
    ModeOfDeliveryValue_ (this),
    Site_ (this),
    BulkMailCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MailingAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Attention
      //
      if (n.name () == "Attention" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Attention_type > r (
          Attention_traits::create (i, f, this));

        if (!this->Attention_)
        {
          this->Attention_.set (::std::move (r));
          continue;
        }
      }

      // CareOf
      //
      if (n.name () == "CareOf" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< CareOf_type > r (
          CareOf_traits::create (i, f, this));

        if (!this->CareOf_)
        {
          this->CareOf_.set (::std::move (r));
          continue;
        }
      }

      // Floor
      //
      if (n.name () == "Floor" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Floor_type > r (
          Floor_traits::create (i, f, this));

        if (!this->Floor_)
        {
          this->Floor_.set (::std::move (r));
          continue;
        }
      }

      // UnitNumber
      //
      if (n.name () == "UnitNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< UnitNumber_type > r (
          UnitNumber_traits::create (i, f, this));

        if (!this->UnitNumber_)
        {
          this->UnitNumber_.set (::std::move (r));
          continue;
        }
      }

      // StreetDirectionPrefix
      //
      if (n.name () == "StreetDirectionPrefix" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetDirectionPrefix_type > r (
          StreetDirectionPrefix_traits::create (i, f, this));

        if (!this->StreetDirectionPrefix_)
        {
          this->StreetDirectionPrefix_.set (::std::move (r));
          continue;
        }
      }

      // StreetNumber
      //
      if (n.name () == "StreetNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetNumber_type > r (
          StreetNumber_traits::create (i, f, this));

        if (!this->StreetNumber_)
        {
          this->StreetNumber_.set (::std::move (r));
          continue;
        }
      }

      // StreetName
      //
      if (n.name () == "StreetName" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetName_type > r (
          StreetName_traits::create (i, f, this));

        if (!this->StreetName_)
        {
          this->StreetName_.set (::std::move (r));
          continue;
        }
      }

      // StreetType
      //
      if (n.name () == "StreetType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetType_type > r (
          StreetType_traits::create (i, f, this));

        if (!this->StreetType_)
        {
          this->StreetType_.set (::std::move (r));
          continue;
        }
      }

      // StreetDirectionSuffix
      //
      if (n.name () == "StreetDirectionSuffix" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StreetDirectionSuffix_type > r (
          StreetDirectionSuffix_traits::create (i, f, this));

        if (!this->StreetDirectionSuffix_)
        {
          this->StreetDirectionSuffix_.set (::std::move (r));
          continue;
        }
      }

      // City
      //
      if (n.name () == "City" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< City_type > r (
          City_traits::create (i, f, this));

        if (!this->City_)
        {
          this->City_.set (::std::move (r));
          continue;
        }
      }

      // ProvinceState
      //
      if (n.name () == "ProvinceState" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ProvinceState_type > r (
          ProvinceState_traits::create (i, f, this));

        if (!this->ProvinceState_)
        {
          this->ProvinceState_.set (::std::move (r));
          continue;
        }
      }

      // Country
      //
      if (n.name () == "Country" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Country_type > r (
          Country_traits::create (i, f, this));

        if (!this->Country_)
        {
          this->Country_.set (::std::move (r));
          continue;
        }
      }

      // PostalZip
      //
      if (n.name () == "PostalZip" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PostalZip_type > r (
          PostalZip_traits::create (i, f, this));

        if (!this->PostalZip_)
        {
          this->PostalZip_.set (::std::move (r));
          continue;
        }
      }

      // FreeformAddress
      //
      if (n.name () == "FreeformAddress" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FreeformAddress_type > r (
          FreeformAddress_traits::create (i, f, this));

        if (!this->FreeformAddress_)
        {
          this->FreeformAddress_.set (::std::move (r));
          continue;
        }
      }

      // Compartment
      //
      if (n.name () == "Compartment" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Compartment_type > r (
          Compartment_traits::create (i, f, this));

        if (!this->Compartment_)
        {
          this->Compartment_.set (::std::move (r));
          continue;
        }
      }

      // DeliveryInstallationType
      //
      if (n.name () == "DeliveryInstallationType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeliveryInstallationType_type > r (
          DeliveryInstallationType_traits::create (i, f, this));

        if (!this->DeliveryInstallationType_)
        {
          this->DeliveryInstallationType_.set (::std::move (r));
          continue;
        }
      }

      // DeliveryInstallationTypeValue
      //
      if (n.name () == "DeliveryInstallationTypeValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DeliveryInstallationTypeValue_type > r (
          DeliveryInstallationTypeValue_traits::create (i, f, this));

        if (!this->DeliveryInstallationTypeValue_)
        {
          this->DeliveryInstallationTypeValue_.set (::std::move (r));
          continue;
        }
      }

      // ModeOfDelivery
      //
      if (n.name () == "ModeOfDelivery" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ModeOfDelivery_type > r (
          ModeOfDelivery_traits::create (i, f, this));

        if (!this->ModeOfDelivery_)
        {
          this->ModeOfDelivery_.set (::std::move (r));
          continue;
        }
      }

      // ModeOfDeliveryValue
      //
      if (n.name () == "ModeOfDeliveryValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ModeOfDeliveryValue_type > r (
          ModeOfDeliveryValue_traits::create (i, f, this));

        if (!this->ModeOfDeliveryValue_)
        {
          this->ModeOfDeliveryValue_.set (::std::move (r));
          continue;
        }
      }

      // Site
      //
      if (n.name () == "Site" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Site_type > r (
          Site_traits::create (i, f, this));

        if (!this->Site_)
        {
          this->Site_.set (::std::move (r));
          continue;
        }
      }

      // BulkMailCode
      //
      if (n.name () == "BulkMailCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< BulkMailCode_type > r (
          BulkMailCode_traits::create (i, f, this));

        if (!this->BulkMailCode_)
        {
          this->BulkMailCode_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MailingAddress* MailingAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MailingAddress (*this, f, c);
  }

  MailingAddress& MailingAddress::
  operator= (const MailingAddress& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Attention_ = x.Attention_;
      this->CareOf_ = x.CareOf_;
      this->Floor_ = x.Floor_;
      this->UnitNumber_ = x.UnitNumber_;
      this->StreetDirectionPrefix_ = x.StreetDirectionPrefix_;
      this->StreetNumber_ = x.StreetNumber_;
      this->StreetName_ = x.StreetName_;
      this->StreetType_ = x.StreetType_;
      this->StreetDirectionSuffix_ = x.StreetDirectionSuffix_;
      this->City_ = x.City_;
      this->ProvinceState_ = x.ProvinceState_;
      this->Country_ = x.Country_;
      this->PostalZip_ = x.PostalZip_;
      this->FreeformAddress_ = x.FreeformAddress_;
      this->Compartment_ = x.Compartment_;
      this->DeliveryInstallationType_ = x.DeliveryInstallationType_;
      this->DeliveryInstallationTypeValue_ = x.DeliveryInstallationTypeValue_;
      this->ModeOfDelivery_ = x.ModeOfDelivery_;
      this->ModeOfDeliveryValue_ = x.ModeOfDeliveryValue_;
      this->Site_ = x.Site_;
      this->BulkMailCode_ = x.BulkMailCode_;
    }

    return *this;
  }

  MailingAddress::
  ~MailingAddress ()
  {
  }

  // FormattedMailingAddress
  //

  FormattedMailingAddress::
  FormattedMailingAddress ()
  : ::dataadvice::FolioItemGroup (),
    Line1_ (this),
    Line2_ (this),
    Line3_ (this),
    Line4_ (this),
    Line5_ (this),
    Line6_ (this)
  {
  }

  FormattedMailingAddress::
  FormattedMailingAddress (const FormattedMailingAddress& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Line1_ (x.Line1_, f, this),
    Line2_ (x.Line2_, f, this),
    Line3_ (x.Line3_, f, this),
    Line4_ (x.Line4_, f, this),
    Line5_ (x.Line5_, f, this),
    Line6_ (x.Line6_, f, this)
  {
  }

  FormattedMailingAddress::
  FormattedMailingAddress (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Line1_ (this),
    Line2_ (this),
    Line3_ (this),
    Line4_ (this),
    Line5_ (this),
    Line6_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FormattedMailingAddress::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Line1
      //
      if (n.name () == "Line1" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Line1_type > r (
          Line1_traits::create (i, f, this));

        if (!this->Line1_)
        {
          this->Line1_.set (::std::move (r));
          continue;
        }
      }

      // Line2
      //
      if (n.name () == "Line2" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Line2_type > r (
          Line2_traits::create (i, f, this));

        if (!this->Line2_)
        {
          this->Line2_.set (::std::move (r));
          continue;
        }
      }

      // Line3
      //
      if (n.name () == "Line3" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Line3_type > r (
          Line3_traits::create (i, f, this));

        if (!this->Line3_)
        {
          this->Line3_.set (::std::move (r));
          continue;
        }
      }

      // Line4
      //
      if (n.name () == "Line4" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Line4_type > r (
          Line4_traits::create (i, f, this));

        if (!this->Line4_)
        {
          this->Line4_.set (::std::move (r));
          continue;
        }
      }

      // Line5
      //
      if (n.name () == "Line5" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Line5_type > r (
          Line5_traits::create (i, f, this));

        if (!this->Line5_)
        {
          this->Line5_.set (::std::move (r));
          continue;
        }
      }

      // Line6
      //
      if (n.name () == "Line6" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Line6_type > r (
          Line6_traits::create (i, f, this));

        if (!this->Line6_)
        {
          this->Line6_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FormattedMailingAddress* FormattedMailingAddress::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FormattedMailingAddress (*this, f, c);
  }

  FormattedMailingAddress& FormattedMailingAddress::
  operator= (const FormattedMailingAddress& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Line1_ = x.Line1_;
      this->Line2_ = x.Line2_;
      this->Line3_ = x.Line3_;
      this->Line4_ = x.Line4_;
      this->Line5_ = x.Line5_;
      this->Line6_ = x.Line6_;
    }

    return *this;
  }

  FormattedMailingAddress::
  ~FormattedMailingAddress ()
  {
  }

  // String40
  //

  String40::
  String40 ()
  : ::xml_schema::string ()
  {
  }

  String40::
  String40 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String40::
  String40 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String40::
  String40 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String40::
  String40 (const String40& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  String40::
  String40 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  String40::
  String40 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  String40::
  String40 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  String40* String40::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String40 (*this, f, c);
  }

  String40::
  ~String40 ()
  {
  }

  // FormattedMailingAddressLine
  //

  FormattedMailingAddressLine::
  FormattedMailingAddressLine ()
  : ::dataadvice::String40 (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FormattedMailingAddressLine::
  FormattedMailingAddressLine (const char* _xsd_string_base)
  : ::dataadvice::String40 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FormattedMailingAddressLine::
  FormattedMailingAddressLine (const ::std::string& _xsd_string_base)
  : ::dataadvice::String40 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FormattedMailingAddressLine::
  FormattedMailingAddressLine (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::String40 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FormattedMailingAddressLine::
  FormattedMailingAddressLine (const FormattedMailingAddressLine& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::dataadvice::String40 (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FormattedMailingAddressLine::
  FormattedMailingAddressLine (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
  : ::dataadvice::String40 (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FormattedMailingAddressLine::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FormattedMailingAddressLine* FormattedMailingAddressLine::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FormattedMailingAddressLine (*this, f, c);
  }

  FormattedMailingAddressLine& FormattedMailingAddressLine::
  operator= (const FormattedMailingAddressLine& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::String40& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FormattedMailingAddressLine::
  ~FormattedMailingAddressLine ()
  {
  }

  // LegalDescriptionCollection
  //

  LegalDescriptionCollection::
  LegalDescriptionCollection ()
  : ::dataadvice::FolioItemGroup (),
    LegalDescription_ (this)
  {
  }

  LegalDescriptionCollection::
  LegalDescriptionCollection (const LegalDescriptionCollection& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    LegalDescription_ (x.LegalDescription_, f, this)
  {
  }

  LegalDescriptionCollection::
  LegalDescriptionCollection (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    LegalDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LegalDescriptionCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LegalDescription
      //
      if (n.name () == "LegalDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LegalDescription_type > r (
          LegalDescription_traits::create (i, f, this));

        this->LegalDescription_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LegalDescriptionCollection* LegalDescriptionCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LegalDescriptionCollection (*this, f, c);
  }

  LegalDescriptionCollection& LegalDescriptionCollection::
  operator= (const LegalDescriptionCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->LegalDescription_ = x.LegalDescription_;
    }

    return *this;
  }

  LegalDescriptionCollection::
  ~LegalDescriptionCollection ()
  {
  }

  // LegalDescription
  //

  LegalDescription::
  LegalDescription ()
  : ::dataadvice::FolioItemGroup (),
    FormattedLegalDescription_ (this),
    PID_ (this),
    Lot_ (this),
    StrataLot_ (this),
    Parcel_ (this),
    Block_ (this),
    SubBlock_ (this),
    Plan_ (this),
    SubLot_ (this),
    Part1_ (this),
    Part2_ (this),
    Part3_ (this),
    Part4_ (this),
    DistrictLot_ (this),
    LegalSubdivision_ (this),
    Section_ (this),
    Township_ (this),
    Range_ (this),
    Meridian_ (this),
    MeridianShort_ (this),
    BCAGroup_ (this),
    LandDistrict_ (this),
    LandDistrictDescription_ (this),
    Portion_ (this),
    ExceptPlan_ (this),
    FirstNationReserveNumber_ (this),
    FirstNationReserveDescription_ (this),
    LeaseLicenceNumber_ (this),
    LandBranchFileNumber_ (this),
    AirSpaceParcelNumber_ (this),
    LegalText_ (this)
  {
  }

  LegalDescription::
  LegalDescription (const LegalDescription& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    FormattedLegalDescription_ (x.FormattedLegalDescription_, f, this),
    PID_ (x.PID_, f, this),
    Lot_ (x.Lot_, f, this),
    StrataLot_ (x.StrataLot_, f, this),
    Parcel_ (x.Parcel_, f, this),
    Block_ (x.Block_, f, this),
    SubBlock_ (x.SubBlock_, f, this),
    Plan_ (x.Plan_, f, this),
    SubLot_ (x.SubLot_, f, this),
    Part1_ (x.Part1_, f, this),
    Part2_ (x.Part2_, f, this),
    Part3_ (x.Part3_, f, this),
    Part4_ (x.Part4_, f, this),
    DistrictLot_ (x.DistrictLot_, f, this),
    LegalSubdivision_ (x.LegalSubdivision_, f, this),
    Section_ (x.Section_, f, this),
    Township_ (x.Township_, f, this),
    Range_ (x.Range_, f, this),
    Meridian_ (x.Meridian_, f, this),
    MeridianShort_ (x.MeridianShort_, f, this),
    BCAGroup_ (x.BCAGroup_, f, this),
    LandDistrict_ (x.LandDistrict_, f, this),
    LandDistrictDescription_ (x.LandDistrictDescription_, f, this),
    Portion_ (x.Portion_, f, this),
    ExceptPlan_ (x.ExceptPlan_, f, this),
    FirstNationReserveNumber_ (x.FirstNationReserveNumber_, f, this),
    FirstNationReserveDescription_ (x.FirstNationReserveDescription_, f, this),
    LeaseLicenceNumber_ (x.LeaseLicenceNumber_, f, this),
    LandBranchFileNumber_ (x.LandBranchFileNumber_, f, this),
    AirSpaceParcelNumber_ (x.AirSpaceParcelNumber_, f, this),
    LegalText_ (x.LegalText_, f, this)
  {
  }

  LegalDescription::
  LegalDescription (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    FormattedLegalDescription_ (this),
    PID_ (this),
    Lot_ (this),
    StrataLot_ (this),
    Parcel_ (this),
    Block_ (this),
    SubBlock_ (this),
    Plan_ (this),
    SubLot_ (this),
    Part1_ (this),
    Part2_ (this),
    Part3_ (this),
    Part4_ (this),
    DistrictLot_ (this),
    LegalSubdivision_ (this),
    Section_ (this),
    Township_ (this),
    Range_ (this),
    Meridian_ (this),
    MeridianShort_ (this),
    BCAGroup_ (this),
    LandDistrict_ (this),
    LandDistrictDescription_ (this),
    Portion_ (this),
    ExceptPlan_ (this),
    FirstNationReserveNumber_ (this),
    FirstNationReserveDescription_ (this),
    LeaseLicenceNumber_ (this),
    LandBranchFileNumber_ (this),
    AirSpaceParcelNumber_ (this),
    LegalText_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LegalDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FormattedLegalDescription
      //
      if (n.name () == "FormattedLegalDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FormattedLegalDescription_type > r (
          FormattedLegalDescription_traits::create (i, f, this));

        if (!this->FormattedLegalDescription_)
        {
          this->FormattedLegalDescription_.set (::std::move (r));
          continue;
        }
      }

      // PID
      //
      if (n.name () == "PID" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PID_type > r (
          PID_traits::create (i, f, this));

        if (!this->PID_)
        {
          this->PID_.set (::std::move (r));
          continue;
        }
      }

      // Lot
      //
      if (n.name () == "Lot" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Lot_type > r (
          Lot_traits::create (i, f, this));

        if (!this->Lot_)
        {
          this->Lot_.set (::std::move (r));
          continue;
        }
      }

      // StrataLot
      //
      if (n.name () == "StrataLot" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< StrataLot_type > r (
          StrataLot_traits::create (i, f, this));

        if (!this->StrataLot_)
        {
          this->StrataLot_.set (::std::move (r));
          continue;
        }
      }

      // Parcel
      //
      if (n.name () == "Parcel" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Parcel_type > r (
          Parcel_traits::create (i, f, this));

        if (!this->Parcel_)
        {
          this->Parcel_.set (::std::move (r));
          continue;
        }
      }

      // Block
      //
      if (n.name () == "Block" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Block_type > r (
          Block_traits::create (i, f, this));

        if (!this->Block_)
        {
          this->Block_.set (::std::move (r));
          continue;
        }
      }

      // SubBlock
      //
      if (n.name () == "SubBlock" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SubBlock_type > r (
          SubBlock_traits::create (i, f, this));

        if (!this->SubBlock_)
        {
          this->SubBlock_.set (::std::move (r));
          continue;
        }
      }

      // Plan
      //
      if (n.name () == "Plan" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Plan_type > r (
          Plan_traits::create (i, f, this));

        if (!this->Plan_)
        {
          this->Plan_.set (::std::move (r));
          continue;
        }
      }

      // SubLot
      //
      if (n.name () == "SubLot" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SubLot_type > r (
          SubLot_traits::create (i, f, this));

        if (!this->SubLot_)
        {
          this->SubLot_.set (::std::move (r));
          continue;
        }
      }

      // Part1
      //
      if (n.name () == "Part1" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Part1_type > r (
          Part1_traits::create (i, f, this));

        if (!this->Part1_)
        {
          this->Part1_.set (::std::move (r));
          continue;
        }
      }

      // Part2
      //
      if (n.name () == "Part2" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Part2_type > r (
          Part2_traits::create (i, f, this));

        if (!this->Part2_)
        {
          this->Part2_.set (::std::move (r));
          continue;
        }
      }

      // Part3
      //
      if (n.name () == "Part3" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Part3_type > r (
          Part3_traits::create (i, f, this));

        if (!this->Part3_)
        {
          this->Part3_.set (::std::move (r));
          continue;
        }
      }

      // Part4
      //
      if (n.name () == "Part4" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Part4_type > r (
          Part4_traits::create (i, f, this));

        if (!this->Part4_)
        {
          this->Part4_.set (::std::move (r));
          continue;
        }
      }

      // DistrictLot
      //
      if (n.name () == "DistrictLot" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DistrictLot_type > r (
          DistrictLot_traits::create (i, f, this));

        if (!this->DistrictLot_)
        {
          this->DistrictLot_.set (::std::move (r));
          continue;
        }
      }

      // LegalSubdivision
      //
      if (n.name () == "LegalSubdivision" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LegalSubdivision_type > r (
          LegalSubdivision_traits::create (i, f, this));

        if (!this->LegalSubdivision_)
        {
          this->LegalSubdivision_.set (::std::move (r));
          continue;
        }
      }

      // Section
      //
      if (n.name () == "Section" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Section_type > r (
          Section_traits::create (i, f, this));

        if (!this->Section_)
        {
          this->Section_.set (::std::move (r));
          continue;
        }
      }

      // Township
      //
      if (n.name () == "Township" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Township_type > r (
          Township_traits::create (i, f, this));

        if (!this->Township_)
        {
          this->Township_.set (::std::move (r));
          continue;
        }
      }

      // Range
      //
      if (n.name () == "Range" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Range_type > r (
          Range_traits::create (i, f, this));

        if (!this->Range_)
        {
          this->Range_.set (::std::move (r));
          continue;
        }
      }

      // Meridian
      //
      if (n.name () == "Meridian" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Meridian_type > r (
          Meridian_traits::create (i, f, this));

        if (!this->Meridian_)
        {
          this->Meridian_.set (::std::move (r));
          continue;
        }
      }

      // MeridianShort
      //
      if (n.name () == "MeridianShort" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MeridianShort_type > r (
          MeridianShort_traits::create (i, f, this));

        if (!this->MeridianShort_)
        {
          this->MeridianShort_.set (::std::move (r));
          continue;
        }
      }

      // BCAGroup
      //
      if (n.name () == "BCAGroup" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< BCAGroup_type > r (
          BCAGroup_traits::create (i, f, this));

        if (!this->BCAGroup_)
        {
          this->BCAGroup_.set (::std::move (r));
          continue;
        }
      }

      // LandDistrict
      //
      if (n.name () == "LandDistrict" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandDistrict_type > r (
          LandDistrict_traits::create (i, f, this));

        if (!this->LandDistrict_)
        {
          this->LandDistrict_.set (::std::move (r));
          continue;
        }
      }

      // LandDistrictDescription
      //
      if (n.name () == "LandDistrictDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandDistrictDescription_type > r (
          LandDistrictDescription_traits::create (i, f, this));

        if (!this->LandDistrictDescription_)
        {
          this->LandDistrictDescription_.set (::std::move (r));
          continue;
        }
      }

      // Portion
      //
      if (n.name () == "Portion" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Portion_type > r (
          Portion_traits::create (i, f, this));

        if (!this->Portion_)
        {
          this->Portion_.set (::std::move (r));
          continue;
        }
      }

      // ExceptPlan
      //
      if (n.name () == "ExceptPlan" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ExceptPlan_type > r (
          ExceptPlan_traits::create (i, f, this));

        if (!this->ExceptPlan_)
        {
          this->ExceptPlan_.set (::std::move (r));
          continue;
        }
      }

      // FirstNationReserveNumber
      //
      if (n.name () == "FirstNationReserveNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FirstNationReserveNumber_type > r (
          FirstNationReserveNumber_traits::create (i, f, this));

        if (!this->FirstNationReserveNumber_)
        {
          this->FirstNationReserveNumber_.set (::std::move (r));
          continue;
        }
      }

      // FirstNationReserveDescription
      //
      if (n.name () == "FirstNationReserveDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FirstNationReserveDescription_type > r (
          FirstNationReserveDescription_traits::create (i, f, this));

        if (!this->FirstNationReserveDescription_)
        {
          this->FirstNationReserveDescription_.set (::std::move (r));
          continue;
        }
      }

      // LeaseLicenceNumber
      //
      if (n.name () == "LeaseLicenceNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LeaseLicenceNumber_type > r (
          LeaseLicenceNumber_traits::create (i, f, this));

        if (!this->LeaseLicenceNumber_)
        {
          this->LeaseLicenceNumber_.set (::std::move (r));
          continue;
        }
      }

      // LandBranchFileNumber
      //
      if (n.name () == "LandBranchFileNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandBranchFileNumber_type > r (
          LandBranchFileNumber_traits::create (i, f, this));

        if (!this->LandBranchFileNumber_)
        {
          this->LandBranchFileNumber_.set (::std::move (r));
          continue;
        }
      }

      // AirSpaceParcelNumber
      //
      if (n.name () == "AirSpaceParcelNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AirSpaceParcelNumber_type > r (
          AirSpaceParcelNumber_traits::create (i, f, this));

        if (!this->AirSpaceParcelNumber_)
        {
          this->AirSpaceParcelNumber_.set (::std::move (r));
          continue;
        }
      }

      // LegalText
      //
      if (n.name () == "LegalText" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LegalText_type > r (
          LegalText_traits::create (i, f, this));

        if (!this->LegalText_)
        {
          this->LegalText_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LegalDescription* LegalDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LegalDescription (*this, f, c);
  }

  LegalDescription& LegalDescription::
  operator= (const LegalDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->FormattedLegalDescription_ = x.FormattedLegalDescription_;
      this->PID_ = x.PID_;
      this->Lot_ = x.Lot_;
      this->StrataLot_ = x.StrataLot_;
      this->Parcel_ = x.Parcel_;
      this->Block_ = x.Block_;
      this->SubBlock_ = x.SubBlock_;
      this->Plan_ = x.Plan_;
      this->SubLot_ = x.SubLot_;
      this->Part1_ = x.Part1_;
      this->Part2_ = x.Part2_;
      this->Part3_ = x.Part3_;
      this->Part4_ = x.Part4_;
      this->DistrictLot_ = x.DistrictLot_;
      this->LegalSubdivision_ = x.LegalSubdivision_;
      this->Section_ = x.Section_;
      this->Township_ = x.Township_;
      this->Range_ = x.Range_;
      this->Meridian_ = x.Meridian_;
      this->MeridianShort_ = x.MeridianShort_;
      this->BCAGroup_ = x.BCAGroup_;
      this->LandDistrict_ = x.LandDistrict_;
      this->LandDistrictDescription_ = x.LandDistrictDescription_;
      this->Portion_ = x.Portion_;
      this->ExceptPlan_ = x.ExceptPlan_;
      this->FirstNationReserveNumber_ = x.FirstNationReserveNumber_;
      this->FirstNationReserveDescription_ = x.FirstNationReserveDescription_;
      this->LeaseLicenceNumber_ = x.LeaseLicenceNumber_;
      this->LandBranchFileNumber_ = x.LandBranchFileNumber_;
      this->AirSpaceParcelNumber_ = x.AirSpaceParcelNumber_;
      this->LegalText_ = x.LegalText_;
    }

    return *this;
  }

  LegalDescription::
  ~LegalDescription ()
  {
  }

  // LandCharacteristic
  //

  LandCharacteristic::
  LandCharacteristic ()
  : ::dataadvice::FolioItemGroup (),
    LandCharacteristicCode_ (this),
    LandCharacteristicDescription_ (this)
  {
  }

  LandCharacteristic::
  LandCharacteristic (const LandCharacteristic& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    LandCharacteristicCode_ (x.LandCharacteristicCode_, f, this),
    LandCharacteristicDescription_ (x.LandCharacteristicDescription_, f, this)
  {
  }

  LandCharacteristic::
  LandCharacteristic (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    LandCharacteristicCode_ (this),
    LandCharacteristicDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LandCharacteristic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LandCharacteristicCode
      //
      if (n.name () == "LandCharacteristicCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandCharacteristicCode_type > r (
          LandCharacteristicCode_traits::create (i, f, this));

        if (!this->LandCharacteristicCode_)
        {
          this->LandCharacteristicCode_.set (::std::move (r));
          continue;
        }
      }

      // LandCharacteristicDescription
      //
      if (n.name () == "LandCharacteristicDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandCharacteristicDescription_type > r (
          LandCharacteristicDescription_traits::create (i, f, this));

        if (!this->LandCharacteristicDescription_)
        {
          this->LandCharacteristicDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LandCharacteristic* LandCharacteristic::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LandCharacteristic (*this, f, c);
  }

  LandCharacteristic& LandCharacteristic::
  operator= (const LandCharacteristic& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->LandCharacteristicCode_ = x.LandCharacteristicCode_;
      this->LandCharacteristicDescription_ = x.LandCharacteristicDescription_;
    }

    return *this;
  }

  LandCharacteristic::
  ~LandCharacteristic ()
  {
  }

  // LandCharacteristicCollection
  //

  LandCharacteristicCollection::
  LandCharacteristicCollection ()
  : ::dataadvice::FolioItemGroup (),
    LandCharacteristic_ (this)
  {
  }

  LandCharacteristicCollection::
  LandCharacteristicCollection (const LandCharacteristicCollection& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    LandCharacteristic_ (x.LandCharacteristic_, f, this)
  {
  }

  LandCharacteristicCollection::
  LandCharacteristicCollection (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    LandCharacteristic_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LandCharacteristicCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LandCharacteristic
      //
      if (n.name () == "LandCharacteristic" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandCharacteristic_type > r (
          LandCharacteristic_traits::create (i, f, this));

        this->LandCharacteristic_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LandCharacteristicCollection* LandCharacteristicCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LandCharacteristicCollection (*this, f, c);
  }

  LandCharacteristicCollection& LandCharacteristicCollection::
  operator= (const LandCharacteristicCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->LandCharacteristic_ = x.LandCharacteristic_;
    }

    return *this;
  }

  LandCharacteristicCollection::
  ~LandCharacteristicCollection ()
  {
  }

  // ManufacturedHomeCollection
  //

  ManufacturedHomeCollection::
  ManufacturedHomeCollection ()
  : ::dataadvice::FolioItemGroup (),
    ManufacturedHome_ (this)
  {
  }

  ManufacturedHomeCollection::
  ManufacturedHomeCollection (const ManufacturedHomeCollection& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    ManufacturedHome_ (x.ManufacturedHome_, f, this)
  {
  }

  ManufacturedHomeCollection::
  ManufacturedHomeCollection (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    ManufacturedHome_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ManufacturedHomeCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ManufacturedHome
      //
      if (n.name () == "ManufacturedHome" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManufacturedHome_type > r (
          ManufacturedHome_traits::create (i, f, this));

        this->ManufacturedHome_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ManufacturedHomeCollection* ManufacturedHomeCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ManufacturedHomeCollection (*this, f, c);
  }

  ManufacturedHomeCollection& ManufacturedHomeCollection::
  operator= (const ManufacturedHomeCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->ManufacturedHome_ = x.ManufacturedHome_;
    }

    return *this;
  }

  ManufacturedHomeCollection::
  ~ManufacturedHomeCollection ()
  {
  }

  // ManufacturedHome
  //

  ManufacturedHome::
  ManufacturedHome ()
  : ::dataadvice::FolioItemGroup (),
    MHRegistryNumber_ (this),
    MHBayNumber_ (this),
    MHPark_ (this),
    MHParkRollNumber_ (this)
  {
  }

  ManufacturedHome::
  ManufacturedHome (const ManufacturedHome& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    MHRegistryNumber_ (x.MHRegistryNumber_, f, this),
    MHBayNumber_ (x.MHBayNumber_, f, this),
    MHPark_ (x.MHPark_, f, this),
    MHParkRollNumber_ (x.MHParkRollNumber_, f, this)
  {
  }

  ManufacturedHome::
  ManufacturedHome (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    MHRegistryNumber_ (this),
    MHBayNumber_ (this),
    MHPark_ (this),
    MHParkRollNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ManufacturedHome::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MHRegistryNumber
      //
      if (n.name () == "MHRegistryNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MHRegistryNumber_type > r (
          MHRegistryNumber_traits::create (i, f, this));

        if (!this->MHRegistryNumber_)
        {
          this->MHRegistryNumber_.set (::std::move (r));
          continue;
        }
      }

      // MHBayNumber
      //
      if (n.name () == "MHBayNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MHBayNumber_type > r (
          MHBayNumber_traits::create (i, f, this));

        if (!this->MHBayNumber_)
        {
          this->MHBayNumber_.set (::std::move (r));
          continue;
        }
      }

      // MHPark
      //
      if (n.name () == "MHPark" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MHPark_type > r (
          MHPark_traits::create (i, f, this));

        if (!this->MHPark_)
        {
          this->MHPark_.set (::std::move (r));
          continue;
        }
      }

      // MHParkRollNumber
      //
      if (n.name () == "MHParkRollNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MHParkRollNumber_type > r (
          MHParkRollNumber_traits::create (i, f, this));

        if (!this->MHParkRollNumber_)
        {
          this->MHParkRollNumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ManufacturedHome* ManufacturedHome::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ManufacturedHome (*this, f, c);
  }

  ManufacturedHome& ManufacturedHome::
  operator= (const ManufacturedHome& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->MHRegistryNumber_ = x.MHRegistryNumber_;
      this->MHBayNumber_ = x.MHBayNumber_;
      this->MHPark_ = x.MHPark_;
      this->MHParkRollNumber_ = x.MHParkRollNumber_;
    }

    return *this;
  }

  ManufacturedHome::
  ~ManufacturedHome ()
  {
  }

  // FarmCollection
  //

  FarmCollection::
  FarmCollection ()
  : ::dataadvice::FolioItemGroup (),
    Farm_ (this)
  {
  }

  FarmCollection::
  FarmCollection (const FarmCollection& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Farm_ (x.Farm_, f, this)
  {
  }

  FarmCollection::
  FarmCollection (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Farm_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FarmCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Farm
      //
      if (n.name () == "Farm" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Farm_type > r (
          Farm_traits::create (i, f, this));

        this->Farm_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FarmCollection* FarmCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FarmCollection (*this, f, c);
  }

  FarmCollection& FarmCollection::
  operator= (const FarmCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Farm_ = x.Farm_;
    }

    return *this;
  }

  FarmCollection::
  ~FarmCollection ()
  {
  }

  // Farm
  //

  Farm::
  Farm ()
  : ::dataadvice::FolioItemGroup (),
    FarmNumber_ (this)
  {
  }

  Farm::
  Farm (const Farm& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    FarmNumber_ (x.FarmNumber_, f, this)
  {
  }

  Farm::
  Farm (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    FarmNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Farm::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // FarmNumber
      //
      if (n.name () == "FarmNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< FarmNumber_type > r (
          FarmNumber_traits::create (i, f, this));

        this->FarmNumber_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Farm* Farm::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Farm (*this, f, c);
  }

  Farm& Farm::
  operator= (const Farm& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->FarmNumber_ = x.FarmNumber_;
    }

    return *this;
  }

  Farm::
  ~Farm ()
  {
  }

  // OilAndGasCollection
  //

  OilAndGasCollection::
  OilAndGasCollection ()
  : ::dataadvice::FolioItemGroup (),
    OilAndGas_ (this)
  {
  }

  OilAndGasCollection::
  OilAndGasCollection (const OilAndGasCollection& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    OilAndGas_ (x.OilAndGas_, f, this)
  {
  }

  OilAndGasCollection::
  OilAndGasCollection (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    OilAndGas_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OilAndGasCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // OilAndGas
      //
      if (n.name () == "OilAndGas" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< OilAndGas_type > r (
          OilAndGas_traits::create (i, f, this));

        this->OilAndGas_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  OilAndGasCollection* OilAndGasCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OilAndGasCollection (*this, f, c);
  }

  OilAndGasCollection& OilAndGasCollection::
  operator= (const OilAndGasCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->OilAndGas_ = x.OilAndGas_;
    }

    return *this;
  }

  OilAndGasCollection::
  ~OilAndGasCollection ()
  {
  }

  // OilAndGas
  //

  OilAndGas::
  OilAndGas ()
  : ::dataadvice::FolioItemGroup (),
    PipelineProjectNumber_ (this)
  {
  }

  OilAndGas::
  OilAndGas (const OilAndGas& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    PipelineProjectNumber_ (x.PipelineProjectNumber_, f, this)
  {
  }

  OilAndGas::
  OilAndGas (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    PipelineProjectNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void OilAndGas::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PipelineProjectNumber
      //
      if (n.name () == "PipelineProjectNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PipelineProjectNumber_type > r (
          PipelineProjectNumber_traits::create (i, f, this));

        if (!this->PipelineProjectNumber_)
        {
          this->PipelineProjectNumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  OilAndGas* OilAndGas::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class OilAndGas (*this, f, c);
  }

  OilAndGas& OilAndGas::
  operator= (const OilAndGas& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->PipelineProjectNumber_ = x.PipelineProjectNumber_;
    }

    return *this;
  }

  OilAndGas::
  ~OilAndGas ()
  {
  }

  // ManagedForestCollection
  //

  ManagedForestCollection::
  ManagedForestCollection ()
  : ::dataadvice::FolioItemGroup (),
    ManagedForest_ (this)
  {
  }

  ManagedForestCollection::
  ManagedForestCollection (const ManagedForestCollection& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    ManagedForest_ (x.ManagedForest_, f, this)
  {
  }

  ManagedForestCollection::
  ManagedForestCollection (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    ManagedForest_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ManagedForestCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ManagedForest
      //
      if (n.name () == "ManagedForest" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManagedForest_type > r (
          ManagedForest_traits::create (i, f, this));

        this->ManagedForest_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ManagedForestCollection* ManagedForestCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ManagedForestCollection (*this, f, c);
  }

  ManagedForestCollection& ManagedForestCollection::
  operator= (const ManagedForestCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->ManagedForest_ = x.ManagedForest_;
    }

    return *this;
  }

  ManagedForestCollection::
  ~ManagedForestCollection ()
  {
  }

  // ManagedForest
  //

  ManagedForest::
  ManagedForest ()
  : ::dataadvice::FolioItemGroup (),
    ManagedForestNumber_ (this)
  {
  }

  ManagedForest::
  ManagedForest (const ManagedForest& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    ManagedForestNumber_ (x.ManagedForestNumber_, f, this)
  {
  }

  ManagedForest::
  ManagedForest (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    ManagedForestNumber_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ManagedForest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ManagedForestNumber
      //
      if (n.name () == "ManagedForestNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManagedForestNumber_type > r (
          ManagedForestNumber_traits::create (i, f, this));

        if (!this->ManagedForestNumber_)
        {
          this->ManagedForestNumber_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ManagedForest* ManagedForest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ManagedForest (*this, f, c);
  }

  ManagedForest& ManagedForest::
  operator= (const ManagedForest& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->ManagedForestNumber_ = x.ManagedForestNumber_;
    }

    return *this;
  }

  ManagedForest::
  ~ManagedForest ()
  {
  }

  // FolioAmendmentCollection
  //

  FolioAmendmentCollection::
  FolioAmendmentCollection ()
  : ::dataadvice::FolioItemGroup (),
    Amendment_ (this)
  {
  }

  FolioAmendmentCollection::
  FolioAmendmentCollection (const FolioAmendmentCollection& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Amendment_ (x.Amendment_, f, this)
  {
  }

  FolioAmendmentCollection::
  FolioAmendmentCollection (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Amendment_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FolioAmendmentCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Amendment
      //
      if (n.name () == "Amendment" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Amendment_type > r (
          Amendment_traits::create (i, f, this));

        this->Amendment_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  FolioAmendmentCollection* FolioAmendmentCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioAmendmentCollection (*this, f, c);
  }

  FolioAmendmentCollection& FolioAmendmentCollection::
  operator= (const FolioAmendmentCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Amendment_ = x.Amendment_;
    }

    return *this;
  }

  FolioAmendmentCollection::
  ~FolioAmendmentCollection ()
  {
  }

  // FolioAmendment
  //

  FolioAmendment::
  FolioAmendment ()
  : ::dataadvice::FolioItemGroup (),
    AmendmentType_ (this),
    AmendmentTypeDescription_ (this),
    AmendmentReasonCode_ (this),
    AmendmentReasonDescription_ (this),
    SuppOccupancyDate_ (this),
    SuppOccupancyCode_ (this)
  {
  }

  FolioAmendment::
  FolioAmendment (const FolioAmendment& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    AmendmentType_ (x.AmendmentType_, f, this),
    AmendmentTypeDescription_ (x.AmendmentTypeDescription_, f, this),
    AmendmentReasonCode_ (x.AmendmentReasonCode_, f, this),
    AmendmentReasonDescription_ (x.AmendmentReasonDescription_, f, this),
    SuppOccupancyDate_ (x.SuppOccupancyDate_, f, this),
    SuppOccupancyCode_ (x.SuppOccupancyCode_, f, this)
  {
  }

  FolioAmendment::
  FolioAmendment (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    AmendmentType_ (this),
    AmendmentTypeDescription_ (this),
    AmendmentReasonCode_ (this),
    AmendmentReasonDescription_ (this),
    SuppOccupancyDate_ (this),
    SuppOccupancyCode_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FolioAmendment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // AmendmentType
      //
      if (n.name () == "AmendmentType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentType_type > r (
          AmendmentType_traits::create (i, f, this));

        if (!this->AmendmentType_)
        {
          this->AmendmentType_.set (::std::move (r));
          continue;
        }
      }

      // AmendmentTypeDescription
      //
      if (n.name () == "AmendmentTypeDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentTypeDescription_type > r (
          AmendmentTypeDescription_traits::create (i, f, this));

        if (!this->AmendmentTypeDescription_)
        {
          this->AmendmentTypeDescription_.set (::std::move (r));
          continue;
        }
      }

      // AmendmentReasonCode
      //
      if (n.name () == "AmendmentReasonCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentReasonCode_type > r (
          AmendmentReasonCode_traits::create (i, f, this));

        if (!this->AmendmentReasonCode_)
        {
          this->AmendmentReasonCode_.set (::std::move (r));
          continue;
        }
      }

      // AmendmentReasonDescription
      //
      if (n.name () == "AmendmentReasonDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< AmendmentReasonDescription_type > r (
          AmendmentReasonDescription_traits::create (i, f, this));

        if (!this->AmendmentReasonDescription_)
        {
          this->AmendmentReasonDescription_.set (::std::move (r));
          continue;
        }
      }

      // SuppOccupancyDate
      //
      if (n.name () == "SuppOccupancyDate" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SuppOccupancyDate_type > r (
          SuppOccupancyDate_traits::create (i, f, this));

        if (!this->SuppOccupancyDate_)
        {
          this->SuppOccupancyDate_.set (::std::move (r));
          continue;
        }
      }

      // SuppOccupancyCode
      //
      if (n.name () == "SuppOccupancyCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SuppOccupancyCode_type > r (
          SuppOccupancyCode_traits::create (i, f, this));

        if (!this->SuppOccupancyCode_)
        {
          this->SuppOccupancyCode_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FolioAmendment* FolioAmendment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioAmendment (*this, f, c);
  }

  FolioAmendment& FolioAmendment::
  operator= (const FolioAmendment& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->AmendmentType_ = x.AmendmentType_;
      this->AmendmentTypeDescription_ = x.AmendmentTypeDescription_;
      this->AmendmentReasonCode_ = x.AmendmentReasonCode_;
      this->AmendmentReasonDescription_ = x.AmendmentReasonDescription_;
      this->SuppOccupancyDate_ = x.SuppOccupancyDate_;
      this->SuppOccupancyCode_ = x.SuppOccupancyCode_;
    }

    return *this;
  }

  FolioAmendment::
  ~FolioAmendment ()
  {
  }

  // SaleCollection
  //

  SaleCollection::
  SaleCollection ()
  : ::dataadvice::FolioItemGroup (),
    Sale_ (this)
  {
  }

  SaleCollection::
  SaleCollection (const SaleCollection& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Sale_ (x.Sale_, f, this)
  {
  }

  SaleCollection::
  SaleCollection (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Sale_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SaleCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Sale
      //
      if (n.name () == "Sale" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Sale_type > r (
          Sale_traits::create (i, f, this));

        this->Sale_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  SaleCollection* SaleCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SaleCollection (*this, f, c);
  }

  SaleCollection& SaleCollection::
  operator= (const SaleCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Sale_ = x.Sale_;
    }

    return *this;
  }

  SaleCollection::
  ~SaleCollection ()
  {
  }

  // Sale
  //

  Sale::
  Sale ()
  : ::dataadvice::FolioItemGroup (),
    DocumentNumber_ (this),
    ConveyanceDate_ (this),
    ConveyancePrice_ (this),
    ConveyanceType_ (this),
    ConveyanceTypeDescription_ (this),
    RejectReasonCode_ (this),
    RejectReasonDescription_ (this)
  {
  }

  Sale::
  Sale (const Sale& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    DocumentNumber_ (x.DocumentNumber_, f, this),
    ConveyanceDate_ (x.ConveyanceDate_, f, this),
    ConveyancePrice_ (x.ConveyancePrice_, f, this),
    ConveyanceType_ (x.ConveyanceType_, f, this),
    ConveyanceTypeDescription_ (x.ConveyanceTypeDescription_, f, this),
    RejectReasonCode_ (x.RejectReasonCode_, f, this),
    RejectReasonDescription_ (x.RejectReasonDescription_, f, this)
  {
  }

  Sale::
  Sale (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    DocumentNumber_ (this),
    ConveyanceDate_ (this),
    ConveyancePrice_ (this),
    ConveyanceType_ (this),
    ConveyanceTypeDescription_ (this),
    RejectReasonCode_ (this),
    RejectReasonDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Sale::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DocumentNumber
      //
      if (n.name () == "DocumentNumber" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DocumentNumber_type > r (
          DocumentNumber_traits::create (i, f, this));

        if (!this->DocumentNumber_)
        {
          this->DocumentNumber_.set (::std::move (r));
          continue;
        }
      }

      // ConveyanceDate
      //
      if (n.name () == "ConveyanceDate" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ConveyanceDate_type > r (
          ConveyanceDate_traits::create (i, f, this));

        if (!this->ConveyanceDate_)
        {
          this->ConveyanceDate_.set (::std::move (r));
          continue;
        }
      }

      // ConveyancePrice
      //
      if (n.name () == "ConveyancePrice" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ConveyancePrice_type > r (
          ConveyancePrice_traits::create (i, f, this));

        if (!this->ConveyancePrice_)
        {
          this->ConveyancePrice_.set (::std::move (r));
          continue;
        }
      }

      // ConveyanceType
      //
      if (n.name () == "ConveyanceType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ConveyanceType_type > r (
          ConveyanceType_traits::create (i, f, this));

        if (!this->ConveyanceType_)
        {
          this->ConveyanceType_.set (::std::move (r));
          continue;
        }
      }

      // ConveyanceTypeDescription
      //
      if (n.name () == "ConveyanceTypeDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ConveyanceTypeDescription_type > r (
          ConveyanceTypeDescription_traits::create (i, f, this));

        if (!this->ConveyanceTypeDescription_)
        {
          this->ConveyanceTypeDescription_.set (::std::move (r));
          continue;
        }
      }

      // RejectReasonCode
      //
      if (n.name () == "RejectReasonCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RejectReasonCode_type > r (
          RejectReasonCode_traits::create (i, f, this));

        if (!this->RejectReasonCode_)
        {
          this->RejectReasonCode_.set (::std::move (r));
          continue;
        }
      }

      // RejectReasonDescription
      //
      if (n.name () == "RejectReasonDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RejectReasonDescription_type > r (
          RejectReasonDescription_traits::create (i, f, this));

        if (!this->RejectReasonDescription_)
        {
          this->RejectReasonDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Sale* Sale::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Sale (*this, f, c);
  }

  Sale& Sale::
  operator= (const Sale& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->DocumentNumber_ = x.DocumentNumber_;
      this->ConveyanceDate_ = x.ConveyanceDate_;
      this->ConveyancePrice_ = x.ConveyancePrice_;
      this->ConveyanceType_ = x.ConveyanceType_;
      this->ConveyanceTypeDescription_ = x.ConveyanceTypeDescription_;
      this->RejectReasonCode_ = x.RejectReasonCode_;
      this->RejectReasonDescription_ = x.RejectReasonDescription_;
    }

    return *this;
  }

  Sale::
  ~Sale ()
  {
  }

  // FolioDescription
  //

  FolioDescription::
  FolioDescription ()
  : ::dataadvice::FolioItemGroup (),
    Neighbourhood_ (this),
    ActualUseCode_ (this),
    ActualUseDescription_ (this),
    VacantFlag_ (this),
    BCTransitFlag_ (this),
    PoliceTaxFlag_ (this),
    ALRCode_ (this),
    ALRDescription_ (this),
    ParkingArea_ (this),
    LandMeasurement_ (this),
    SchoolDistrict_ (this),
    RegionalDistrict_ (this),
    RegionalHospitalDistrict_ (this),
    PredominantManualClass_ (this)
  {
  }

  FolioDescription::
  FolioDescription (const FolioDescription& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    Neighbourhood_ (x.Neighbourhood_, f, this),
    ActualUseCode_ (x.ActualUseCode_, f, this),
    ActualUseDescription_ (x.ActualUseDescription_, f, this),
    VacantFlag_ (x.VacantFlag_, f, this),
    BCTransitFlag_ (x.BCTransitFlag_, f, this),
    PoliceTaxFlag_ (x.PoliceTaxFlag_, f, this),
    ALRCode_ (x.ALRCode_, f, this),
    ALRDescription_ (x.ALRDescription_, f, this),
    ParkingArea_ (x.ParkingArea_, f, this),
    LandMeasurement_ (x.LandMeasurement_, f, this),
    SchoolDistrict_ (x.SchoolDistrict_, f, this),
    RegionalDistrict_ (x.RegionalDistrict_, f, this),
    RegionalHospitalDistrict_ (x.RegionalHospitalDistrict_, f, this),
    PredominantManualClass_ (x.PredominantManualClass_, f, this)
  {
  }

  FolioDescription::
  FolioDescription (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    Neighbourhood_ (this),
    ActualUseCode_ (this),
    ActualUseDescription_ (this),
    VacantFlag_ (this),
    BCTransitFlag_ (this),
    PoliceTaxFlag_ (this),
    ALRCode_ (this),
    ALRDescription_ (this),
    ParkingArea_ (this),
    LandMeasurement_ (this),
    SchoolDistrict_ (this),
    RegionalDistrict_ (this),
    RegionalHospitalDistrict_ (this),
    PredominantManualClass_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FolioDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Neighbourhood
      //
      if (n.name () == "Neighbourhood" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Neighbourhood_type > r (
          Neighbourhood_traits::create (i, f, this));

        if (!this->Neighbourhood_)
        {
          this->Neighbourhood_.set (::std::move (r));
          continue;
        }
      }

      // ActualUseCode
      //
      if (n.name () == "ActualUseCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ActualUseCode_type > r (
          ActualUseCode_traits::create (i, f, this));

        if (!this->ActualUseCode_)
        {
          this->ActualUseCode_.set (::std::move (r));
          continue;
        }
      }

      // ActualUseDescription
      //
      if (n.name () == "ActualUseDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ActualUseDescription_type > r (
          ActualUseDescription_traits::create (i, f, this));

        if (!this->ActualUseDescription_)
        {
          this->ActualUseDescription_.set (::std::move (r));
          continue;
        }
      }

      // VacantFlag
      //
      if (n.name () == "VacantFlag" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< VacantFlag_type > r (
          VacantFlag_traits::create (i, f, this));

        if (!this->VacantFlag_)
        {
          this->VacantFlag_.set (::std::move (r));
          continue;
        }
      }

      // BCTransitFlag
      //
      if (n.name () == "BCTransitFlag" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< BCTransitFlag_type > r (
          BCTransitFlag_traits::create (i, f, this));

        if (!this->BCTransitFlag_)
        {
          this->BCTransitFlag_.set (::std::move (r));
          continue;
        }
      }

      // PoliceTaxFlag
      //
      if (n.name () == "PoliceTaxFlag" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PoliceTaxFlag_type > r (
          PoliceTaxFlag_traits::create (i, f, this));

        if (!this->PoliceTaxFlag_)
        {
          this->PoliceTaxFlag_.set (::std::move (r));
          continue;
        }
      }

      // ALRCode
      //
      if (n.name () == "ALRCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ALRCode_type > r (
          ALRCode_traits::create (i, f, this));

        if (!this->ALRCode_)
        {
          this->ALRCode_.set (::std::move (r));
          continue;
        }
      }

      // ALRDescription
      //
      if (n.name () == "ALRDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ALRDescription_type > r (
          ALRDescription_traits::create (i, f, this));

        if (!this->ALRDescription_)
        {
          this->ALRDescription_.set (::std::move (r));
          continue;
        }
      }

      // ParkingArea
      //
      if (n.name () == "ParkingArea" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ParkingArea_type > r (
          ParkingArea_traits::create (i, f, this));

        if (!this->ParkingArea_)
        {
          this->ParkingArea_.set (::std::move (r));
          continue;
        }
      }

      // LandMeasurement
      //
      if (n.name () == "LandMeasurement" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandMeasurement_type > r (
          LandMeasurement_traits::create (i, f, this));

        if (!this->LandMeasurement_)
        {
          this->LandMeasurement_.set (::std::move (r));
          continue;
        }
      }

      // SchoolDistrict
      //
      if (n.name () == "SchoolDistrict" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SchoolDistrict_type > r (
          SchoolDistrict_traits::create (i, f, this));

        if (!this->SchoolDistrict_)
        {
          this->SchoolDistrict_.set (::std::move (r));
          continue;
        }
      }

      // RegionalDistrict
      //
      if (n.name () == "RegionalDistrict" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RegionalDistrict_type > r (
          RegionalDistrict_traits::create (i, f, this));

        if (!this->RegionalDistrict_)
        {
          this->RegionalDistrict_.set (::std::move (r));
          continue;
        }
      }

      // RegionalHospitalDistrict
      //
      if (n.name () == "RegionalHospitalDistrict" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< RegionalHospitalDistrict_type > r (
          RegionalHospitalDistrict_traits::create (i, f, this));

        if (!this->RegionalHospitalDistrict_)
        {
          this->RegionalHospitalDistrict_.set (::std::move (r));
          continue;
        }
      }

      // PredominantManualClass
      //
      if (n.name () == "PredominantManualClass" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PredominantManualClass_type > r (
          PredominantManualClass_traits::create (i, f, this));

        if (!this->PredominantManualClass_)
        {
          this->PredominantManualClass_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  FolioDescription* FolioDescription::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioDescription (*this, f, c);
  }

  FolioDescription& FolioDescription::
  operator= (const FolioDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->Neighbourhood_ = x.Neighbourhood_;
      this->ActualUseCode_ = x.ActualUseCode_;
      this->ActualUseDescription_ = x.ActualUseDescription_;
      this->VacantFlag_ = x.VacantFlag_;
      this->BCTransitFlag_ = x.BCTransitFlag_;
      this->PoliceTaxFlag_ = x.PoliceTaxFlag_;
      this->ALRCode_ = x.ALRCode_;
      this->ALRDescription_ = x.ALRDescription_;
      this->ParkingArea_ = x.ParkingArea_;
      this->LandMeasurement_ = x.LandMeasurement_;
      this->SchoolDistrict_ = x.SchoolDistrict_;
      this->RegionalDistrict_ = x.RegionalDistrict_;
      this->RegionalHospitalDistrict_ = x.RegionalHospitalDistrict_;
      this->PredominantManualClass_ = x.PredominantManualClass_;
    }

    return *this;
  }

  FolioDescription::
  ~FolioDescription ()
  {
  }

  // LandMeasurement
  //

  LandMeasurement::
  LandMeasurement ()
  : ::dataadvice::FolioItemGroup (),
    LandDimensionType_ (this),
    LandDimensionTypeDescription_ (this),
    LandDimension_ (this),
    LandWidth_ (this),
    LandDepth_ (this)
  {
  }

  LandMeasurement::
  LandMeasurement (const LandMeasurement& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    LandDimensionType_ (x.LandDimensionType_, f, this),
    LandDimensionTypeDescription_ (x.LandDimensionTypeDescription_, f, this),
    LandDimension_ (x.LandDimension_, f, this),
    LandWidth_ (x.LandWidth_, f, this),
    LandDepth_ (x.LandDepth_, f, this)
  {
  }

  LandMeasurement::
  LandMeasurement (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    LandDimensionType_ (this),
    LandDimensionTypeDescription_ (this),
    LandDimension_ (this),
    LandWidth_ (this),
    LandDepth_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LandMeasurement::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LandDimensionType
      //
      if (n.name () == "LandDimensionType" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandDimensionType_type > r (
          LandDimensionType_traits::create (i, f, this));

        if (!this->LandDimensionType_)
        {
          this->LandDimensionType_.set (::std::move (r));
          continue;
        }
      }

      // LandDimensionTypeDescription
      //
      if (n.name () == "LandDimensionTypeDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandDimensionTypeDescription_type > r (
          LandDimensionTypeDescription_traits::create (i, f, this));

        if (!this->LandDimensionTypeDescription_)
        {
          this->LandDimensionTypeDescription_.set (::std::move (r));
          continue;
        }
      }

      // LandDimension
      //
      if (n.name () == "LandDimension" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandDimension_type > r (
          LandDimension_traits::create (i, f, this));

        if (!this->LandDimension_)
        {
          this->LandDimension_.set (::std::move (r));
          continue;
        }
      }

      // LandWidth
      //
      if (n.name () == "LandWidth" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandWidth_type > r (
          LandWidth_traits::create (i, f, this));

        if (!this->LandWidth_)
        {
          this->LandWidth_.set (::std::move (r));
          continue;
        }
      }

      // LandDepth
      //
      if (n.name () == "LandDepth" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LandDepth_type > r (
          LandDepth_traits::create (i, f, this));

        if (!this->LandDepth_)
        {
          this->LandDepth_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  LandMeasurement* LandMeasurement::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LandMeasurement (*this, f, c);
  }

  LandMeasurement& LandMeasurement::
  operator= (const LandMeasurement& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->LandDimensionType_ = x.LandDimensionType_;
      this->LandDimensionTypeDescription_ = x.LandDimensionTypeDescription_;
      this->LandDimension_ = x.LandDimension_;
      this->LandWidth_ = x.LandWidth_;
      this->LandDepth_ = x.LandDepth_;
    }

    return *this;
  }

  LandMeasurement::
  ~LandMeasurement ()
  {
  }

  // Neighbourhood
  //

  Neighbourhood::
  Neighbourhood ()
  : ::dataadvice::FolioItemGroup (),
    NeighbourhoodCode_ (this),
    NeighbourhoodDescription_ (this)
  {
  }

  Neighbourhood::
  Neighbourhood (const Neighbourhood& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    NeighbourhoodCode_ (x.NeighbourhoodCode_, f, this),
    NeighbourhoodDescription_ (x.NeighbourhoodDescription_, f, this)
  {
  }

  Neighbourhood::
  Neighbourhood (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    NeighbourhoodCode_ (this),
    NeighbourhoodDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Neighbourhood::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // NeighbourhoodCode
      //
      if (n.name () == "NeighbourhoodCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< NeighbourhoodCode_type > r (
          NeighbourhoodCode_traits::create (i, f, this));

        if (!this->NeighbourhoodCode_)
        {
          this->NeighbourhoodCode_.set (::std::move (r));
          continue;
        }
      }

      // NeighbourhoodDescription
      //
      if (n.name () == "NeighbourhoodDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< NeighbourhoodDescription_type > r (
          NeighbourhoodDescription_traits::create (i, f, this));

        if (!this->NeighbourhoodDescription_)
        {
          this->NeighbourhoodDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  Neighbourhood* Neighbourhood::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Neighbourhood (*this, f, c);
  }

  Neighbourhood& Neighbourhood::
  operator= (const Neighbourhood& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->NeighbourhoodCode_ = x.NeighbourhoodCode_;
      this->NeighbourhoodDescription_ = x.NeighbourhoodDescription_;
    }

    return *this;
  }

  Neighbourhood::
  ~Neighbourhood ()
  {
  }

  // SpecialDistrict
  //

  SpecialDistrict::
  SpecialDistrict ()
  : ::dataadvice::FolioItemGroup (),
    DistrictCode_ (this),
    DistrictDescription_ (this)
  {
  }

  SpecialDistrict::
  SpecialDistrict (const SpecialDistrict& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    DistrictCode_ (x.DistrictCode_, f, this),
    DistrictDescription_ (x.DistrictDescription_, f, this)
  {
  }

  SpecialDistrict::
  SpecialDistrict (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    DistrictCode_ (this),
    DistrictDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SpecialDistrict::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // DistrictCode
      //
      if (n.name () == "DistrictCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DistrictCode_type > r (
          DistrictCode_traits::create (i, f, this));

        if (!this->DistrictCode_)
        {
          this->DistrictCode_.set (::std::move (r));
          continue;
        }
      }

      // DistrictDescription
      //
      if (n.name () == "DistrictDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< DistrictDescription_type > r (
          DistrictDescription_traits::create (i, f, this));

        if (!this->DistrictDescription_)
        {
          this->DistrictDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  SpecialDistrict* SpecialDistrict::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SpecialDistrict (*this, f, c);
  }

  SpecialDistrict& SpecialDistrict::
  operator= (const SpecialDistrict& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->DistrictCode_ = x.DistrictCode_;
      this->DistrictDescription_ = x.DistrictDescription_;
    }

    return *this;
  }

  SpecialDistrict::
  ~SpecialDistrict ()
  {
  }

  // ManualClass
  //

  ManualClass::
  ManualClass ()
  : ::dataadvice::FolioItemGroup (),
    ManualClassCode_ (this),
    ManualClassDescription_ (this),
    PercentDeviation_ (this)
  {
  }

  ManualClass::
  ManualClass (const ManualClass& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    ManualClassCode_ (x.ManualClassCode_, f, this),
    ManualClassDescription_ (x.ManualClassDescription_, f, this),
    PercentDeviation_ (x.PercentDeviation_, f, this)
  {
  }

  ManualClass::
  ManualClass (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    ManualClassCode_ (this),
    ManualClassDescription_ (this),
    PercentDeviation_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ManualClass::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ManualClassCode
      //
      if (n.name () == "ManualClassCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManualClassCode_type > r (
          ManualClassCode_traits::create (i, f, this));

        if (!this->ManualClassCode_)
        {
          this->ManualClassCode_.set (::std::move (r));
          continue;
        }
      }

      // ManualClassDescription
      //
      if (n.name () == "ManualClassDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ManualClassDescription_type > r (
          ManualClassDescription_traits::create (i, f, this));

        if (!this->ManualClassDescription_)
        {
          this->ManualClassDescription_.set (::std::move (r));
          continue;
        }
      }

      // PercentDeviation
      //
      if (n.name () == "PercentDeviation" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PercentDeviation_type > r (
          PercentDeviation_traits::create (i, f, this));

        if (!this->PercentDeviation_)
        {
          this->PercentDeviation_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  ManualClass* ManualClass::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ManualClass (*this, f, c);
  }

  ManualClass& ManualClass::
  operator= (const ManualClass& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->ManualClassCode_ = x.ManualClassCode_;
      this->ManualClassDescription_ = x.ManualClassDescription_;
      this->PercentDeviation_ = x.PercentDeviation_;
    }

    return *this;
  }

  ManualClass::
  ~ManualClass ()
  {
  }

  // MinorTaxing
  //

  MinorTaxing::
  MinorTaxing ()
  : ::dataadvice::FolioItemGroup (),
    ElectoralAreas_ (this),
    ServiceAreas_ (this),
    Defined_ (this),
    SpecifiedRegional_ (this),
    SpecifiedMunicipal_ (this),
    LocalAreas_ (this),
    GeneralServices_ (this),
    ImprovementDistricts_ (this),
    IslandsTrusts_ (this)
  {
  }

  MinorTaxing::
  MinorTaxing (const MinorTaxing& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    ElectoralAreas_ (x.ElectoralAreas_, f, this),
    ServiceAreas_ (x.ServiceAreas_, f, this),
    Defined_ (x.Defined_, f, this),
    SpecifiedRegional_ (x.SpecifiedRegional_, f, this),
    SpecifiedMunicipal_ (x.SpecifiedMunicipal_, f, this),
    LocalAreas_ (x.LocalAreas_, f, this),
    GeneralServices_ (x.GeneralServices_, f, this),
    ImprovementDistricts_ (x.ImprovementDistricts_, f, this),
    IslandsTrusts_ (x.IslandsTrusts_, f, this)
  {
  }

  MinorTaxing::
  MinorTaxing (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    ElectoralAreas_ (this),
    ServiceAreas_ (this),
    Defined_ (this),
    SpecifiedRegional_ (this),
    SpecifiedMunicipal_ (this),
    LocalAreas_ (this),
    GeneralServices_ (this),
    ImprovementDistricts_ (this),
    IslandsTrusts_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MinorTaxing::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ElectoralAreas
      //
      if (n.name () == "ElectoralAreas" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ElectoralAreas_type > r (
          ElectoralAreas_traits::create (i, f, this));

        if (!this->ElectoralAreas_)
        {
          this->ElectoralAreas_.set (::std::move (r));
          continue;
        }
      }

      // ServiceAreas
      //
      if (n.name () == "ServiceAreas" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ServiceAreas_type > r (
          ServiceAreas_traits::create (i, f, this));

        if (!this->ServiceAreas_)
        {
          this->ServiceAreas_.set (::std::move (r));
          continue;
        }
      }

      // Defined
      //
      if (n.name () == "Defined" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< Defined_type > r (
          Defined_traits::create (i, f, this));

        if (!this->Defined_)
        {
          this->Defined_.set (::std::move (r));
          continue;
        }
      }

      // SpecifiedRegional
      //
      if (n.name () == "SpecifiedRegional" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SpecifiedRegional_type > r (
          SpecifiedRegional_traits::create (i, f, this));

        if (!this->SpecifiedRegional_)
        {
          this->SpecifiedRegional_.set (::std::move (r));
          continue;
        }
      }

      // SpecifiedMunicipal
      //
      if (n.name () == "SpecifiedMunicipal" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SpecifiedMunicipal_type > r (
          SpecifiedMunicipal_traits::create (i, f, this));

        if (!this->SpecifiedMunicipal_)
        {
          this->SpecifiedMunicipal_.set (::std::move (r));
          continue;
        }
      }

      // LocalAreas
      //
      if (n.name () == "LocalAreas" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< LocalAreas_type > r (
          LocalAreas_traits::create (i, f, this));

        if (!this->LocalAreas_)
        {
          this->LocalAreas_.set (::std::move (r));
          continue;
        }
      }

      // GeneralServices
      //
      if (n.name () == "GeneralServices" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< GeneralServices_type > r (
          GeneralServices_traits::create (i, f, this));

        if (!this->GeneralServices_)
        {
          this->GeneralServices_.set (::std::move (r));
          continue;
        }
      }

      // ImprovementDistricts
      //
      if (n.name () == "ImprovementDistricts" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< ImprovementDistricts_type > r (
          ImprovementDistricts_traits::create (i, f, this));

        if (!this->ImprovementDistricts_)
        {
          this->ImprovementDistricts_.set (::std::move (r));
          continue;
        }
      }

      // IslandsTrusts
      //
      if (n.name () == "IslandsTrusts" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< IslandsTrusts_type > r (
          IslandsTrusts_traits::create (i, f, this));

        if (!this->IslandsTrusts_)
        {
          this->IslandsTrusts_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MinorTaxing* MinorTaxing::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MinorTaxing (*this, f, c);
  }

  MinorTaxing& MinorTaxing::
  operator= (const MinorTaxing& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->ElectoralAreas_ = x.ElectoralAreas_;
      this->ServiceAreas_ = x.ServiceAreas_;
      this->Defined_ = x.Defined_;
      this->SpecifiedRegional_ = x.SpecifiedRegional_;
      this->SpecifiedMunicipal_ = x.SpecifiedMunicipal_;
      this->LocalAreas_ = x.LocalAreas_;
      this->GeneralServices_ = x.GeneralServices_;
      this->ImprovementDistricts_ = x.ImprovementDistricts_;
      this->IslandsTrusts_ = x.IslandsTrusts_;
    }

    return *this;
  }

  MinorTaxing::
  ~MinorTaxing ()
  {
  }

  // MinorTaxingJurisdictionCollection
  //

  MinorTaxingJurisdictionCollection::
  MinorTaxingJurisdictionCollection ()
  : ::dataadvice::FolioItemGroup (),
    MinorTaxingJurisdiction_ (this)
  {
  }

  MinorTaxingJurisdictionCollection::
  MinorTaxingJurisdictionCollection (const MinorTaxingJurisdictionCollection& x,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    MinorTaxingJurisdiction_ (x.MinorTaxingJurisdiction_, f, this)
  {
  }

  MinorTaxingJurisdictionCollection::
  MinorTaxingJurisdictionCollection (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f,
                                     ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    MinorTaxingJurisdiction_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MinorTaxingJurisdictionCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MinorTaxingJurisdiction
      //
      if (n.name () == "MinorTaxingJurisdiction" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MinorTaxingJurisdiction_type > r (
          MinorTaxingJurisdiction_traits::create (i, f, this));

        this->MinorTaxingJurisdiction_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MinorTaxingJurisdictionCollection* MinorTaxingJurisdictionCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MinorTaxingJurisdictionCollection (*this, f, c);
  }

  MinorTaxingJurisdictionCollection& MinorTaxingJurisdictionCollection::
  operator= (const MinorTaxingJurisdictionCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->MinorTaxingJurisdiction_ = x.MinorTaxingJurisdiction_;
    }

    return *this;
  }

  MinorTaxingJurisdictionCollection::
  ~MinorTaxingJurisdictionCollection ()
  {
  }

  // MinorTaxingJurisdiction
  //

  MinorTaxingJurisdiction::
  MinorTaxingJurisdiction ()
  : ::dataadvice::FolioItemGroup (),
    MinorTaxingCode_ (this),
    MinorTaxingCodeShort_ (this),
    MinorTaxingDescription_ (this)
  {
  }

  MinorTaxingJurisdiction::
  MinorTaxingJurisdiction (const MinorTaxingJurisdiction& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (x, f, c),
    MinorTaxingCode_ (x.MinorTaxingCode_, f, this),
    MinorTaxingCodeShort_ (x.MinorTaxingCodeShort_, f, this),
    MinorTaxingDescription_ (x.MinorTaxingDescription_, f, this)
  {
  }

  MinorTaxingJurisdiction::
  MinorTaxingJurisdiction (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::dataadvice::FolioItemGroup (e, f | ::xml_schema::flags::base, c),
    MinorTaxingCode_ (this),
    MinorTaxingCodeShort_ (this),
    MinorTaxingDescription_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MinorTaxingJurisdiction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::dataadvice::FolioItemGroup::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // MinorTaxingCode
      //
      if (n.name () == "MinorTaxingCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MinorTaxingCode_type > r (
          MinorTaxingCode_traits::create (i, f, this));

        if (!this->MinorTaxingCode_)
        {
          this->MinorTaxingCode_.set (::std::move (r));
          continue;
        }
      }

      // MinorTaxingCodeShort
      //
      if (n.name () == "MinorTaxingCodeShort" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MinorTaxingCodeShort_type > r (
          MinorTaxingCodeShort_traits::create (i, f, this));

        if (!this->MinorTaxingCodeShort_)
        {
          this->MinorTaxingCodeShort_.set (::std::move (r));
          continue;
        }
      }

      // MinorTaxingDescription
      //
      if (n.name () == "MinorTaxingDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< MinorTaxingDescription_type > r (
          MinorTaxingDescription_traits::create (i, f, this));

        if (!this->MinorTaxingDescription_)
        {
          this->MinorTaxingDescription_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  MinorTaxingJurisdiction* MinorTaxingJurisdiction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MinorTaxingJurisdiction (*this, f, c);
  }

  MinorTaxingJurisdiction& MinorTaxingJurisdiction::
  operator= (const MinorTaxingJurisdiction& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::FolioItemGroup& > (*this) = x;
      this->MinorTaxingCode_ = x.MinorTaxingCode_;
      this->MinorTaxingCodeShort_ = x.MinorTaxingCodeShort_;
      this->MinorTaxingDescription_ = x.MinorTaxingDescription_;
    }

    return *this;
  }

  MinorTaxingJurisdiction::
  ~MinorTaxingJurisdiction ()
  {
  }

  // PropertyValues
  //

  PropertyValues::
  PropertyValues ()
  : ::xml_schema::type (),
    GeneralValues_ (this),
    BCTransitValues_ (this),
    SchoolValues_ (this),
    TaxExemptValues_ (this)
  {
  }

  PropertyValues::
  PropertyValues (const PropertyValues& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    GeneralValues_ (x.GeneralValues_, f, this),
    BCTransitValues_ (x.BCTransitValues_, f, this),
    SchoolValues_ (x.SchoolValues_, f, this),
    TaxExemptValues_ (x.TaxExemptValues_, f, this)
  {
  }

  PropertyValues::
  PropertyValues (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    GeneralValues_ (this),
    BCTransitValues_ (this),
    SchoolValues_ (this),
    TaxExemptValues_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PropertyValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // GeneralValues
      //
      if (n.name () == "GeneralValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< GeneralValues_type > r (
          GeneralValues_traits::create (i, f, this));

        if (!this->GeneralValues_)
        {
          this->GeneralValues_.set (::std::move (r));
          continue;
        }
      }

      // BCTransitValues
      //
      if (n.name () == "BCTransitValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< BCTransitValues_type > r (
          BCTransitValues_traits::create (i, f, this));

        if (!this->BCTransitValues_)
        {
          this->BCTransitValues_.set (::std::move (r));
          continue;
        }
      }

      // SchoolValues
      //
      if (n.name () == "SchoolValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< SchoolValues_type > r (
          SchoolValues_traits::create (i, f, this));

        if (!this->SchoolValues_)
        {
          this->SchoolValues_.set (::std::move (r));
          continue;
        }
      }

      // TaxExemptValues
      //
      if (n.name () == "TaxExemptValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TaxExemptValues_type > r (
          TaxExemptValues_traits::create (i, f, this));

        if (!this->TaxExemptValues_)
        {
          this->TaxExemptValues_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  PropertyValues* PropertyValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PropertyValues (*this, f, c);
  }

  PropertyValues& PropertyValues::
  operator= (const PropertyValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->GeneralValues_ = x.GeneralValues_;
      this->BCTransitValues_ = x.BCTransitValues_;
      this->SchoolValues_ = x.SchoolValues_;
      this->TaxExemptValues_ = x.TaxExemptValues_;
    }

    return *this;
  }

  PropertyValues::
  ~PropertyValues ()
  {
  }

  // TaxExemptValuesCollection
  //

  TaxExemptValuesCollection::
  TaxExemptValuesCollection ()
  : ::xml_schema::type (),
    TaxExemptPropertyClassValues_ (this)
  {
  }

  TaxExemptValuesCollection::
  TaxExemptValuesCollection (const TaxExemptValuesCollection& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TaxExemptPropertyClassValues_ (x.TaxExemptPropertyClassValues_, f, this)
  {
  }

  TaxExemptValuesCollection::
  TaxExemptValuesCollection (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TaxExemptPropertyClassValues_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TaxExemptValuesCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TaxExemptPropertyClassValues
      //
      if (n.name () == "TaxExemptPropertyClassValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TaxExemptPropertyClassValues_type > r (
          TaxExemptPropertyClassValues_traits::create (i, f, this));

        this->TaxExemptPropertyClassValues_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  TaxExemptValuesCollection* TaxExemptValuesCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TaxExemptValuesCollection (*this, f, c);
  }

  TaxExemptValuesCollection& TaxExemptValuesCollection::
  operator= (const TaxExemptValuesCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->TaxExemptPropertyClassValues_ = x.TaxExemptPropertyClassValues_;
    }

    return *this;
  }

  TaxExemptValuesCollection::
  ~TaxExemptValuesCollection ()
  {
  }

  // TaxExemptPropertyClassValues
  //

  TaxExemptPropertyClassValues::
  TaxExemptPropertyClassValues (const TaxExemptCode_type& TaxExemptCode,
                                const PropertyClassCode_type& PropertyClassCode,
                                const LandValue_type& LandValue,
                                const ImprovementValue_type& ImprovementValue)
  : ::xml_schema::type (),
    TaxExemptCode_ (TaxExemptCode, this),
    TaxExemptDescription_ (this),
    PropertyClassCode_ (PropertyClassCode, this),
    PropertyClassDescription_ (this),
    LandValue_ (LandValue, this),
    ImprovementValue_ (ImprovementValue, this)
  {
  }

  TaxExemptPropertyClassValues::
  TaxExemptPropertyClassValues (const TaxExemptPropertyClassValues& x,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TaxExemptCode_ (x.TaxExemptCode_, f, this),
    TaxExemptDescription_ (x.TaxExemptDescription_, f, this),
    PropertyClassCode_ (x.PropertyClassCode_, f, this),
    PropertyClassDescription_ (x.PropertyClassDescription_, f, this),
    LandValue_ (x.LandValue_, f, this),
    ImprovementValue_ (x.ImprovementValue_, f, this)
  {
  }

  TaxExemptPropertyClassValues::
  TaxExemptPropertyClassValues (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f,
                                ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TaxExemptCode_ (this),
    TaxExemptDescription_ (this),
    PropertyClassCode_ (this),
    PropertyClassDescription_ (this),
    LandValue_ (this),
    ImprovementValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TaxExemptPropertyClassValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TaxExemptCode
      //
      if (n.name () == "TaxExemptCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TaxExemptCode_type > r (
          TaxExemptCode_traits::create (i, f, this));

        if (!TaxExemptCode_.present ())
        {
          this->TaxExemptCode_.set (::std::move (r));
          continue;
        }
      }

      // TaxExemptDescription
      //
      if (n.name () == "TaxExemptDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TaxExemptDescription_type > r (
          TaxExemptDescription_traits::create (i, f, this));

        if (!this->TaxExemptDescription_)
        {
          this->TaxExemptDescription_.set (::std::move (r));
          continue;
        }
      }

      // PropertyClassCode
      //
      if (n.name () == "PropertyClassCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertyClassCode_type > r (
          PropertyClassCode_traits::create (i, f, this));

        if (!PropertyClassCode_.present ())
        {
          this->PropertyClassCode_.set (::std::move (r));
          continue;
        }
      }

      // PropertyClassDescription
      //
      if (n.name () == "PropertyClassDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertyClassDescription_type > r (
          PropertyClassDescription_traits::create (i, f, this));

        if (!this->PropertyClassDescription_)
        {
          this->PropertyClassDescription_.set (::std::move (r));
          continue;
        }
      }

      // LandValue
      //
      if (n.name () == "LandValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!LandValue_.present ())
        {
          this->LandValue_.set (LandValue_traits::create (i, f, this));
          continue;
        }
      }

      // ImprovementValue
      //
      if (n.name () == "ImprovementValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!ImprovementValue_.present ())
        {
          this->ImprovementValue_.set (ImprovementValue_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!TaxExemptCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TaxExemptCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!PropertyClassCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PropertyClassCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!LandValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LandValue",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!ImprovementValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ImprovementValue",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  TaxExemptPropertyClassValues* TaxExemptPropertyClassValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TaxExemptPropertyClassValues (*this, f, c);
  }

  TaxExemptPropertyClassValues& TaxExemptPropertyClassValues::
  operator= (const TaxExemptPropertyClassValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->TaxExemptCode_ = x.TaxExemptCode_;
      this->TaxExemptDescription_ = x.TaxExemptDescription_;
      this->PropertyClassCode_ = x.PropertyClassCode_;
      this->PropertyClassDescription_ = x.PropertyClassDescription_;
      this->LandValue_ = x.LandValue_;
      this->ImprovementValue_ = x.ImprovementValue_;
    }

    return *this;
  }

  TaxExemptPropertyClassValues::
  ~TaxExemptPropertyClassValues ()
  {
  }

  // PropertyClassValuesCollection
  //

  PropertyClassValuesCollection::
  PropertyClassValuesCollection ()
  : ::xml_schema::type (),
    PropertyClassValues_ (this)
  {
  }

  PropertyClassValuesCollection::
  PropertyClassValuesCollection (const PropertyClassValuesCollection& x,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    PropertyClassValues_ (x.PropertyClassValues_, f, this)
  {
  }

  PropertyClassValuesCollection::
  PropertyClassValuesCollection (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    PropertyClassValues_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PropertyClassValuesCollection::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PropertyClassValues
      //
      if (n.name () == "PropertyClassValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertyClassValues_type > r (
          PropertyClassValues_traits::create (i, f, this));

        this->PropertyClassValues_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  PropertyClassValuesCollection* PropertyClassValuesCollection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PropertyClassValuesCollection (*this, f, c);
  }

  PropertyClassValuesCollection& PropertyClassValuesCollection::
  operator= (const PropertyClassValuesCollection& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->PropertyClassValues_ = x.PropertyClassValues_;
    }

    return *this;
  }

  PropertyClassValuesCollection::
  ~PropertyClassValuesCollection ()
  {
  }

  // PropertyClassValues
  //

  PropertyClassValues::
  PropertyClassValues (const PropertyClassCode_type& PropertyClassCode)
  : ::xml_schema::type (),
    PropertyClassCode_ (PropertyClassCode, this),
    PropertyClassDescription_ (this),
    PropertySubClassCode_ (this),
    PropertySubClassDescription_ (this),
    GrossValues_ (this),
    TaxExemptValues_ (this),
    NetValues_ (this)
  {
  }

  PropertyClassValues::
  PropertyClassValues (const PropertyClassValues& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    PropertyClassCode_ (x.PropertyClassCode_, f, this),
    PropertyClassDescription_ (x.PropertyClassDescription_, f, this),
    PropertySubClassCode_ (x.PropertySubClassCode_, f, this),
    PropertySubClassDescription_ (x.PropertySubClassDescription_, f, this),
    GrossValues_ (x.GrossValues_, f, this),
    TaxExemptValues_ (x.TaxExemptValues_, f, this),
    NetValues_ (x.NetValues_, f, this)
  {
  }

  PropertyClassValues::
  PropertyClassValues (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    PropertyClassCode_ (this),
    PropertyClassDescription_ (this),
    PropertySubClassCode_ (this),
    PropertySubClassDescription_ (this),
    GrossValues_ (this),
    TaxExemptValues_ (this),
    NetValues_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PropertyClassValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PropertyClassCode
      //
      if (n.name () == "PropertyClassCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertyClassCode_type > r (
          PropertyClassCode_traits::create (i, f, this));

        if (!PropertyClassCode_.present ())
        {
          this->PropertyClassCode_.set (::std::move (r));
          continue;
        }
      }

      // PropertyClassDescription
      //
      if (n.name () == "PropertyClassDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertyClassDescription_type > r (
          PropertyClassDescription_traits::create (i, f, this));

        if (!this->PropertyClassDescription_)
        {
          this->PropertyClassDescription_.set (::std::move (r));
          continue;
        }
      }

      // PropertySubClassCode
      //
      if (n.name () == "PropertySubClassCode" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertySubClassCode_type > r (
          PropertySubClassCode_traits::create (i, f, this));

        if (!this->PropertySubClassCode_)
        {
          this->PropertySubClassCode_.set (::std::move (r));
          continue;
        }
      }

      // PropertySubClassDescription
      //
      if (n.name () == "PropertySubClassDescription" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< PropertySubClassDescription_type > r (
          PropertySubClassDescription_traits::create (i, f, this));

        if (!this->PropertySubClassDescription_)
        {
          this->PropertySubClassDescription_.set (::std::move (r));
          continue;
        }
      }

      // GrossValues
      //
      if (n.name () == "GrossValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< GrossValues_type > r (
          GrossValues_traits::create (i, f, this));

        if (!this->GrossValues_)
        {
          this->GrossValues_.set (::std::move (r));
          continue;
        }
      }

      // TaxExemptValues
      //
      if (n.name () == "TaxExemptValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< TaxExemptValues_type > r (
          TaxExemptValues_traits::create (i, f, this));

        if (!this->TaxExemptValues_)
        {
          this->TaxExemptValues_.set (::std::move (r));
          continue;
        }
      }

      // NetValues
      //
      if (n.name () == "NetValues" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        ::std::unique_ptr< NetValues_type > r (
          NetValues_traits::create (i, f, this));

        if (!this->NetValues_)
        {
          this->NetValues_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!PropertyClassCode_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PropertyClassCode",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  PropertyClassValues* PropertyClassValues::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PropertyClassValues (*this, f, c);
  }

  PropertyClassValues& PropertyClassValues::
  operator= (const PropertyClassValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->PropertyClassCode_ = x.PropertyClassCode_;
      this->PropertyClassDescription_ = x.PropertyClassDescription_;
      this->PropertySubClassCode_ = x.PropertySubClassCode_;
      this->PropertySubClassDescription_ = x.PropertySubClassDescription_;
      this->GrossValues_ = x.GrossValues_;
      this->TaxExemptValues_ = x.TaxExemptValues_;
      this->NetValues_ = x.NetValues_;
    }

    return *this;
  }

  PropertyClassValues::
  ~PropertyClassValues ()
  {
  }

  // PropertyClassCode
  //

  PropertyClassCode::
  PropertyClassCode ()
  : ::xml_schema::string ()
  {
  }

  PropertyClassCode::
  PropertyClassCode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PropertyClassCode::
  PropertyClassCode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PropertyClassCode::
  PropertyClassCode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PropertyClassCode::
  PropertyClassCode (const PropertyClassCode& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  PropertyClassCode::
  PropertyClassCode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  PropertyClassCode::
  PropertyClassCode (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  PropertyClassCode::
  PropertyClassCode (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  PropertyClassCode* PropertyClassCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PropertyClassCode (*this, f, c);
  }

  PropertyClassCode::
  ~PropertyClassCode ()
  {
  }

  // PropertySubClassCode
  //

  PropertySubClassCode::
  PropertySubClassCode ()
  : ::xml_schema::string ()
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const PropertySubClassCode& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  PropertySubClassCode::
  PropertySubClassCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  PropertySubClassCode* PropertySubClassCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class PropertySubClassCode (*this, f, c);
  }

  PropertySubClassCode::
  ~PropertySubClassCode ()
  {
  }

  // Valuation
  //

  Valuation::
  Valuation (const LandValue_type& LandValue,
             const ImprovementValue_type& ImprovementValue)
  : ::xml_schema::type (),
    LandValue_ (LandValue, this),
    ImprovementValue_ (ImprovementValue, this)
  {
  }

  Valuation::
  Valuation (const Valuation& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    LandValue_ (x.LandValue_, f, this),
    ImprovementValue_ (x.ImprovementValue_, f, this)
  {
  }

  Valuation::
  Valuation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    LandValue_ (this),
    ImprovementValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Valuation::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // LandValue
      //
      if (n.name () == "LandValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!LandValue_.present ())
        {
          this->LandValue_.set (LandValue_traits::create (i, f, this));
          continue;
        }
      }

      // ImprovementValue
      //
      if (n.name () == "ImprovementValue" && n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
      {
        if (!ImprovementValue_.present ())
        {
          this->ImprovementValue_.set (ImprovementValue_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!LandValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "LandValue",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }

    if (!ImprovementValue_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ImprovementValue",
        "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
    }
  }

  Valuation* Valuation::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Valuation (*this, f, c);
  }

  Valuation& Valuation::
  operator= (const Valuation& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->LandValue_ = x.LandValue_;
      this->ImprovementValue_ = x.ImprovementValue_;
    }

    return *this;
  }

  Valuation::
  ~Valuation ()
  {
  }

  // FolioIntegerItem
  //

  FolioIntegerItem::
  FolioIntegerItem (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioIntegerItem::
  FolioIntegerItem (const FolioIntegerItem& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioIntegerItem::
  FolioIntegerItem (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioIntegerItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioIntegerItem* FolioIntegerItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioIntegerItem (*this, f, c);
  }

  FolioIntegerItem& FolioIntegerItem::
  operator= (const FolioIntegerItem& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioIntegerItem::
  ~FolioIntegerItem ()
  {
  }

  // FolioBooleanItem
  //

  FolioBooleanItem::
  FolioBooleanItem (const ::xml_schema::boolean& _xsd_boolean_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (_xsd_boolean_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioBooleanItem::
  FolioBooleanItem (const FolioBooleanItem& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioBooleanItem::
  FolioBooleanItem (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioBooleanItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioBooleanItem* FolioBooleanItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioBooleanItem (*this, f, c);
  }

  FolioBooleanItem& FolioBooleanItem::
  operator= (const FolioBooleanItem& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioBooleanItem::
  ~FolioBooleanItem ()
  {
  }

  // FolioDecimalItem
  //

  FolioDecimalItem::
  FolioDecimalItem (const ::xml_schema::decimal& _xsd_decimal_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (_xsd_decimal_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioDecimalItem::
  FolioDecimalItem (const FolioDecimalItem& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioDecimalItem::
  FolioDecimalItem (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal > (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioDecimalItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioDecimalItem* FolioDecimalItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioDecimalItem (*this, f, c);
  }

  FolioDecimalItem& FolioDecimalItem::
  operator= (const FolioDecimalItem& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioDecimalItem::
  ~FolioDecimalItem ()
  {
  }

  // FolioDateItem
  //

  FolioDateItem::
  FolioDateItem (const ::xml_schema::date& _xsd_date_base)
  : ::xml_schema::date (_xsd_date_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioDateItem::
  FolioDateItem (const FolioDateItem& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::date (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioDateItem::
  FolioDateItem (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::date (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioDateItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioDateItem* FolioDateItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioDateItem (*this, f, c);
  }

  FolioDateItem& FolioDateItem::
  operator= (const FolioDateItem& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::date& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioDateItem::
  ~FolioDateItem ()
  {
  }

  // UniqueID
  //

  UniqueID::
  UniqueID ()
  : ::xml_schema::string ()
  {
  }

  UniqueID::
  UniqueID (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UniqueID::
  UniqueID (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UniqueID::
  UniqueID (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  UniqueID::
  UniqueID (const UniqueID& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  UniqueID::
  UniqueID (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  UniqueID::
  UniqueID (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  UniqueID::
  UniqueID (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  UniqueID* UniqueID::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class UniqueID (*this, f, c);
  }

  UniqueID::
  ~UniqueID ()
  {
  }

  // FolioUniqueIDItem
  //

  FolioUniqueIDItem::
  FolioUniqueIDItem ()
  : ::dataadvice::UniqueID (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioUniqueIDItem::
  FolioUniqueIDItem (const char* _xsd_string_base)
  : ::dataadvice::UniqueID (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioUniqueIDItem::
  FolioUniqueIDItem (const ::std::string& _xsd_string_base)
  : ::dataadvice::UniqueID (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioUniqueIDItem::
  FolioUniqueIDItem (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::UniqueID (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioUniqueIDItem::
  FolioUniqueIDItem (const FolioUniqueIDItem& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::dataadvice::UniqueID (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioUniqueIDItem::
  FolioUniqueIDItem (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::dataadvice::UniqueID (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioUniqueIDItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioUniqueIDItem* FolioUniqueIDItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioUniqueIDItem (*this, f, c);
  }

  FolioUniqueIDItem& FolioUniqueIDItem::
  operator= (const FolioUniqueIDItem& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::UniqueID& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioUniqueIDItem::
  ~FolioUniqueIDItem ()
  {
  }

  // LookupCode
  //

  LookupCode::
  LookupCode ()
  : ::xml_schema::string ()
  {
  }

  LookupCode::
  LookupCode (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LookupCode::
  LookupCode (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LookupCode::
  LookupCode (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  LookupCode::
  LookupCode (const LookupCode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  LookupCode::
  LookupCode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  LookupCode::
  LookupCode (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  LookupCode::
  LookupCode (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  LookupCode* LookupCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class LookupCode (*this, f, c);
  }

  LookupCode::
  ~LookupCode ()
  {
  }

  // FolioLookupCodeItem
  //

  FolioLookupCodeItem::
  FolioLookupCodeItem ()
  : ::dataadvice::LookupCode (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioLookupCodeItem::
  FolioLookupCodeItem (const char* _xsd_string_base)
  : ::dataadvice::LookupCode (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioLookupCodeItem::
  FolioLookupCodeItem (const ::std::string& _xsd_string_base)
  : ::dataadvice::LookupCode (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioLookupCodeItem::
  FolioLookupCodeItem (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::LookupCode (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioLookupCodeItem::
  FolioLookupCodeItem (const FolioLookupCodeItem& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::dataadvice::LookupCode (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioLookupCodeItem::
  FolioLookupCodeItem (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::dataadvice::LookupCode (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioLookupCodeItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioLookupCodeItem* FolioLookupCodeItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioLookupCodeItem (*this, f, c);
  }

  FolioLookupCodeItem& FolioLookupCodeItem::
  operator= (const FolioLookupCodeItem& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::LookupCode& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioLookupCodeItem::
  ~FolioLookupCodeItem ()
  {
  }

  // Character
  //

  Character::
  Character ()
  : ::xml_schema::string ()
  {
  }

  Character::
  Character (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Character::
  Character (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Character::
  Character (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  Character::
  Character (const Character& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  Character::
  Character (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  Character::
  Character (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  Character::
  Character (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  Character* Character::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Character (*this, f, c);
  }

  Character::
  ~Character ()
  {
  }

  // FolioCharacterItem
  //

  FolioCharacterItem::
  FolioCharacterItem ()
  : ::dataadvice::Character (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioCharacterItem::
  FolioCharacterItem (const char* _xsd_string_base)
  : ::dataadvice::Character (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioCharacterItem::
  FolioCharacterItem (const ::std::string& _xsd_string_base)
  : ::dataadvice::Character (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioCharacterItem::
  FolioCharacterItem (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::Character (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioCharacterItem::
  FolioCharacterItem (const FolioCharacterItem& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::dataadvice::Character (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioCharacterItem::
  FolioCharacterItem (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::dataadvice::Character (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioCharacterItem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioCharacterItem* FolioCharacterItem::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioCharacterItem (*this, f, c);
  }

  FolioCharacterItem& FolioCharacterItem::
  operator= (const FolioCharacterItem& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::Character& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioCharacterItem::
  ~FolioCharacterItem ()
  {
  }

  // String255
  //

  String255::
  String255 ()
  : ::xml_schema::string ()
  {
  }

  String255::
  String255 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String255::
  String255 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String255::
  String255 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String255::
  String255 (const String255& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  String255::
  String255 (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  String255::
  String255 (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  String255::
  String255 (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  String255* String255::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String255 (*this, f, c);
  }

  String255::
  ~String255 ()
  {
  }

  // FolioString255Item
  //

  FolioString255Item::
  FolioString255Item ()
  : ::dataadvice::String255 (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString255Item::
  FolioString255Item (const char* _xsd_string_base)
  : ::dataadvice::String255 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString255Item::
  FolioString255Item (const ::std::string& _xsd_string_base)
  : ::dataadvice::String255 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString255Item::
  FolioString255Item (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::String255 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString255Item::
  FolioString255Item (const FolioString255Item& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::dataadvice::String255 (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioString255Item::
  FolioString255Item (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::dataadvice::String255 (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioString255Item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioString255Item* FolioString255Item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioString255Item (*this, f, c);
  }

  FolioString255Item& FolioString255Item::
  operator= (const FolioString255Item& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::String255& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioString255Item::
  ~FolioString255Item ()
  {
  }

  // String1024
  //

  String1024::
  String1024 ()
  : ::xml_schema::string ()
  {
  }

  String1024::
  String1024 (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String1024::
  String1024 (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String1024::
  String1024 (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  String1024::
  String1024 (const String1024& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  String1024::
  String1024 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  String1024::
  String1024 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  String1024::
  String1024 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  String1024* String1024::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class String1024 (*this, f, c);
  }

  String1024::
  ~String1024 ()
  {
  }

  // FolioString1024Item
  //

  FolioString1024Item::
  FolioString1024Item ()
  : ::dataadvice::String1024 (),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString1024Item::
  FolioString1024Item (const char* _xsd_string_base)
  : ::dataadvice::String1024 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString1024Item::
  FolioString1024Item (const ::std::string& _xsd_string_base)
  : ::dataadvice::String1024 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString1024Item::
  FolioString1024Item (const ::xml_schema::string& _xsd_string_base)
  : ::dataadvice::String1024 (_xsd_string_base),
    Action_ (this),
    OldValue_ (this)
  {
  }

  FolioString1024Item::
  FolioString1024Item (const FolioString1024Item& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::dataadvice::String1024 (x, f, c),
    Action_ (x.Action_, f, this),
    OldValue_ (x.OldValue_, f, this)
  {
  }

  FolioString1024Item::
  FolioString1024Item (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::dataadvice::String1024 (e, f | ::xml_schema::flags::base, c),
    Action_ (this),
    OldValue_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void FolioString1024Item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Action" && n.namespace_ ().empty ())
      {
        this->Action_.set (Action_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "OldValue" && n.namespace_ ().empty ())
      {
        this->OldValue_.set (OldValue_traits::create (i, f, this));
        continue;
      }
    }
  }

  FolioString1024Item* FolioString1024Item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class FolioString1024Item (*this, f, c);
  }

  FolioString1024Item& FolioString1024Item::
  operator= (const FolioString1024Item& x)
  {
    if (this != &x)
    {
      static_cast< ::dataadvice::String1024& > (*this) = x;
      this->Action_ = x.Action_;
      this->OldValue_ = x.OldValue_;
    }

    return *this;
  }

  FolioString1024Item::
  ~FolioString1024Item ()
  {
  }

  // ActionCode
  //

  ActionCode::
  ActionCode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_ActionCode_convert ();
  }

  ActionCode::
  ActionCode (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_ActionCode_convert ();
  }

  ActionCode::
  ActionCode (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_ActionCode_convert ();
  }

  ActionCode* ActionCode::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ActionCode (*this, f, c);
  }

  ActionCode::value ActionCode::
  _xsd_ActionCode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ActionCode_literals_);
    const value* i (::std::lower_bound (
                      _xsd_ActionCode_indexes_,
                      _xsd_ActionCode_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_ActionCode_indexes_ + 3 || _xsd_ActionCode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const ActionCode::
  _xsd_ActionCode_literals_[3] =
  {
    "Add",
    "Change",
    "Delete"
  };

  const ActionCode::value ActionCode::
  _xsd_ActionCode_indexes_[3] =
  {
    ::dataadvice::ActionCode::Add,
    ::dataadvice::ActionCode::Change,
    ::dataadvice::ActionCode::Delete
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace dataadvice
{
  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::std::string& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::dataadvice::DataAdvice > (
      ::dataadvice::DataAdvice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::std::string& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::dataadvice::DataAdvice > (
      ::dataadvice::DataAdvice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::std::string& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::dataadvice::DataAdvice > (
      ::dataadvice::DataAdvice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dataadvice::DataAdvice_ (isrc, f, p);
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dataadvice::DataAdvice_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::dataadvice::DataAdvice_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dataadvice::DataAdvice_ (isrc, f, p);
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               const ::std::string& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dataadvice::DataAdvice_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               const ::std::string& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::dataadvice::DataAdvice_ (isrc, h, f, p);
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::dataadvice::DataAdvice > (
      ::dataadvice::DataAdvice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::dataadvice::DataAdvice > (
      ::dataadvice::DataAdvice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::dataadvice::DataAdvice > (
      ::dataadvice::DataAdvice_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::xercesc::DOMDocument& doc,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::dataadvice::DataAdvice > (
        ::dataadvice::DataAdvice_ (
          std::move (d), f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "DataAdvice" &&
        n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
    {
      ::std::unique_ptr< ::dataadvice::DataAdvice > r (
        ::xsd::cxx::tree::traits< ::dataadvice::DataAdvice, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DataAdvice",
      "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
  }

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "DataAdvice" &&
        n.namespace_ () == "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd")
    {
      ::std::unique_ptr< ::dataadvice::DataAdvice > r (
        ::xsd::cxx::tree::traits< ::dataadvice::DataAdvice, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "DataAdvice",
      "http://data.bcassessment.ca/DataAdvice/Formats/DAX/DataAdvice.xsd");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

