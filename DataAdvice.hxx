// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef E__WORKSPACE_PROJECTS_NEW_BCAAREADER_NATIVE_BCAA_IMPORTER2_DATA_ADVICE_HXX
#define E__WORKSPACE_PROJECTS_NEW_BCAAREADER_NATIVE_BCAA_IMPORTER2_DATA_ADVICE_HXX

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace dataadvice
{
  class DataAdvice;
  class Version;
  class RunType;
  class DeliverySummary;
  class AmendmentReasonCountCollection;
  class AmendmentReasonCount;
  class DeleteReasonCountCollection;
  class DeleteReasonCount;
  class AssessmentAreaCollection;
  class AssessmentArea;
  class AssessmentAreaCode;
  class JurisdictionCollection;
  class Jurisdiction;
  class JurisdictionCode;
  class FolioGroupValues;
  class FolioRecordCollection;
  class FolioRecord;
  class String32;
  class FolioRollNumber;
  class FolioAction;
  class FolioAdd;
  class FolioDelete;
  class FolioRenumber;
  class FolioItemGroup;
  class FolioAddressCollection;
  class FolioAddress;
  class OwnershipGroupCollection;
  class OwnershipGroup;
  class OwnerCollection;
  class Owner;
  class MailingAddress;
  class FormattedMailingAddress;
  class String40;
  class FormattedMailingAddressLine;
  class LegalDescriptionCollection;
  class LegalDescription;
  class LandCharacteristic;
  class LandCharacteristicCollection;
  class ManufacturedHomeCollection;
  class ManufacturedHome;
  class FarmCollection;
  class Farm;
  class OilAndGasCollection;
  class OilAndGas;
  class ManagedForestCollection;
  class ManagedForest;
  class FolioAmendmentCollection;
  class FolioAmendment;
  class SaleCollection;
  class Sale;
  class FolioDescription;
  class LandMeasurement;
  class Neighbourhood;
  class SpecialDistrict;
  class ManualClass;
  class MinorTaxing;
  class MinorTaxingJurisdictionCollection;
  class MinorTaxingJurisdiction;
  class PropertyValues;
  class TaxExemptValuesCollection;
  class TaxExemptPropertyClassValues;
  class PropertyClassValuesCollection;
  class PropertyClassValues;
  class PropertyClassCode;
  class PropertySubClassCode;
  class Valuation;
  class FolioIntegerItem;
  class FolioBooleanItem;
  class FolioDecimalItem;
  class FolioDateItem;
  class UniqueID;
  class FolioUniqueIDItem;
  class LookupCode;
  class FolioLookupCodeItem;
  class Character;
  class FolioCharacterItem;
  class String255;
  class FolioString255Item;
  class String1024;
  class FolioString1024Item;
  class ActionCode;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace dataadvice
{
  class DataAdvice: public ::xml_schema::type
  {
    public:
    // RollYear
    //
    typedef ::xml_schema::integer RollYear_type;
    typedef ::xsd::cxx::tree::traits< RollYear_type, char > RollYear_traits;

    const RollYear_type&
    RollYear () const;

    RollYear_type&
    RollYear ();

    void
    RollYear (const RollYear_type& x);

    // OwnershipYear
    //
    typedef ::xml_schema::integer OwnershipYear_type;
    typedef ::xsd::cxx::tree::traits< OwnershipYear_type, char > OwnershipYear_traits;

    const OwnershipYear_type&
    OwnershipYear () const;

    OwnershipYear_type&
    OwnershipYear ();

    void
    OwnershipYear (const OwnershipYear_type& x);

    // RunType
    //
    typedef ::dataadvice::RunType RunType_type;
    typedef ::xsd::cxx::tree::traits< RunType_type, char > RunType_traits;

    const RunType_type&
    RunType () const;

    RunType_type&
    RunType ();

    void
    RunType (const RunType_type& x);

    void
    RunType (::std::unique_ptr< RunType_type > p);

    // StartDate
    //
    typedef ::xml_schema::date StartDate_type;
    typedef ::xsd::cxx::tree::traits< StartDate_type, char > StartDate_traits;

    const StartDate_type&
    StartDate () const;

    StartDate_type&
    StartDate ();

    void
    StartDate (const StartDate_type& x);

    void
    StartDate (::std::unique_ptr< StartDate_type > p);

    // EndDate
    //
    typedef ::xml_schema::date EndDate_type;
    typedef ::xsd::cxx::tree::traits< EndDate_type, char > EndDate_traits;

    const EndDate_type&
    EndDate () const;

    EndDate_type&
    EndDate ();

    void
    EndDate (const EndDate_type& x);

    void
    EndDate (::std::unique_ptr< EndDate_type > p);

    // AssessmentAreas
    //
    typedef ::dataadvice::AssessmentAreaCollection AssessmentAreas_type;
    typedef ::xsd::cxx::tree::optional< AssessmentAreas_type > AssessmentAreas_optional;
    typedef ::xsd::cxx::tree::traits< AssessmentAreas_type, char > AssessmentAreas_traits;

    const AssessmentAreas_optional&
    AssessmentAreas () const;

    AssessmentAreas_optional&
    AssessmentAreas ();

    void
    AssessmentAreas (const AssessmentAreas_type& x);

    void
    AssessmentAreas (const AssessmentAreas_optional& x);

    void
    AssessmentAreas (::std::unique_ptr< AssessmentAreas_type > p);

    // ReportSummary
    //
    typedef ::dataadvice::DeliverySummary ReportSummary_type;
    typedef ::xsd::cxx::tree::optional< ReportSummary_type > ReportSummary_optional;
    typedef ::xsd::cxx::tree::traits< ReportSummary_type, char > ReportSummary_traits;

    const ReportSummary_optional&
    ReportSummary () const;

    ReportSummary_optional&
    ReportSummary ();

    void
    ReportSummary (const ReportSummary_type& x);

    void
    ReportSummary (const ReportSummary_optional& x);

    void
    ReportSummary (::std::unique_ptr< ReportSummary_type > p);

    // Version
    //
    typedef ::dataadvice::Version Version_type;
    typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

    const Version_type&
    Version () const;

    static const Version_type&
    Version_default_value ();

    // RequestID
    //
    typedef ::dataadvice::UniqueID RequestID_type;
    typedef ::xsd::cxx::tree::traits< RequestID_type, char > RequestID_traits;

    const RequestID_type&
    RequestID () const;

    RequestID_type&
    RequestID ();

    void
    RequestID (const RequestID_type& x);

    void
    RequestID (::std::unique_ptr< RequestID_type > p);

    // OrderID
    //
    typedef ::dataadvice::UniqueID OrderID_type;
    typedef ::xsd::cxx::tree::traits< OrderID_type, char > OrderID_traits;

    const OrderID_type&
    OrderID () const;

    OrderID_type&
    OrderID ();

    void
    OrderID (const OrderID_type& x);

    void
    OrderID (::std::unique_ptr< OrderID_type > p);

    // RunDate
    //
    typedef ::xml_schema::date RunDate_type;
    typedef ::xsd::cxx::tree::traits< RunDate_type, char > RunDate_traits;

    const RunDate_type&
    RunDate () const;

    RunDate_type&
    RunDate ();

    void
    RunDate (const RunDate_type& x);

    void
    RunDate (::std::unique_ptr< RunDate_type > p);

    // Constructors.
    //
    DataAdvice (const RollYear_type&,
                const OwnershipYear_type&,
                const RunType_type&,
                const StartDate_type&,
                const EndDate_type&,
                const RequestID_type&,
                const OrderID_type&,
                const RunDate_type&);

    DataAdvice (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    DataAdvice (const DataAdvice& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual DataAdvice*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DataAdvice&
    operator= (const DataAdvice& x);

    virtual 
    ~DataAdvice ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< RollYear_type > RollYear_;
    ::xsd::cxx::tree::one< OwnershipYear_type > OwnershipYear_;
    ::xsd::cxx::tree::one< RunType_type > RunType_;
    ::xsd::cxx::tree::one< StartDate_type > StartDate_;
    ::xsd::cxx::tree::one< EndDate_type > EndDate_;
    AssessmentAreas_optional AssessmentAreas_;
    ReportSummary_optional ReportSummary_;
    ::xsd::cxx::tree::one< Version_type > Version_;
    static const Version_type Version_default_value_;
    ::xsd::cxx::tree::one< RequestID_type > RequestID_;
    ::xsd::cxx::tree::one< OrderID_type > OrderID_;
    ::xsd::cxx::tree::one< RunDate_type > RunDate_;
  };

  class Version: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Version ();

    Version (const char*);

    Version (const ::std::string&);

    Version (const ::xml_schema::string&);

    Version (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Version (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Version (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    Version (const Version& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual Version*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Version ();
  };

  class RunType: public ::xml_schema::string
  {
    public:
    enum value
    {
      COMP,
      REVD,
      RVSP,
      GRNT,
      SUPP,
      PAAB,
      DECISION,
      MONTHLY,
      WEEKLY,
      OTHER
    };

    RunType (value v);

    RunType (const char* v);

    RunType (const ::std::string& v);

    RunType (const ::xml_schema::string& v);

    RunType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    RunType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    RunType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    RunType (const RunType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual RunType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    RunType&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_RunType_convert ();
    }

    protected:
    value
    _xsd_RunType_convert () const;

    public:
    static const char* const _xsd_RunType_literals_[10];
    static const value _xsd_RunType_indexes_[10];
  };

  class DeliverySummary: public ::xml_schema::type
  {
    public:
    // TotalFolioCount
    //
    typedef ::xml_schema::integer TotalFolioCount_type;
    typedef ::xsd::cxx::tree::optional< TotalFolioCount_type > TotalFolioCount_optional;
    typedef ::xsd::cxx::tree::traits< TotalFolioCount_type, char > TotalFolioCount_traits;

    const TotalFolioCount_optional&
    TotalFolioCount () const;

    TotalFolioCount_optional&
    TotalFolioCount ();

    void
    TotalFolioCount (const TotalFolioCount_type& x);

    void
    TotalFolioCount (const TotalFolioCount_optional& x);

    // TaxableFolioCount
    //
    typedef ::xml_schema::integer TaxableFolioCount_type;
    typedef ::xsd::cxx::tree::optional< TaxableFolioCount_type > TaxableFolioCount_optional;
    typedef ::xsd::cxx::tree::traits< TaxableFolioCount_type, char > TaxableFolioCount_traits;

    const TaxableFolioCount_optional&
    TaxableFolioCount () const;

    TaxableFolioCount_optional&
    TaxableFolioCount ();

    void
    TaxableFolioCount (const TaxableFolioCount_type& x);

    void
    TaxableFolioCount (const TaxableFolioCount_optional& x);

    // TaxExemptFolioCount
    //
    typedef ::xml_schema::integer TaxExemptFolioCount_type;
    typedef ::xsd::cxx::tree::optional< TaxExemptFolioCount_type > TaxExemptFolioCount_optional;
    typedef ::xsd::cxx::tree::traits< TaxExemptFolioCount_type, char > TaxExemptFolioCount_traits;

    const TaxExemptFolioCount_optional&
    TaxExemptFolioCount () const;

    TaxExemptFolioCount_optional&
    TaxExemptFolioCount ();

    void
    TaxExemptFolioCount (const TaxExemptFolioCount_type& x);

    void
    TaxExemptFolioCount (const TaxExemptFolioCount_optional& x);

    // TotalGrossValues
    //
    typedef ::dataadvice::FolioGroupValues TotalGrossValues_type;
    typedef ::xsd::cxx::tree::optional< TotalGrossValues_type > TotalGrossValues_optional;
    typedef ::xsd::cxx::tree::traits< TotalGrossValues_type, char > TotalGrossValues_traits;

    const TotalGrossValues_optional&
    TotalGrossValues () const;

    TotalGrossValues_optional&
    TotalGrossValues ();

    void
    TotalGrossValues (const TotalGrossValues_type& x);

    void
    TotalGrossValues (const TotalGrossValues_optional& x);

    void
    TotalGrossValues (::std::unique_ptr< TotalGrossValues_type > p);

    // TotalTaxExemptValues
    //
    typedef ::dataadvice::FolioGroupValues TotalTaxExemptValues_type;
    typedef ::xsd::cxx::tree::optional< TotalTaxExemptValues_type > TotalTaxExemptValues_optional;
    typedef ::xsd::cxx::tree::traits< TotalTaxExemptValues_type, char > TotalTaxExemptValues_traits;

    const TotalTaxExemptValues_optional&
    TotalTaxExemptValues () const;

    TotalTaxExemptValues_optional&
    TotalTaxExemptValues ();

    void
    TotalTaxExemptValues (const TotalTaxExemptValues_type& x);

    void
    TotalTaxExemptValues (const TotalTaxExemptValues_optional& x);

    void
    TotalTaxExemptValues (::std::unique_ptr< TotalTaxExemptValues_type > p);

    // TotalNetValues
    //
    typedef ::dataadvice::FolioGroupValues TotalNetValues_type;
    typedef ::xsd::cxx::tree::optional< TotalNetValues_type > TotalNetValues_optional;
    typedef ::xsd::cxx::tree::traits< TotalNetValues_type, char > TotalNetValues_traits;

    const TotalNetValues_optional&
    TotalNetValues () const;

    TotalNetValues_optional&
    TotalNetValues ();

    void
    TotalNetValues (const TotalNetValues_type& x);

    void
    TotalNetValues (const TotalNetValues_optional& x);

    void
    TotalNetValues (::std::unique_ptr< TotalNetValues_type > p);

    // GeneralValues
    //
    typedef ::dataadvice::PropertyClassValuesCollection GeneralValues_type;
    typedef ::xsd::cxx::tree::optional< GeneralValues_type > GeneralValues_optional;
    typedef ::xsd::cxx::tree::traits< GeneralValues_type, char > GeneralValues_traits;

    const GeneralValues_optional&
    GeneralValues () const;

    GeneralValues_optional&
    GeneralValues ();

    void
    GeneralValues (const GeneralValues_type& x);

    void
    GeneralValues (const GeneralValues_optional& x);

    void
    GeneralValues (::std::unique_ptr< GeneralValues_type > p);

    // BCTransitValues
    //
    typedef ::dataadvice::PropertyClassValuesCollection BCTransitValues_type;
    typedef ::xsd::cxx::tree::optional< BCTransitValues_type > BCTransitValues_optional;
    typedef ::xsd::cxx::tree::traits< BCTransitValues_type, char > BCTransitValues_traits;

    const BCTransitValues_optional&
    BCTransitValues () const;

    BCTransitValues_optional&
    BCTransitValues ();

    void
    BCTransitValues (const BCTransitValues_type& x);

    void
    BCTransitValues (const BCTransitValues_optional& x);

    void
    BCTransitValues (::std::unique_ptr< BCTransitValues_type > p);

    // SchoolValues
    //
    typedef ::dataadvice::PropertyClassValuesCollection SchoolValues_type;
    typedef ::xsd::cxx::tree::optional< SchoolValues_type > SchoolValues_optional;
    typedef ::xsd::cxx::tree::traits< SchoolValues_type, char > SchoolValues_traits;

    const SchoolValues_optional&
    SchoolValues () const;

    SchoolValues_optional&
    SchoolValues ();

    void
    SchoolValues (const SchoolValues_type& x);

    void
    SchoolValues (const SchoolValues_optional& x);

    void
    SchoolValues (::std::unique_ptr< SchoolValues_type > p);

    // AmendmentReasonCounts
    //
    typedef ::dataadvice::AmendmentReasonCountCollection AmendmentReasonCounts_type;
    typedef ::xsd::cxx::tree::optional< AmendmentReasonCounts_type > AmendmentReasonCounts_optional;
    typedef ::xsd::cxx::tree::traits< AmendmentReasonCounts_type, char > AmendmentReasonCounts_traits;

    const AmendmentReasonCounts_optional&
    AmendmentReasonCounts () const;

    AmendmentReasonCounts_optional&
    AmendmentReasonCounts ();

    void
    AmendmentReasonCounts (const AmendmentReasonCounts_type& x);

    void
    AmendmentReasonCounts (const AmendmentReasonCounts_optional& x);

    void
    AmendmentReasonCounts (::std::unique_ptr< AmendmentReasonCounts_type > p);

    // DeleteReasonCounts
    //
    typedef ::dataadvice::DeleteReasonCountCollection DeleteReasonCounts_type;
    typedef ::xsd::cxx::tree::optional< DeleteReasonCounts_type > DeleteReasonCounts_optional;
    typedef ::xsd::cxx::tree::traits< DeleteReasonCounts_type, char > DeleteReasonCounts_traits;

    const DeleteReasonCounts_optional&
    DeleteReasonCounts () const;

    DeleteReasonCounts_optional&
    DeleteReasonCounts ();

    void
    DeleteReasonCounts (const DeleteReasonCounts_type& x);

    void
    DeleteReasonCounts (const DeleteReasonCounts_optional& x);

    void
    DeleteReasonCounts (::std::unique_ptr< DeleteReasonCounts_type > p);

    // Constructors.
    //
    DeliverySummary ();

    DeliverySummary (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    DeliverySummary (const DeliverySummary& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual DeliverySummary*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DeliverySummary&
    operator= (const DeliverySummary& x);

    virtual 
    ~DeliverySummary ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TotalFolioCount_optional TotalFolioCount_;
    TaxableFolioCount_optional TaxableFolioCount_;
    TaxExemptFolioCount_optional TaxExemptFolioCount_;
    TotalGrossValues_optional TotalGrossValues_;
    TotalTaxExemptValues_optional TotalTaxExemptValues_;
    TotalNetValues_optional TotalNetValues_;
    GeneralValues_optional GeneralValues_;
    BCTransitValues_optional BCTransitValues_;
    SchoolValues_optional SchoolValues_;
    AmendmentReasonCounts_optional AmendmentReasonCounts_;
    DeleteReasonCounts_optional DeleteReasonCounts_;
  };

  class AmendmentReasonCountCollection: public ::xml_schema::type
  {
    public:
    // AmendmentReasonCount
    //
    typedef ::dataadvice::AmendmentReasonCount AmendmentReasonCount_type;
    typedef ::xsd::cxx::tree::sequence< AmendmentReasonCount_type > AmendmentReasonCount_sequence;
    typedef AmendmentReasonCount_sequence::iterator AmendmentReasonCount_iterator;
    typedef AmendmentReasonCount_sequence::const_iterator AmendmentReasonCount_const_iterator;
    typedef ::xsd::cxx::tree::traits< AmendmentReasonCount_type, char > AmendmentReasonCount_traits;

    const AmendmentReasonCount_sequence&
    AmendmentReasonCount () const;

    AmendmentReasonCount_sequence&
    AmendmentReasonCount ();

    void
    AmendmentReasonCount (const AmendmentReasonCount_sequence& s);

    // Constructors.
    //
    AmendmentReasonCountCollection ();

    AmendmentReasonCountCollection (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    AmendmentReasonCountCollection (const AmendmentReasonCountCollection& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

    virtual AmendmentReasonCountCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AmendmentReasonCountCollection&
    operator= (const AmendmentReasonCountCollection& x);

    virtual 
    ~AmendmentReasonCountCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AmendmentReasonCount_sequence AmendmentReasonCount_;
  };

  class AmendmentReasonCount: public ::xml_schema::type
  {
    public:
    // AmendmentReasonCode
    //
    typedef ::dataadvice::LookupCode AmendmentReasonCode_type;
    typedef ::xsd::cxx::tree::traits< AmendmentReasonCode_type, char > AmendmentReasonCode_traits;

    const AmendmentReasonCode_type&
    AmendmentReasonCode () const;

    AmendmentReasonCode_type&
    AmendmentReasonCode ();

    void
    AmendmentReasonCode (const AmendmentReasonCode_type& x);

    void
    AmendmentReasonCode (::std::unique_ptr< AmendmentReasonCode_type > p);

    // AmendmentReasonDescription
    //
    typedef ::dataadvice::String255 AmendmentReasonDescription_type;
    typedef ::xsd::cxx::tree::optional< AmendmentReasonDescription_type > AmendmentReasonDescription_optional;
    typedef ::xsd::cxx::tree::traits< AmendmentReasonDescription_type, char > AmendmentReasonDescription_traits;

    const AmendmentReasonDescription_optional&
    AmendmentReasonDescription () const;

    AmendmentReasonDescription_optional&
    AmendmentReasonDescription ();

    void
    AmendmentReasonDescription (const AmendmentReasonDescription_type& x);

    void
    AmendmentReasonDescription (const AmendmentReasonDescription_optional& x);

    void
    AmendmentReasonDescription (::std::unique_ptr< AmendmentReasonDescription_type > p);

    // FolioCount
    //
    typedef ::xml_schema::integer FolioCount_type;
    typedef ::xsd::cxx::tree::traits< FolioCount_type, char > FolioCount_traits;

    const FolioCount_type&
    FolioCount () const;

    FolioCount_type&
    FolioCount ();

    void
    FolioCount (const FolioCount_type& x);

    // Constructors.
    //
    AmendmentReasonCount (const AmendmentReasonCode_type&,
                          const FolioCount_type&);

    AmendmentReasonCount (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    AmendmentReasonCount (const AmendmentReasonCount& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual AmendmentReasonCount*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AmendmentReasonCount&
    operator= (const AmendmentReasonCount& x);

    virtual 
    ~AmendmentReasonCount ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AmendmentReasonCode_type > AmendmentReasonCode_;
    AmendmentReasonDescription_optional AmendmentReasonDescription_;
    ::xsd::cxx::tree::one< FolioCount_type > FolioCount_;
  };

  class DeleteReasonCountCollection: public ::xml_schema::type
  {
    public:
    // DeleteReasonCount
    //
    typedef ::dataadvice::DeleteReasonCount DeleteReasonCount_type;
    typedef ::xsd::cxx::tree::sequence< DeleteReasonCount_type > DeleteReasonCount_sequence;
    typedef DeleteReasonCount_sequence::iterator DeleteReasonCount_iterator;
    typedef DeleteReasonCount_sequence::const_iterator DeleteReasonCount_const_iterator;
    typedef ::xsd::cxx::tree::traits< DeleteReasonCount_type, char > DeleteReasonCount_traits;

    const DeleteReasonCount_sequence&
    DeleteReasonCount () const;

    DeleteReasonCount_sequence&
    DeleteReasonCount ();

    void
    DeleteReasonCount (const DeleteReasonCount_sequence& s);

    // Constructors.
    //
    DeleteReasonCountCollection ();

    DeleteReasonCountCollection (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    DeleteReasonCountCollection (const DeleteReasonCountCollection& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual DeleteReasonCountCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DeleteReasonCountCollection&
    operator= (const DeleteReasonCountCollection& x);

    virtual 
    ~DeleteReasonCountCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DeleteReasonCount_sequence DeleteReasonCount_;
  };

  class DeleteReasonCount: public ::xml_schema::type
  {
    public:
    // DeleteReasonCode
    //
    typedef ::dataadvice::LookupCode DeleteReasonCode_type;
    typedef ::xsd::cxx::tree::traits< DeleteReasonCode_type, char > DeleteReasonCode_traits;

    const DeleteReasonCode_type&
    DeleteReasonCode () const;

    DeleteReasonCode_type&
    DeleteReasonCode ();

    void
    DeleteReasonCode (const DeleteReasonCode_type& x);

    void
    DeleteReasonCode (::std::unique_ptr< DeleteReasonCode_type > p);

    // DeleteReasonDescription
    //
    typedef ::dataadvice::String255 DeleteReasonDescription_type;
    typedef ::xsd::cxx::tree::optional< DeleteReasonDescription_type > DeleteReasonDescription_optional;
    typedef ::xsd::cxx::tree::traits< DeleteReasonDescription_type, char > DeleteReasonDescription_traits;

    const DeleteReasonDescription_optional&
    DeleteReasonDescription () const;

    DeleteReasonDescription_optional&
    DeleteReasonDescription ();

    void
    DeleteReasonDescription (const DeleteReasonDescription_type& x);

    void
    DeleteReasonDescription (const DeleteReasonDescription_optional& x);

    void
    DeleteReasonDescription (::std::unique_ptr< DeleteReasonDescription_type > p);

    // FolioCount
    //
    typedef ::xml_schema::integer FolioCount_type;
    typedef ::xsd::cxx::tree::traits< FolioCount_type, char > FolioCount_traits;

    const FolioCount_type&
    FolioCount () const;

    FolioCount_type&
    FolioCount ();

    void
    FolioCount (const FolioCount_type& x);

    // Constructors.
    //
    DeleteReasonCount (const DeleteReasonCode_type&,
                       const FolioCount_type&);

    DeleteReasonCount (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    DeleteReasonCount (const DeleteReasonCount& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual DeleteReasonCount*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    DeleteReasonCount&
    operator= (const DeleteReasonCount& x);

    virtual 
    ~DeleteReasonCount ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< DeleteReasonCode_type > DeleteReasonCode_;
    DeleteReasonDescription_optional DeleteReasonDescription_;
    ::xsd::cxx::tree::one< FolioCount_type > FolioCount_;
  };

  class AssessmentAreaCollection: public ::xml_schema::type
  {
    public:
    // AssessmentArea
    //
    typedef ::dataadvice::AssessmentArea AssessmentArea_type;
    typedef ::xsd::cxx::tree::sequence< AssessmentArea_type > AssessmentArea_sequence;
    typedef AssessmentArea_sequence::iterator AssessmentArea_iterator;
    typedef AssessmentArea_sequence::const_iterator AssessmentArea_const_iterator;
    typedef ::xsd::cxx::tree::traits< AssessmentArea_type, char > AssessmentArea_traits;

    const AssessmentArea_sequence&
    AssessmentArea () const;

    AssessmentArea_sequence&
    AssessmentArea ();

    void
    AssessmentArea (const AssessmentArea_sequence& s);

    // Constructors.
    //
    AssessmentAreaCollection ();

    AssessmentAreaCollection (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    AssessmentAreaCollection (const AssessmentAreaCollection& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual AssessmentAreaCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AssessmentAreaCollection&
    operator= (const AssessmentAreaCollection& x);

    virtual 
    ~AssessmentAreaCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AssessmentArea_sequence AssessmentArea_;
  };

  class AssessmentArea: public ::xml_schema::type
  {
    public:
    // AssessmentAreaCode
    //
    typedef ::dataadvice::AssessmentAreaCode AssessmentAreaCode_type;
    typedef ::xsd::cxx::tree::traits< AssessmentAreaCode_type, char > AssessmentAreaCode_traits;

    const AssessmentAreaCode_type&
    AssessmentAreaCode () const;

    AssessmentAreaCode_type&
    AssessmentAreaCode ();

    void
    AssessmentAreaCode (const AssessmentAreaCode_type& x);

    void
    AssessmentAreaCode (::std::unique_ptr< AssessmentAreaCode_type > p);

    // AssessmentAreaDescription
    //
    typedef ::dataadvice::String255 AssessmentAreaDescription_type;
    typedef ::xsd::cxx::tree::optional< AssessmentAreaDescription_type > AssessmentAreaDescription_optional;
    typedef ::xsd::cxx::tree::traits< AssessmentAreaDescription_type, char > AssessmentAreaDescription_traits;

    const AssessmentAreaDescription_optional&
    AssessmentAreaDescription () const;

    AssessmentAreaDescription_optional&
    AssessmentAreaDescription ();

    void
    AssessmentAreaDescription (const AssessmentAreaDescription_type& x);

    void
    AssessmentAreaDescription (const AssessmentAreaDescription_optional& x);

    void
    AssessmentAreaDescription (::std::unique_ptr< AssessmentAreaDescription_type > p);

    // Jurisdictions
    //
    typedef ::dataadvice::JurisdictionCollection Jurisdictions_type;
    typedef ::xsd::cxx::tree::optional< Jurisdictions_type > Jurisdictions_optional;
    typedef ::xsd::cxx::tree::traits< Jurisdictions_type, char > Jurisdictions_traits;

    const Jurisdictions_optional&
    Jurisdictions () const;

    Jurisdictions_optional&
    Jurisdictions ();

    void
    Jurisdictions (const Jurisdictions_type& x);

    void
    Jurisdictions (const Jurisdictions_optional& x);

    void
    Jurisdictions (::std::unique_ptr< Jurisdictions_type > p);

    // AreaSummary
    //
    typedef ::dataadvice::DeliverySummary AreaSummary_type;
    typedef ::xsd::cxx::tree::optional< AreaSummary_type > AreaSummary_optional;
    typedef ::xsd::cxx::tree::traits< AreaSummary_type, char > AreaSummary_traits;

    const AreaSummary_optional&
    AreaSummary () const;

    AreaSummary_optional&
    AreaSummary ();

    void
    AreaSummary (const AreaSummary_type& x);

    void
    AreaSummary (const AreaSummary_optional& x);

    void
    AreaSummary (::std::unique_ptr< AreaSummary_type > p);

    // Constructors.
    //
    AssessmentArea (const AssessmentAreaCode_type&);

    AssessmentArea (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    AssessmentArea (const AssessmentArea& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual AssessmentArea*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    AssessmentArea&
    operator= (const AssessmentArea& x);

    virtual 
    ~AssessmentArea ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AssessmentAreaCode_type > AssessmentAreaCode_;
    AssessmentAreaDescription_optional AssessmentAreaDescription_;
    Jurisdictions_optional Jurisdictions_;
    AreaSummary_optional AreaSummary_;
  };

  class AssessmentAreaCode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    AssessmentAreaCode ();

    AssessmentAreaCode (const char*);

    AssessmentAreaCode (const ::std::string&);

    AssessmentAreaCode (const ::xml_schema::string&);

    AssessmentAreaCode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AssessmentAreaCode (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AssessmentAreaCode (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    AssessmentAreaCode (const AssessmentAreaCode& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual AssessmentAreaCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~AssessmentAreaCode ();
  };

  class JurisdictionCollection: public ::xml_schema::type
  {
    public:
    // Jurisdiction
    //
    typedef ::dataadvice::Jurisdiction Jurisdiction_type;
    typedef ::xsd::cxx::tree::sequence< Jurisdiction_type > Jurisdiction_sequence;
    typedef Jurisdiction_sequence::iterator Jurisdiction_iterator;
    typedef Jurisdiction_sequence::const_iterator Jurisdiction_const_iterator;
    typedef ::xsd::cxx::tree::traits< Jurisdiction_type, char > Jurisdiction_traits;

    const Jurisdiction_sequence&
    Jurisdiction () const;

    Jurisdiction_sequence&
    Jurisdiction ();

    void
    Jurisdiction (const Jurisdiction_sequence& s);

    // Constructors.
    //
    JurisdictionCollection ();

    JurisdictionCollection (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    JurisdictionCollection (const JurisdictionCollection& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual JurisdictionCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    JurisdictionCollection&
    operator= (const JurisdictionCollection& x);

    virtual 
    ~JurisdictionCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Jurisdiction_sequence Jurisdiction_;
  };

  class Jurisdiction: public ::xml_schema::type
  {
    public:
    // JurisdictionCode
    //
    typedef ::dataadvice::JurisdictionCode JurisdictionCode_type;
    typedef ::xsd::cxx::tree::traits< JurisdictionCode_type, char > JurisdictionCode_traits;

    const JurisdictionCode_type&
    JurisdictionCode () const;

    JurisdictionCode_type&
    JurisdictionCode ();

    void
    JurisdictionCode (const JurisdictionCode_type& x);

    void
    JurisdictionCode (::std::unique_ptr< JurisdictionCode_type > p);

    // JurisdictionDescription
    //
    typedef ::dataadvice::String255 JurisdictionDescription_type;
    typedef ::xsd::cxx::tree::optional< JurisdictionDescription_type > JurisdictionDescription_optional;
    typedef ::xsd::cxx::tree::traits< JurisdictionDescription_type, char > JurisdictionDescription_traits;

    const JurisdictionDescription_optional&
    JurisdictionDescription () const;

    JurisdictionDescription_optional&
    JurisdictionDescription ();

    void
    JurisdictionDescription (const JurisdictionDescription_type& x);

    void
    JurisdictionDescription (const JurisdictionDescription_optional& x);

    void
    JurisdictionDescription (::std::unique_ptr< JurisdictionDescription_type > p);

    // FolioRecords
    //
    typedef ::dataadvice::FolioRecordCollection FolioRecords_type;
    typedef ::xsd::cxx::tree::optional< FolioRecords_type > FolioRecords_optional;
    typedef ::xsd::cxx::tree::traits< FolioRecords_type, char > FolioRecords_traits;

    const FolioRecords_optional&
    FolioRecords () const;

    FolioRecords_optional&
    FolioRecords ();

    void
    FolioRecords (const FolioRecords_type& x);

    void
    FolioRecords (const FolioRecords_optional& x);

    void
    FolioRecords (::std::unique_ptr< FolioRecords_type > p);

    // JurisdictionSummary
    //
    typedef ::dataadvice::DeliverySummary JurisdictionSummary_type;
    typedef ::xsd::cxx::tree::optional< JurisdictionSummary_type > JurisdictionSummary_optional;
    typedef ::xsd::cxx::tree::traits< JurisdictionSummary_type, char > JurisdictionSummary_traits;

    const JurisdictionSummary_optional&
    JurisdictionSummary () const;

    JurisdictionSummary_optional&
    JurisdictionSummary ();

    void
    JurisdictionSummary (const JurisdictionSummary_type& x);

    void
    JurisdictionSummary (const JurisdictionSummary_optional& x);

    void
    JurisdictionSummary (::std::unique_ptr< JurisdictionSummary_type > p);

    // Constructors.
    //
    Jurisdiction (const JurisdictionCode_type&);

    Jurisdiction (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    Jurisdiction (const Jurisdiction& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual Jurisdiction*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Jurisdiction&
    operator= (const Jurisdiction& x);

    virtual 
    ~Jurisdiction ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< JurisdictionCode_type > JurisdictionCode_;
    JurisdictionDescription_optional JurisdictionDescription_;
    FolioRecords_optional FolioRecords_;
    JurisdictionSummary_optional JurisdictionSummary_;
  };

  class JurisdictionCode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    JurisdictionCode ();

    JurisdictionCode (const char*);

    JurisdictionCode (const ::std::string&);

    JurisdictionCode (const ::xml_schema::string&);

    JurisdictionCode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    JurisdictionCode (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    JurisdictionCode (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    JurisdictionCode (const JurisdictionCode& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual JurisdictionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~JurisdictionCode ();
  };

  class FolioGroupValues: public ::xml_schema::type
  {
    public:
    // LandValue
    //
    typedef ::xml_schema::decimal LandValue_type;
    typedef ::xsd::cxx::tree::traits< LandValue_type, char, ::xsd::cxx::tree::schema_type::decimal > LandValue_traits;

    const LandValue_type&
    LandValue () const;

    LandValue_type&
    LandValue ();

    void
    LandValue (const LandValue_type& x);

    // ImprovementValue
    //
    typedef ::xml_schema::decimal ImprovementValue_type;
    typedef ::xsd::cxx::tree::traits< ImprovementValue_type, char, ::xsd::cxx::tree::schema_type::decimal > ImprovementValue_traits;

    const ImprovementValue_type&
    ImprovementValue () const;

    ImprovementValue_type&
    ImprovementValue ();

    void
    ImprovementValue (const ImprovementValue_type& x);

    // ParkingAreaValue
    //
    typedef ::xml_schema::decimal ParkingAreaValue_type;
    typedef ::xsd::cxx::tree::optional< ParkingAreaValue_type > ParkingAreaValue_optional;
    typedef ::xsd::cxx::tree::traits< ParkingAreaValue_type, char, ::xsd::cxx::tree::schema_type::decimal > ParkingAreaValue_traits;

    const ParkingAreaValue_optional&
    ParkingAreaValue () const;

    ParkingAreaValue_optional&
    ParkingAreaValue ();

    void
    ParkingAreaValue (const ParkingAreaValue_type& x);

    void
    ParkingAreaValue (const ParkingAreaValue_optional& x);

    // Constructors.
    //
    FolioGroupValues (const LandValue_type&,
                      const ImprovementValue_type&);

    FolioGroupValues (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    FolioGroupValues (const FolioGroupValues& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual FolioGroupValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioGroupValues&
    operator= (const FolioGroupValues& x);

    virtual 
    ~FolioGroupValues ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< LandValue_type > LandValue_;
    ::xsd::cxx::tree::one< ImprovementValue_type > ImprovementValue_;
    ParkingAreaValue_optional ParkingAreaValue_;
  };

  class FolioRecordCollection: public ::xml_schema::type
  {
    public:
    // FolioRecord
    //
    typedef ::dataadvice::FolioRecord FolioRecord_type;
    typedef ::xsd::cxx::tree::sequence< FolioRecord_type > FolioRecord_sequence;
    typedef FolioRecord_sequence::iterator FolioRecord_iterator;
    typedef FolioRecord_sequence::const_iterator FolioRecord_const_iterator;
    typedef ::xsd::cxx::tree::traits< FolioRecord_type, char > FolioRecord_traits;

    const FolioRecord_sequence&
    FolioRecord () const;

    FolioRecord_sequence&
    FolioRecord ();

    void
    FolioRecord (const FolioRecord_sequence& s);

    // Constructors.
    //
    FolioRecordCollection ();

    FolioRecordCollection (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    FolioRecordCollection (const FolioRecordCollection& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

    virtual FolioRecordCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioRecordCollection&
    operator= (const FolioRecordCollection& x);

    virtual 
    ~FolioRecordCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FolioRecord_sequence FolioRecord_;
  };

  class FolioRecord: public ::xml_schema::type
  {
    public:
    // RollNumber
    //
    typedef ::dataadvice::FolioRollNumber RollNumber_type;
    typedef ::xsd::cxx::tree::traits< RollNumber_type, char > RollNumber_traits;

    const RollNumber_type&
    RollNumber () const;

    RollNumber_type&
    RollNumber ();

    void
    RollNumber (const RollNumber_type& x);

    void
    RollNumber (::std::unique_ptr< RollNumber_type > p);

    // FolioStatus
    //
    typedef ::dataadvice::FolioLookupCodeItem FolioStatus_type;
    typedef ::xsd::cxx::tree::optional< FolioStatus_type > FolioStatus_optional;
    typedef ::xsd::cxx::tree::traits< FolioStatus_type, char > FolioStatus_traits;

    const FolioStatus_optional&
    FolioStatus () const;

    FolioStatus_optional&
    FolioStatus ();

    void
    FolioStatus (const FolioStatus_type& x);

    void
    FolioStatus (const FolioStatus_optional& x);

    void
    FolioStatus (::std::unique_ptr< FolioStatus_type > p);

    // FolioStatusDescription
    //
    typedef ::dataadvice::FolioString255Item FolioStatusDescription_type;
    typedef ::xsd::cxx::tree::optional< FolioStatusDescription_type > FolioStatusDescription_optional;
    typedef ::xsd::cxx::tree::traits< FolioStatusDescription_type, char > FolioStatusDescription_traits;

    const FolioStatusDescription_optional&
    FolioStatusDescription () const;

    FolioStatusDescription_optional&
    FolioStatusDescription ();

    void
    FolioStatusDescription (const FolioStatusDescription_type& x);

    void
    FolioStatusDescription (const FolioStatusDescription_optional& x);

    void
    FolioStatusDescription (::std::unique_ptr< FolioStatusDescription_type > p);

    // FolioAction
    //
    typedef ::dataadvice::FolioAction FolioAction_type;
    typedef ::xsd::cxx::tree::optional< FolioAction_type > FolioAction_optional;
    typedef ::xsd::cxx::tree::traits< FolioAction_type, char > FolioAction_traits;

    const FolioAction_optional&
    FolioAction () const;

    FolioAction_optional&
    FolioAction ();

    void
    FolioAction (const FolioAction_type& x);

    void
    FolioAction (const FolioAction_optional& x);

    void
    FolioAction (::std::unique_ptr< FolioAction_type > p);

    // FolioAddresses
    //
    typedef ::dataadvice::FolioAddressCollection FolioAddresses_type;
    typedef ::xsd::cxx::tree::optional< FolioAddresses_type > FolioAddresses_optional;
    typedef ::xsd::cxx::tree::traits< FolioAddresses_type, char > FolioAddresses_traits;

    const FolioAddresses_optional&
    FolioAddresses () const;

    FolioAddresses_optional&
    FolioAddresses ();

    void
    FolioAddresses (const FolioAddresses_type& x);

    void
    FolioAddresses (const FolioAddresses_optional& x);

    void
    FolioAddresses (::std::unique_ptr< FolioAddresses_type > p);

    // OwnershipGroups
    //
    typedef ::dataadvice::OwnershipGroupCollection OwnershipGroups_type;
    typedef ::xsd::cxx::tree::optional< OwnershipGroups_type > OwnershipGroups_optional;
    typedef ::xsd::cxx::tree::traits< OwnershipGroups_type, char > OwnershipGroups_traits;

    const OwnershipGroups_optional&
    OwnershipGroups () const;

    OwnershipGroups_optional&
    OwnershipGroups ();

    void
    OwnershipGroups (const OwnershipGroups_type& x);

    void
    OwnershipGroups (const OwnershipGroups_optional& x);

    void
    OwnershipGroups (::std::unique_ptr< OwnershipGroups_type > p);

    // LegalDescriptions
    //
    typedef ::dataadvice::LegalDescriptionCollection LegalDescriptions_type;
    typedef ::xsd::cxx::tree::optional< LegalDescriptions_type > LegalDescriptions_optional;
    typedef ::xsd::cxx::tree::traits< LegalDescriptions_type, char > LegalDescriptions_traits;

    const LegalDescriptions_optional&
    LegalDescriptions () const;

    LegalDescriptions_optional&
    LegalDescriptions ();

    void
    LegalDescriptions (const LegalDescriptions_type& x);

    void
    LegalDescriptions (const LegalDescriptions_optional& x);

    void
    LegalDescriptions (::std::unique_ptr< LegalDescriptions_type > p);

    // FolioDescription
    //
    typedef ::dataadvice::FolioDescription FolioDescription_type;
    typedef ::xsd::cxx::tree::optional< FolioDescription_type > FolioDescription_optional;
    typedef ::xsd::cxx::tree::traits< FolioDescription_type, char > FolioDescription_traits;

    const FolioDescription_optional&
    FolioDescription () const;

    FolioDescription_optional&
    FolioDescription ();

    void
    FolioDescription (const FolioDescription_type& x);

    void
    FolioDescription (const FolioDescription_optional& x);

    void
    FolioDescription (::std::unique_ptr< FolioDescription_type > p);

    // Sales
    //
    typedef ::dataadvice::SaleCollection Sales_type;
    typedef ::xsd::cxx::tree::optional< Sales_type > Sales_optional;
    typedef ::xsd::cxx::tree::traits< Sales_type, char > Sales_traits;

    const Sales_optional&
    Sales () const;

    Sales_optional&
    Sales ();

    void
    Sales (const Sales_type& x);

    void
    Sales (const Sales_optional& x);

    void
    Sales (::std::unique_ptr< Sales_type > p);

    // Values
    //
    typedef ::dataadvice::PropertyValues Values_type;
    typedef ::xsd::cxx::tree::optional< Values_type > Values_optional;
    typedef ::xsd::cxx::tree::traits< Values_type, char > Values_traits;

    const Values_optional&
    Values () const;

    Values_optional&
    Values ();

    void
    Values (const Values_type& x);

    void
    Values (const Values_optional& x);

    void
    Values (::std::unique_ptr< Values_type > p);

    // Amendments
    //
    typedef ::dataadvice::FolioAmendmentCollection Amendments_type;
    typedef ::xsd::cxx::tree::optional< Amendments_type > Amendments_optional;
    typedef ::xsd::cxx::tree::traits< Amendments_type, char > Amendments_traits;

    const Amendments_optional&
    Amendments () const;

    Amendments_optional&
    Amendments ();

    void
    Amendments (const Amendments_type& x);

    void
    Amendments (const Amendments_optional& x);

    void
    Amendments (::std::unique_ptr< Amendments_type > p);

    // MinorTaxing
    //
    typedef ::dataadvice::MinorTaxing MinorTaxing_type;
    typedef ::xsd::cxx::tree::optional< MinorTaxing_type > MinorTaxing_optional;
    typedef ::xsd::cxx::tree::traits< MinorTaxing_type, char > MinorTaxing_traits;

    const MinorTaxing_optional&
    MinorTaxing () const;

    MinorTaxing_optional&
    MinorTaxing ();

    void
    MinorTaxing (const MinorTaxing_type& x);

    void
    MinorTaxing (const MinorTaxing_optional& x);

    void
    MinorTaxing (::std::unique_ptr< MinorTaxing_type > p);

    // Farms
    //
    typedef ::dataadvice::FarmCollection Farms_type;
    typedef ::xsd::cxx::tree::optional< Farms_type > Farms_optional;
    typedef ::xsd::cxx::tree::traits< Farms_type, char > Farms_traits;

    const Farms_optional&
    Farms () const;

    Farms_optional&
    Farms ();

    void
    Farms (const Farms_type& x);

    void
    Farms (const Farms_optional& x);

    void
    Farms (::std::unique_ptr< Farms_type > p);

    // ManufacturedHomes
    //
    typedef ::dataadvice::ManufacturedHomeCollection ManufacturedHomes_type;
    typedef ::xsd::cxx::tree::optional< ManufacturedHomes_type > ManufacturedHomes_optional;
    typedef ::xsd::cxx::tree::traits< ManufacturedHomes_type, char > ManufacturedHomes_traits;

    const ManufacturedHomes_optional&
    ManufacturedHomes () const;

    ManufacturedHomes_optional&
    ManufacturedHomes ();

    void
    ManufacturedHomes (const ManufacturedHomes_type& x);

    void
    ManufacturedHomes (const ManufacturedHomes_optional& x);

    void
    ManufacturedHomes (::std::unique_ptr< ManufacturedHomes_type > p);

    // ManagedForests
    //
    typedef ::dataadvice::ManagedForestCollection ManagedForests_type;
    typedef ::xsd::cxx::tree::optional< ManagedForests_type > ManagedForests_optional;
    typedef ::xsd::cxx::tree::traits< ManagedForests_type, char > ManagedForests_traits;

    const ManagedForests_optional&
    ManagedForests () const;

    ManagedForests_optional&
    ManagedForests ();

    void
    ManagedForests (const ManagedForests_type& x);

    void
    ManagedForests (const ManagedForests_optional& x);

    void
    ManagedForests (::std::unique_ptr< ManagedForests_type > p);

    // OilAndGas
    //
    typedef ::dataadvice::OilAndGasCollection OilAndGas_type;
    typedef ::xsd::cxx::tree::optional< OilAndGas_type > OilAndGas_optional;
    typedef ::xsd::cxx::tree::traits< OilAndGas_type, char > OilAndGas_traits;

    const OilAndGas_optional&
    OilAndGas () const;

    OilAndGas_optional&
    OilAndGas ();

    void
    OilAndGas (const OilAndGas_type& x);

    void
    OilAndGas (const OilAndGas_optional& x);

    void
    OilAndGas (::std::unique_ptr< OilAndGas_type > p);

    // LandCharacteristics
    //
    typedef ::dataadvice::LandCharacteristicCollection LandCharacteristics_type;
    typedef ::xsd::cxx::tree::optional< LandCharacteristics_type > LandCharacteristics_optional;
    typedef ::xsd::cxx::tree::traits< LandCharacteristics_type, char > LandCharacteristics_traits;

    const LandCharacteristics_optional&
    LandCharacteristics () const;

    LandCharacteristics_optional&
    LandCharacteristics ();

    void
    LandCharacteristics (const LandCharacteristics_type& x);

    void
    LandCharacteristics (const LandCharacteristics_optional& x);

    void
    LandCharacteristics (::std::unique_ptr< LandCharacteristics_type > p);

    // Constructors.
    //
    FolioRecord (const RollNumber_type&);

    FolioRecord (::std::unique_ptr< RollNumber_type >);

    FolioRecord (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    FolioRecord (const FolioRecord& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual FolioRecord*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioRecord&
    operator= (const FolioRecord& x);

    virtual 
    ~FolioRecord ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< RollNumber_type > RollNumber_;
    FolioStatus_optional FolioStatus_;
    FolioStatusDescription_optional FolioStatusDescription_;
    FolioAction_optional FolioAction_;
    FolioAddresses_optional FolioAddresses_;
    OwnershipGroups_optional OwnershipGroups_;
    LegalDescriptions_optional LegalDescriptions_;
    FolioDescription_optional FolioDescription_;
    Sales_optional Sales_;
    Values_optional Values_;
    Amendments_optional Amendments_;
    MinorTaxing_optional MinorTaxing_;
    Farms_optional Farms_;
    ManufacturedHomes_optional ManufacturedHomes_;
    ManagedForests_optional ManagedForests_;
    OilAndGas_optional OilAndGas_;
    LandCharacteristics_optional LandCharacteristics_;
  };

  class String32: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    String32 ();

    String32 (const char*);

    String32 (const ::std::string&);

    String32 (const ::xml_schema::string&);

    String32 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    String32 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    String32 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    String32 (const String32& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual String32*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~String32 ();
  };

  class FolioRollNumber: public ::dataadvice::String32
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::String32 OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioRollNumber ();

    FolioRollNumber (const char*);

    FolioRollNumber (const ::std::string&);

    FolioRollNumber (const ::xml_schema::string&);

    FolioRollNumber (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    FolioRollNumber (const FolioRollNumber& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual FolioRollNumber*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioRollNumber&
    operator= (const FolioRollNumber& x);

    virtual 
    ~FolioRollNumber ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class FolioAction: public ::xml_schema::type
  {
    public:
    // FolioAdd
    //
    typedef ::dataadvice::FolioAdd FolioAdd_type;
    typedef ::xsd::cxx::tree::optional< FolioAdd_type > FolioAdd_optional;
    typedef ::xsd::cxx::tree::traits< FolioAdd_type, char > FolioAdd_traits;

    const FolioAdd_optional&
    FolioAdd () const;

    FolioAdd_optional&
    FolioAdd ();

    void
    FolioAdd (const FolioAdd_type& x);

    void
    FolioAdd (const FolioAdd_optional& x);

    void
    FolioAdd (::std::unique_ptr< FolioAdd_type > p);

    // FolioDelete
    //
    typedef ::dataadvice::FolioDelete FolioDelete_type;
    typedef ::xsd::cxx::tree::optional< FolioDelete_type > FolioDelete_optional;
    typedef ::xsd::cxx::tree::traits< FolioDelete_type, char > FolioDelete_traits;

    const FolioDelete_optional&
    FolioDelete () const;

    FolioDelete_optional&
    FolioDelete ();

    void
    FolioDelete (const FolioDelete_type& x);

    void
    FolioDelete (const FolioDelete_optional& x);

    void
    FolioDelete (::std::unique_ptr< FolioDelete_type > p);

    // Constructors.
    //
    FolioAction ();

    FolioAction (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    FolioAction (const FolioAction& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual FolioAction*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioAction&
    operator= (const FolioAction& x);

    virtual 
    ~FolioAction ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FolioAdd_optional FolioAdd_;
    FolioDelete_optional FolioDelete_;
  };

  class FolioAdd: public ::xml_schema::type
  {
    public:
    // FolioRenumber
    //
    typedef ::dataadvice::FolioRenumber FolioRenumber_type;
    typedef ::xsd::cxx::tree::optional< FolioRenumber_type > FolioRenumber_optional;
    typedef ::xsd::cxx::tree::traits< FolioRenumber_type, char > FolioRenumber_traits;

    const FolioRenumber_optional&
    FolioRenumber () const;

    FolioRenumber_optional&
    FolioRenumber ();

    void
    FolioRenumber (const FolioRenumber_type& x);

    void
    FolioRenumber (const FolioRenumber_optional& x);

    void
    FolioRenumber (::std::unique_ptr< FolioRenumber_type > p);

    // Constructors.
    //
    FolioAdd ();

    FolioAdd (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    FolioAdd (const FolioAdd& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual FolioAdd*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioAdd&
    operator= (const FolioAdd& x);

    virtual 
    ~FolioAdd ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FolioRenumber_optional FolioRenumber_;
  };

  class FolioDelete: public ::xml_schema::type
  {
    public:
    // FolioRenumber
    //
    typedef ::dataadvice::FolioRenumber FolioRenumber_type;
    typedef ::xsd::cxx::tree::optional< FolioRenumber_type > FolioRenumber_optional;
    typedef ::xsd::cxx::tree::traits< FolioRenumber_type, char > FolioRenumber_traits;

    const FolioRenumber_optional&
    FolioRenumber () const;

    FolioRenumber_optional&
    FolioRenumber ();

    void
    FolioRenumber (const FolioRenumber_type& x);

    void
    FolioRenumber (const FolioRenumber_optional& x);

    void
    FolioRenumber (::std::unique_ptr< FolioRenumber_type > p);

    // DeleteReasonCode
    //
    typedef ::dataadvice::LookupCode DeleteReasonCode_type;
    typedef ::xsd::cxx::tree::optional< DeleteReasonCode_type > DeleteReasonCode_optional;
    typedef ::xsd::cxx::tree::traits< DeleteReasonCode_type, char > DeleteReasonCode_traits;

    const DeleteReasonCode_optional&
    DeleteReasonCode () const;

    DeleteReasonCode_optional&
    DeleteReasonCode ();

    void
    DeleteReasonCode (const DeleteReasonCode_type& x);

    void
    DeleteReasonCode (const DeleteReasonCode_optional& x);

    void
    DeleteReasonCode (::std::unique_ptr< DeleteReasonCode_type > p);

    // DeleteReasonDescription
    //
    typedef ::dataadvice::String255 DeleteReasonDescription_type;
    typedef ::xsd::cxx::tree::optional< DeleteReasonDescription_type > DeleteReasonDescription_optional;
    typedef ::xsd::cxx::tree::traits< DeleteReasonDescription_type, char > DeleteReasonDescription_traits;

    const DeleteReasonDescription_optional&
    DeleteReasonDescription () const;

    DeleteReasonDescription_optional&
    DeleteReasonDescription ();

    void
    DeleteReasonDescription (const DeleteReasonDescription_type& x);

    void
    DeleteReasonDescription (const DeleteReasonDescription_optional& x);

    void
    DeleteReasonDescription (::std::unique_ptr< DeleteReasonDescription_type > p);

    // Constructors.
    //
    FolioDelete ();

    FolioDelete (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    FolioDelete (const FolioDelete& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual FolioDelete*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioDelete&
    operator= (const FolioDelete& x);

    virtual 
    ~FolioDelete ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FolioRenumber_optional FolioRenumber_;
    DeleteReasonCode_optional DeleteReasonCode_;
    DeleteReasonDescription_optional DeleteReasonDescription_;
  };

  class FolioRenumber: public ::xml_schema::type
  {
    public:
    // AssessmentAreaCode
    //
    typedef ::dataadvice::AssessmentAreaCode AssessmentAreaCode_type;
    typedef ::xsd::cxx::tree::traits< AssessmentAreaCode_type, char > AssessmentAreaCode_traits;

    const AssessmentAreaCode_type&
    AssessmentAreaCode () const;

    AssessmentAreaCode_type&
    AssessmentAreaCode ();

    void
    AssessmentAreaCode (const AssessmentAreaCode_type& x);

    void
    AssessmentAreaCode (::std::unique_ptr< AssessmentAreaCode_type > p);

    // AssessmentAreaDescription
    //
    typedef ::dataadvice::String255 AssessmentAreaDescription_type;
    typedef ::xsd::cxx::tree::optional< AssessmentAreaDescription_type > AssessmentAreaDescription_optional;
    typedef ::xsd::cxx::tree::traits< AssessmentAreaDescription_type, char > AssessmentAreaDescription_traits;

    const AssessmentAreaDescription_optional&
    AssessmentAreaDescription () const;

    AssessmentAreaDescription_optional&
    AssessmentAreaDescription ();

    void
    AssessmentAreaDescription (const AssessmentAreaDescription_type& x);

    void
    AssessmentAreaDescription (const AssessmentAreaDescription_optional& x);

    void
    AssessmentAreaDescription (::std::unique_ptr< AssessmentAreaDescription_type > p);

    // JurisdictionCode
    //
    typedef ::dataadvice::JurisdictionCode JurisdictionCode_type;
    typedef ::xsd::cxx::tree::traits< JurisdictionCode_type, char > JurisdictionCode_traits;

    const JurisdictionCode_type&
    JurisdictionCode () const;

    JurisdictionCode_type&
    JurisdictionCode ();

    void
    JurisdictionCode (const JurisdictionCode_type& x);

    void
    JurisdictionCode (::std::unique_ptr< JurisdictionCode_type > p);

    // JurisdictionDescription
    //
    typedef ::dataadvice::String255 JurisdictionDescription_type;
    typedef ::xsd::cxx::tree::optional< JurisdictionDescription_type > JurisdictionDescription_optional;
    typedef ::xsd::cxx::tree::traits< JurisdictionDescription_type, char > JurisdictionDescription_traits;

    const JurisdictionDescription_optional&
    JurisdictionDescription () const;

    JurisdictionDescription_optional&
    JurisdictionDescription ();

    void
    JurisdictionDescription (const JurisdictionDescription_type& x);

    void
    JurisdictionDescription (const JurisdictionDescription_optional& x);

    void
    JurisdictionDescription (::std::unique_ptr< JurisdictionDescription_type > p);

    // RollNumber
    //
    typedef ::dataadvice::String32 RollNumber_type;
    typedef ::xsd::cxx::tree::traits< RollNumber_type, char > RollNumber_traits;

    const RollNumber_type&
    RollNumber () const;

    RollNumber_type&
    RollNumber ();

    void
    RollNumber (const RollNumber_type& x);

    void
    RollNumber (::std::unique_ptr< RollNumber_type > p);

    // Constructors.
    //
    FolioRenumber (const AssessmentAreaCode_type&,
                   const JurisdictionCode_type&,
                   const RollNumber_type&);

    FolioRenumber (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    FolioRenumber (const FolioRenumber& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual FolioRenumber*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioRenumber&
    operator= (const FolioRenumber& x);

    virtual 
    ~FolioRenumber ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< AssessmentAreaCode_type > AssessmentAreaCode_;
    AssessmentAreaDescription_optional AssessmentAreaDescription_;
    ::xsd::cxx::tree::one< JurisdictionCode_type > JurisdictionCode_;
    JurisdictionDescription_optional JurisdictionDescription_;
    ::xsd::cxx::tree::one< RollNumber_type > RollNumber_;
  };

  class FolioItemGroup: public ::xml_schema::type
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // Constructors.
    //
    FolioItemGroup ();

    FolioItemGroup (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    FolioItemGroup (const FolioItemGroup& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual FolioItemGroup*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioItemGroup&
    operator= (const FolioItemGroup& x);

    virtual 
    ~FolioItemGroup ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
  };

  class FolioAddressCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // FolioAddress
    //
    typedef ::dataadvice::FolioAddress FolioAddress_type;
    typedef ::xsd::cxx::tree::sequence< FolioAddress_type > FolioAddress_sequence;
    typedef FolioAddress_sequence::iterator FolioAddress_iterator;
    typedef FolioAddress_sequence::const_iterator FolioAddress_const_iterator;
    typedef ::xsd::cxx::tree::traits< FolioAddress_type, char > FolioAddress_traits;

    const FolioAddress_sequence&
    FolioAddress () const;

    FolioAddress_sequence&
    FolioAddress ();

    void
    FolioAddress (const FolioAddress_sequence& s);

    // Constructors.
    //
    FolioAddressCollection ();

    FolioAddressCollection (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    FolioAddressCollection (const FolioAddressCollection& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

    virtual FolioAddressCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioAddressCollection&
    operator= (const FolioAddressCollection& x);

    virtual 
    ~FolioAddressCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FolioAddress_sequence FolioAddress_;
  };

  class FolioAddress: public ::dataadvice::FolioItemGroup
  {
    public:
    // PrimaryFlag
    //
    typedef ::dataadvice::FolioBooleanItem PrimaryFlag_type;
    typedef ::xsd::cxx::tree::optional< PrimaryFlag_type > PrimaryFlag_optional;
    typedef ::xsd::cxx::tree::traits< PrimaryFlag_type, char > PrimaryFlag_traits;

    const PrimaryFlag_optional&
    PrimaryFlag () const;

    PrimaryFlag_optional&
    PrimaryFlag ();

    void
    PrimaryFlag (const PrimaryFlag_type& x);

    void
    PrimaryFlag (const PrimaryFlag_optional& x);

    void
    PrimaryFlag (::std::unique_ptr< PrimaryFlag_type > p);

    // UnitNumber
    //
    typedef ::dataadvice::FolioString255Item UnitNumber_type;
    typedef ::xsd::cxx::tree::optional< UnitNumber_type > UnitNumber_optional;
    typedef ::xsd::cxx::tree::traits< UnitNumber_type, char > UnitNumber_traits;

    const UnitNumber_optional&
    UnitNumber () const;

    UnitNumber_optional&
    UnitNumber ();

    void
    UnitNumber (const UnitNumber_type& x);

    void
    UnitNumber (const UnitNumber_optional& x);

    void
    UnitNumber (::std::unique_ptr< UnitNumber_type > p);

    // StreetNumber
    //
    typedef ::dataadvice::FolioString255Item StreetNumber_type;
    typedef ::xsd::cxx::tree::optional< StreetNumber_type > StreetNumber_optional;
    typedef ::xsd::cxx::tree::traits< StreetNumber_type, char > StreetNumber_traits;

    const StreetNumber_optional&
    StreetNumber () const;

    StreetNumber_optional&
    StreetNumber ();

    void
    StreetNumber (const StreetNumber_type& x);

    void
    StreetNumber (const StreetNumber_optional& x);

    void
    StreetNumber (::std::unique_ptr< StreetNumber_type > p);

    // StreetDirectionPrefix
    //
    typedef ::dataadvice::FolioString255Item StreetDirectionPrefix_type;
    typedef ::xsd::cxx::tree::optional< StreetDirectionPrefix_type > StreetDirectionPrefix_optional;
    typedef ::xsd::cxx::tree::traits< StreetDirectionPrefix_type, char > StreetDirectionPrefix_traits;

    const StreetDirectionPrefix_optional&
    StreetDirectionPrefix () const;

    StreetDirectionPrefix_optional&
    StreetDirectionPrefix ();

    void
    StreetDirectionPrefix (const StreetDirectionPrefix_type& x);

    void
    StreetDirectionPrefix (const StreetDirectionPrefix_optional& x);

    void
    StreetDirectionPrefix (::std::unique_ptr< StreetDirectionPrefix_type > p);

    // StreetName
    //
    typedef ::dataadvice::FolioString255Item StreetName_type;
    typedef ::xsd::cxx::tree::optional< StreetName_type > StreetName_optional;
    typedef ::xsd::cxx::tree::traits< StreetName_type, char > StreetName_traits;

    const StreetName_optional&
    StreetName () const;

    StreetName_optional&
    StreetName ();

    void
    StreetName (const StreetName_type& x);

    void
    StreetName (const StreetName_optional& x);

    void
    StreetName (::std::unique_ptr< StreetName_type > p);

    // StreetType
    //
    typedef ::dataadvice::FolioString255Item StreetType_type;
    typedef ::xsd::cxx::tree::optional< StreetType_type > StreetType_optional;
    typedef ::xsd::cxx::tree::traits< StreetType_type, char > StreetType_traits;

    const StreetType_optional&
    StreetType () const;

    StreetType_optional&
    StreetType ();

    void
    StreetType (const StreetType_type& x);

    void
    StreetType (const StreetType_optional& x);

    void
    StreetType (::std::unique_ptr< StreetType_type > p);

    // StreetDirectionSuffix
    //
    typedef ::dataadvice::FolioString255Item StreetDirectionSuffix_type;
    typedef ::xsd::cxx::tree::optional< StreetDirectionSuffix_type > StreetDirectionSuffix_optional;
    typedef ::xsd::cxx::tree::traits< StreetDirectionSuffix_type, char > StreetDirectionSuffix_traits;

    const StreetDirectionSuffix_optional&
    StreetDirectionSuffix () const;

    StreetDirectionSuffix_optional&
    StreetDirectionSuffix ();

    void
    StreetDirectionSuffix (const StreetDirectionSuffix_type& x);

    void
    StreetDirectionSuffix (const StreetDirectionSuffix_optional& x);

    void
    StreetDirectionSuffix (::std::unique_ptr< StreetDirectionSuffix_type > p);

    // City
    //
    typedef ::dataadvice::FolioString255Item City_type;
    typedef ::xsd::cxx::tree::optional< City_type > City_optional;
    typedef ::xsd::cxx::tree::traits< City_type, char > City_traits;

    const City_optional&
    City () const;

    City_optional&
    City ();

    void
    City (const City_type& x);

    void
    City (const City_optional& x);

    void
    City (::std::unique_ptr< City_type > p);

    // ProvinceState
    //
    typedef ::dataadvice::FolioString255Item ProvinceState_type;
    typedef ::xsd::cxx::tree::optional< ProvinceState_type > ProvinceState_optional;
    typedef ::xsd::cxx::tree::traits< ProvinceState_type, char > ProvinceState_traits;

    const ProvinceState_optional&
    ProvinceState () const;

    ProvinceState_optional&
    ProvinceState ();

    void
    ProvinceState (const ProvinceState_type& x);

    void
    ProvinceState (const ProvinceState_optional& x);

    void
    ProvinceState (::std::unique_ptr< ProvinceState_type > p);

    // PostalZip
    //
    typedef ::dataadvice::FolioString255Item PostalZip_type;
    typedef ::xsd::cxx::tree::optional< PostalZip_type > PostalZip_optional;
    typedef ::xsd::cxx::tree::traits< PostalZip_type, char > PostalZip_traits;

    const PostalZip_optional&
    PostalZip () const;

    PostalZip_optional&
    PostalZip ();

    void
    PostalZip (const PostalZip_type& x);

    void
    PostalZip (const PostalZip_optional& x);

    void
    PostalZip (::std::unique_ptr< PostalZip_type > p);

    // MapReferenceNumber
    //
    typedef ::dataadvice::FolioString255Item MapReferenceNumber_type;
    typedef ::xsd::cxx::tree::optional< MapReferenceNumber_type > MapReferenceNumber_optional;
    typedef ::xsd::cxx::tree::traits< MapReferenceNumber_type, char > MapReferenceNumber_traits;

    const MapReferenceNumber_optional&
    MapReferenceNumber () const;

    MapReferenceNumber_optional&
    MapReferenceNumber ();

    void
    MapReferenceNumber (const MapReferenceNumber_type& x);

    void
    MapReferenceNumber (const MapReferenceNumber_optional& x);

    void
    MapReferenceNumber (::std::unique_ptr< MapReferenceNumber_type > p);

    // Constructors.
    //
    FolioAddress ();

    FolioAddress (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    FolioAddress (const FolioAddress& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual FolioAddress*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioAddress&
    operator= (const FolioAddress& x);

    virtual 
    ~FolioAddress ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PrimaryFlag_optional PrimaryFlag_;
    UnitNumber_optional UnitNumber_;
    StreetNumber_optional StreetNumber_;
    StreetDirectionPrefix_optional StreetDirectionPrefix_;
    StreetName_optional StreetName_;
    StreetType_optional StreetType_;
    StreetDirectionSuffix_optional StreetDirectionSuffix_;
    City_optional City_;
    ProvinceState_optional ProvinceState_;
    PostalZip_optional PostalZip_;
    MapReferenceNumber_optional MapReferenceNumber_;
  };

  class OwnershipGroupCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // OwnershipGroup
    //
    typedef ::dataadvice::OwnershipGroup OwnershipGroup_type;
    typedef ::xsd::cxx::tree::sequence< OwnershipGroup_type > OwnershipGroup_sequence;
    typedef OwnershipGroup_sequence::iterator OwnershipGroup_iterator;
    typedef OwnershipGroup_sequence::const_iterator OwnershipGroup_const_iterator;
    typedef ::xsd::cxx::tree::traits< OwnershipGroup_type, char > OwnershipGroup_traits;

    const OwnershipGroup_sequence&
    OwnershipGroup () const;

    OwnershipGroup_sequence&
    OwnershipGroup ();

    void
    OwnershipGroup (const OwnershipGroup_sequence& s);

    // Constructors.
    //
    OwnershipGroupCollection ();

    OwnershipGroupCollection (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    OwnershipGroupCollection (const OwnershipGroupCollection& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual OwnershipGroupCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OwnershipGroupCollection&
    operator= (const OwnershipGroupCollection& x);

    virtual 
    ~OwnershipGroupCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OwnershipGroup_sequence OwnershipGroup_;
  };

  class OwnershipGroup: public ::dataadvice::FolioItemGroup
  {
    public:
    // OwnershipGroupID
    //
    typedef ::dataadvice::FolioUniqueIDItem OwnershipGroupID_type;
    typedef ::xsd::cxx::tree::optional< OwnershipGroupID_type > OwnershipGroupID_optional;
    typedef ::xsd::cxx::tree::traits< OwnershipGroupID_type, char > OwnershipGroupID_traits;

    const OwnershipGroupID_optional&
    OwnershipGroupID () const;

    OwnershipGroupID_optional&
    OwnershipGroupID ();

    void
    OwnershipGroupID (const OwnershipGroupID_type& x);

    void
    OwnershipGroupID (const OwnershipGroupID_optional& x);

    void
    OwnershipGroupID (::std::unique_ptr< OwnershipGroupID_type > p);

    // TenureCode
    //
    typedef ::dataadvice::FolioLookupCodeItem TenureCode_type;
    typedef ::xsd::cxx::tree::optional< TenureCode_type > TenureCode_optional;
    typedef ::xsd::cxx::tree::traits< TenureCode_type, char > TenureCode_traits;

    const TenureCode_optional&
    TenureCode () const;

    TenureCode_optional&
    TenureCode ();

    void
    TenureCode (const TenureCode_type& x);

    void
    TenureCode (const TenureCode_optional& x);

    void
    TenureCode (::std::unique_ptr< TenureCode_type > p);

    // TenureDescription
    //
    typedef ::dataadvice::FolioString255Item TenureDescription_type;
    typedef ::xsd::cxx::tree::optional< TenureDescription_type > TenureDescription_optional;
    typedef ::xsd::cxx::tree::traits< TenureDescription_type, char > TenureDescription_traits;

    const TenureDescription_optional&
    TenureDescription () const;

    TenureDescription_optional&
    TenureDescription ();

    void
    TenureDescription (const TenureDescription_type& x);

    void
    TenureDescription (const TenureDescription_optional& x);

    void
    TenureDescription (::std::unique_ptr< TenureDescription_type > p);

    // AssessmentNoticeReturned
    //
    typedef ::dataadvice::FolioBooleanItem AssessmentNoticeReturned_type;
    typedef ::xsd::cxx::tree::optional< AssessmentNoticeReturned_type > AssessmentNoticeReturned_optional;
    typedef ::xsd::cxx::tree::traits< AssessmentNoticeReturned_type, char > AssessmentNoticeReturned_traits;

    const AssessmentNoticeReturned_optional&
    AssessmentNoticeReturned () const;

    AssessmentNoticeReturned_optional&
    AssessmentNoticeReturned ();

    void
    AssessmentNoticeReturned (const AssessmentNoticeReturned_type& x);

    void
    AssessmentNoticeReturned (const AssessmentNoticeReturned_optional& x);

    void
    AssessmentNoticeReturned (::std::unique_ptr< AssessmentNoticeReturned_type > p);

    // AssessmentNoticeSuppressed
    //
    typedef ::dataadvice::FolioBooleanItem AssessmentNoticeSuppressed_type;
    typedef ::xsd::cxx::tree::optional< AssessmentNoticeSuppressed_type > AssessmentNoticeSuppressed_optional;
    typedef ::xsd::cxx::tree::traits< AssessmentNoticeSuppressed_type, char > AssessmentNoticeSuppressed_traits;

    const AssessmentNoticeSuppressed_optional&
    AssessmentNoticeSuppressed () const;

    AssessmentNoticeSuppressed_optional&
    AssessmentNoticeSuppressed ();

    void
    AssessmentNoticeSuppressed (const AssessmentNoticeSuppressed_type& x);

    void
    AssessmentNoticeSuppressed (const AssessmentNoticeSuppressed_optional& x);

    void
    AssessmentNoticeSuppressed (::std::unique_ptr< AssessmentNoticeSuppressed_type > p);

    // ChangeType
    //
    typedef ::dataadvice::FolioLookupCodeItem ChangeType_type;
    typedef ::xsd::cxx::tree::optional< ChangeType_type > ChangeType_optional;
    typedef ::xsd::cxx::tree::traits< ChangeType_type, char > ChangeType_traits;

    const ChangeType_optional&
    ChangeType () const;

    ChangeType_optional&
    ChangeType ();

    void
    ChangeType (const ChangeType_type& x);

    void
    ChangeType (const ChangeType_optional& x);

    void
    ChangeType (::std::unique_ptr< ChangeType_type > p);

    // ChangeTypeDescription
    //
    typedef ::dataadvice::FolioString255Item ChangeTypeDescription_type;
    typedef ::xsd::cxx::tree::optional< ChangeTypeDescription_type > ChangeTypeDescription_optional;
    typedef ::xsd::cxx::tree::traits< ChangeTypeDescription_type, char > ChangeTypeDescription_traits;

    const ChangeTypeDescription_optional&
    ChangeTypeDescription () const;

    ChangeTypeDescription_optional&
    ChangeTypeDescription ();

    void
    ChangeTypeDescription (const ChangeTypeDescription_type& x);

    void
    ChangeTypeDescription (const ChangeTypeDescription_optional& x);

    void
    ChangeTypeDescription (::std::unique_ptr< ChangeTypeDescription_type > p);

    // ChangeDate
    //
    typedef ::dataadvice::FolioDateItem ChangeDate_type;
    typedef ::xsd::cxx::tree::optional< ChangeDate_type > ChangeDate_optional;
    typedef ::xsd::cxx::tree::traits< ChangeDate_type, char > ChangeDate_traits;

    const ChangeDate_optional&
    ChangeDate () const;

    ChangeDate_optional&
    ChangeDate ();

    void
    ChangeDate (const ChangeDate_type& x);

    void
    ChangeDate (const ChangeDate_optional& x);

    void
    ChangeDate (::std::unique_ptr< ChangeDate_type > p);

    // ChangeSource
    //
    typedef ::dataadvice::FolioLookupCodeItem ChangeSource_type;
    typedef ::xsd::cxx::tree::optional< ChangeSource_type > ChangeSource_optional;
    typedef ::xsd::cxx::tree::traits< ChangeSource_type, char > ChangeSource_traits;

    const ChangeSource_optional&
    ChangeSource () const;

    ChangeSource_optional&
    ChangeSource ();

    void
    ChangeSource (const ChangeSource_type& x);

    void
    ChangeSource (const ChangeSource_optional& x);

    void
    ChangeSource (::std::unique_ptr< ChangeSource_type > p);

    // ChangeSourceDescription
    //
    typedef ::dataadvice::FolioString255Item ChangeSourceDescription_type;
    typedef ::xsd::cxx::tree::optional< ChangeSourceDescription_type > ChangeSourceDescription_optional;
    typedef ::xsd::cxx::tree::traits< ChangeSourceDescription_type, char > ChangeSourceDescription_traits;

    const ChangeSourceDescription_optional&
    ChangeSourceDescription () const;

    ChangeSourceDescription_optional&
    ChangeSourceDescription ();

    void
    ChangeSourceDescription (const ChangeSourceDescription_type& x);

    void
    ChangeSourceDescription (const ChangeSourceDescription_optional& x);

    void
    ChangeSourceDescription (::std::unique_ptr< ChangeSourceDescription_type > p);

    // Owners
    //
    typedef ::dataadvice::OwnerCollection Owners_type;
    typedef ::xsd::cxx::tree::optional< Owners_type > Owners_optional;
    typedef ::xsd::cxx::tree::traits< Owners_type, char > Owners_traits;

    const Owners_optional&
    Owners () const;

    Owners_optional&
    Owners ();

    void
    Owners (const Owners_type& x);

    void
    Owners (const Owners_optional& x);

    void
    Owners (::std::unique_ptr< Owners_type > p);

    // FormattedMailingAddress
    //
    typedef ::dataadvice::FormattedMailingAddress FormattedMailingAddress_type;
    typedef ::xsd::cxx::tree::optional< FormattedMailingAddress_type > FormattedMailingAddress_optional;
    typedef ::xsd::cxx::tree::traits< FormattedMailingAddress_type, char > FormattedMailingAddress_traits;

    const FormattedMailingAddress_optional&
    FormattedMailingAddress () const;

    FormattedMailingAddress_optional&
    FormattedMailingAddress ();

    void
    FormattedMailingAddress (const FormattedMailingAddress_type& x);

    void
    FormattedMailingAddress (const FormattedMailingAddress_optional& x);

    void
    FormattedMailingAddress (::std::unique_ptr< FormattedMailingAddress_type > p);

    // MailingAddress
    //
    typedef ::dataadvice::MailingAddress MailingAddress_type;
    typedef ::xsd::cxx::tree::optional< MailingAddress_type > MailingAddress_optional;
    typedef ::xsd::cxx::tree::traits< MailingAddress_type, char > MailingAddress_traits;

    const MailingAddress_optional&
    MailingAddress () const;

    MailingAddress_optional&
    MailingAddress ();

    void
    MailingAddress (const MailingAddress_type& x);

    void
    MailingAddress (const MailingAddress_optional& x);

    void
    MailingAddress (::std::unique_ptr< MailingAddress_type > p);

    // Constructors.
    //
    OwnershipGroup ();

    OwnershipGroup (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    OwnershipGroup (const OwnershipGroup& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual OwnershipGroup*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OwnershipGroup&
    operator= (const OwnershipGroup& x);

    virtual 
    ~OwnershipGroup ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OwnershipGroupID_optional OwnershipGroupID_;
    TenureCode_optional TenureCode_;
    TenureDescription_optional TenureDescription_;
    AssessmentNoticeReturned_optional AssessmentNoticeReturned_;
    AssessmentNoticeSuppressed_optional AssessmentNoticeSuppressed_;
    ChangeType_optional ChangeType_;
    ChangeTypeDescription_optional ChangeTypeDescription_;
    ChangeDate_optional ChangeDate_;
    ChangeSource_optional ChangeSource_;
    ChangeSourceDescription_optional ChangeSourceDescription_;
    Owners_optional Owners_;
    FormattedMailingAddress_optional FormattedMailingAddress_;
    MailingAddress_optional MailingAddress_;
  };

  class OwnerCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // Owner
    //
    typedef ::dataadvice::Owner Owner_type;
    typedef ::xsd::cxx::tree::sequence< Owner_type > Owner_sequence;
    typedef Owner_sequence::iterator Owner_iterator;
    typedef Owner_sequence::const_iterator Owner_const_iterator;
    typedef ::xsd::cxx::tree::traits< Owner_type, char > Owner_traits;

    const Owner_sequence&
    Owner () const;

    Owner_sequence&
    Owner ();

    void
    Owner (const Owner_sequence& s);

    // Constructors.
    //
    OwnerCollection ();

    OwnerCollection (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    OwnerCollection (const OwnerCollection& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual OwnerCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OwnerCollection&
    operator= (const OwnerCollection& x);

    virtual 
    ~OwnerCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Owner_sequence Owner_;
  };

  class Owner: public ::dataadvice::FolioItemGroup
  {
    public:
    // FirstName
    //
    typedef ::dataadvice::FolioString255Item FirstName_type;
    typedef ::xsd::cxx::tree::optional< FirstName_type > FirstName_optional;
    typedef ::xsd::cxx::tree::traits< FirstName_type, char > FirstName_traits;

    const FirstName_optional&
    FirstName () const;

    FirstName_optional&
    FirstName ();

    void
    FirstName (const FirstName_type& x);

    void
    FirstName (const FirstName_optional& x);

    void
    FirstName (::std::unique_ptr< FirstName_type > p);

    // MiddleName
    //
    typedef ::dataadvice::FolioString255Item MiddleName_type;
    typedef ::xsd::cxx::tree::optional< MiddleName_type > MiddleName_optional;
    typedef ::xsd::cxx::tree::traits< MiddleName_type, char > MiddleName_traits;

    const MiddleName_optional&
    MiddleName () const;

    MiddleName_optional&
    MiddleName ();

    void
    MiddleName (const MiddleName_type& x);

    void
    MiddleName (const MiddleName_optional& x);

    void
    MiddleName (::std::unique_ptr< MiddleName_type > p);

    // MiddleInitial
    //
    typedef ::dataadvice::FolioCharacterItem MiddleInitial_type;
    typedef ::xsd::cxx::tree::optional< MiddleInitial_type > MiddleInitial_optional;
    typedef ::xsd::cxx::tree::traits< MiddleInitial_type, char > MiddleInitial_traits;

    const MiddleInitial_optional&
    MiddleInitial () const;

    MiddleInitial_optional&
    MiddleInitial ();

    void
    MiddleInitial (const MiddleInitial_type& x);

    void
    MiddleInitial (const MiddleInitial_optional& x);

    void
    MiddleInitial (::std::unique_ptr< MiddleInitial_type > p);

    // CompanyOrLastName
    //
    typedef ::dataadvice::FolioString255Item CompanyOrLastName_type;
    typedef ::xsd::cxx::tree::traits< CompanyOrLastName_type, char > CompanyOrLastName_traits;

    const CompanyOrLastName_type&
    CompanyOrLastName () const;

    CompanyOrLastName_type&
    CompanyOrLastName ();

    void
    CompanyOrLastName (const CompanyOrLastName_type& x);

    void
    CompanyOrLastName (::std::unique_ptr< CompanyOrLastName_type > p);

    // OwnerSequenceID
    //
    typedef ::dataadvice::FolioUniqueIDItem OwnerSequenceID_type;
    typedef ::xsd::cxx::tree::optional< OwnerSequenceID_type > OwnerSequenceID_optional;
    typedef ::xsd::cxx::tree::traits< OwnerSequenceID_type, char > OwnerSequenceID_traits;

    const OwnerSequenceID_optional&
    OwnerSequenceID () const;

    OwnerSequenceID_optional&
    OwnerSequenceID ();

    void
    OwnerSequenceID (const OwnerSequenceID_type& x);

    void
    OwnerSequenceID (const OwnerSequenceID_optional& x);

    void
    OwnerSequenceID (::std::unique_ptr< OwnerSequenceID_type > p);

    // EquityType
    //
    typedef ::dataadvice::FolioLookupCodeItem EquityType_type;
    typedef ::xsd::cxx::tree::optional< EquityType_type > EquityType_optional;
    typedef ::xsd::cxx::tree::traits< EquityType_type, char > EquityType_traits;

    const EquityType_optional&
    EquityType () const;

    EquityType_optional&
    EquityType ();

    void
    EquityType (const EquityType_type& x);

    void
    EquityType (const EquityType_optional& x);

    void
    EquityType (::std::unique_ptr< EquityType_type > p);

    // EquityTypeDescription
    //
    typedef ::dataadvice::FolioString255Item EquityTypeDescription_type;
    typedef ::xsd::cxx::tree::optional< EquityTypeDescription_type > EquityTypeDescription_optional;
    typedef ::xsd::cxx::tree::traits< EquityTypeDescription_type, char > EquityTypeDescription_traits;

    const EquityTypeDescription_optional&
    EquityTypeDescription () const;

    EquityTypeDescription_optional&
    EquityTypeDescription ();

    void
    EquityTypeDescription (const EquityTypeDescription_type& x);

    void
    EquityTypeDescription (const EquityTypeDescription_optional& x);

    void
    EquityTypeDescription (::std::unique_ptr< EquityTypeDescription_type > p);

    // Constructors.
    //
    Owner (const CompanyOrLastName_type&);

    Owner (::std::unique_ptr< CompanyOrLastName_type >);

    Owner (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    Owner (const Owner& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual Owner*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Owner&
    operator= (const Owner& x);

    virtual 
    ~Owner ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FirstName_optional FirstName_;
    MiddleName_optional MiddleName_;
    MiddleInitial_optional MiddleInitial_;
    ::xsd::cxx::tree::one< CompanyOrLastName_type > CompanyOrLastName_;
    OwnerSequenceID_optional OwnerSequenceID_;
    EquityType_optional EquityType_;
    EquityTypeDescription_optional EquityTypeDescription_;
  };

  class MailingAddress: public ::dataadvice::FolioItemGroup
  {
    public:
    // Attention
    //
    typedef ::dataadvice::FolioString255Item Attention_type;
    typedef ::xsd::cxx::tree::optional< Attention_type > Attention_optional;
    typedef ::xsd::cxx::tree::traits< Attention_type, char > Attention_traits;

    const Attention_optional&
    Attention () const;

    Attention_optional&
    Attention ();

    void
    Attention (const Attention_type& x);

    void
    Attention (const Attention_optional& x);

    void
    Attention (::std::unique_ptr< Attention_type > p);

    // CareOf
    //
    typedef ::dataadvice::FolioString255Item CareOf_type;
    typedef ::xsd::cxx::tree::optional< CareOf_type > CareOf_optional;
    typedef ::xsd::cxx::tree::traits< CareOf_type, char > CareOf_traits;

    const CareOf_optional&
    CareOf () const;

    CareOf_optional&
    CareOf ();

    void
    CareOf (const CareOf_type& x);

    void
    CareOf (const CareOf_optional& x);

    void
    CareOf (::std::unique_ptr< CareOf_type > p);

    // Floor
    //
    typedef ::dataadvice::FolioString255Item Floor_type;
    typedef ::xsd::cxx::tree::optional< Floor_type > Floor_optional;
    typedef ::xsd::cxx::tree::traits< Floor_type, char > Floor_traits;

    const Floor_optional&
    Floor () const;

    Floor_optional&
    Floor ();

    void
    Floor (const Floor_type& x);

    void
    Floor (const Floor_optional& x);

    void
    Floor (::std::unique_ptr< Floor_type > p);

    // UnitNumber
    //
    typedef ::dataadvice::FolioString255Item UnitNumber_type;
    typedef ::xsd::cxx::tree::optional< UnitNumber_type > UnitNumber_optional;
    typedef ::xsd::cxx::tree::traits< UnitNumber_type, char > UnitNumber_traits;

    const UnitNumber_optional&
    UnitNumber () const;

    UnitNumber_optional&
    UnitNumber ();

    void
    UnitNumber (const UnitNumber_type& x);

    void
    UnitNumber (const UnitNumber_optional& x);

    void
    UnitNumber (::std::unique_ptr< UnitNumber_type > p);

    // StreetDirectionPrefix
    //
    typedef ::dataadvice::FolioString255Item StreetDirectionPrefix_type;
    typedef ::xsd::cxx::tree::optional< StreetDirectionPrefix_type > StreetDirectionPrefix_optional;
    typedef ::xsd::cxx::tree::traits< StreetDirectionPrefix_type, char > StreetDirectionPrefix_traits;

    const StreetDirectionPrefix_optional&
    StreetDirectionPrefix () const;

    StreetDirectionPrefix_optional&
    StreetDirectionPrefix ();

    void
    StreetDirectionPrefix (const StreetDirectionPrefix_type& x);

    void
    StreetDirectionPrefix (const StreetDirectionPrefix_optional& x);

    void
    StreetDirectionPrefix (::std::unique_ptr< StreetDirectionPrefix_type > p);

    // StreetNumber
    //
    typedef ::dataadvice::FolioString255Item StreetNumber_type;
    typedef ::xsd::cxx::tree::optional< StreetNumber_type > StreetNumber_optional;
    typedef ::xsd::cxx::tree::traits< StreetNumber_type, char > StreetNumber_traits;

    const StreetNumber_optional&
    StreetNumber () const;

    StreetNumber_optional&
    StreetNumber ();

    void
    StreetNumber (const StreetNumber_type& x);

    void
    StreetNumber (const StreetNumber_optional& x);

    void
    StreetNumber (::std::unique_ptr< StreetNumber_type > p);

    // StreetName
    //
    typedef ::dataadvice::FolioString255Item StreetName_type;
    typedef ::xsd::cxx::tree::optional< StreetName_type > StreetName_optional;
    typedef ::xsd::cxx::tree::traits< StreetName_type, char > StreetName_traits;

    const StreetName_optional&
    StreetName () const;

    StreetName_optional&
    StreetName ();

    void
    StreetName (const StreetName_type& x);

    void
    StreetName (const StreetName_optional& x);

    void
    StreetName (::std::unique_ptr< StreetName_type > p);

    // StreetType
    //
    typedef ::dataadvice::FolioString255Item StreetType_type;
    typedef ::xsd::cxx::tree::optional< StreetType_type > StreetType_optional;
    typedef ::xsd::cxx::tree::traits< StreetType_type, char > StreetType_traits;

    const StreetType_optional&
    StreetType () const;

    StreetType_optional&
    StreetType ();

    void
    StreetType (const StreetType_type& x);

    void
    StreetType (const StreetType_optional& x);

    void
    StreetType (::std::unique_ptr< StreetType_type > p);

    // StreetDirectionSuffix
    //
    typedef ::dataadvice::FolioString255Item StreetDirectionSuffix_type;
    typedef ::xsd::cxx::tree::optional< StreetDirectionSuffix_type > StreetDirectionSuffix_optional;
    typedef ::xsd::cxx::tree::traits< StreetDirectionSuffix_type, char > StreetDirectionSuffix_traits;

    const StreetDirectionSuffix_optional&
    StreetDirectionSuffix () const;

    StreetDirectionSuffix_optional&
    StreetDirectionSuffix ();

    void
    StreetDirectionSuffix (const StreetDirectionSuffix_type& x);

    void
    StreetDirectionSuffix (const StreetDirectionSuffix_optional& x);

    void
    StreetDirectionSuffix (::std::unique_ptr< StreetDirectionSuffix_type > p);

    // City
    //
    typedef ::dataadvice::FolioString255Item City_type;
    typedef ::xsd::cxx::tree::optional< City_type > City_optional;
    typedef ::xsd::cxx::tree::traits< City_type, char > City_traits;

    const City_optional&
    City () const;

    City_optional&
    City ();

    void
    City (const City_type& x);

    void
    City (const City_optional& x);

    void
    City (::std::unique_ptr< City_type > p);

    // ProvinceState
    //
    typedef ::dataadvice::FolioString255Item ProvinceState_type;
    typedef ::xsd::cxx::tree::optional< ProvinceState_type > ProvinceState_optional;
    typedef ::xsd::cxx::tree::traits< ProvinceState_type, char > ProvinceState_traits;

    const ProvinceState_optional&
    ProvinceState () const;

    ProvinceState_optional&
    ProvinceState ();

    void
    ProvinceState (const ProvinceState_type& x);

    void
    ProvinceState (const ProvinceState_optional& x);

    void
    ProvinceState (::std::unique_ptr< ProvinceState_type > p);

    // Country
    //
    typedef ::dataadvice::FolioString255Item Country_type;
    typedef ::xsd::cxx::tree::optional< Country_type > Country_optional;
    typedef ::xsd::cxx::tree::traits< Country_type, char > Country_traits;

    const Country_optional&
    Country () const;

    Country_optional&
    Country ();

    void
    Country (const Country_type& x);

    void
    Country (const Country_optional& x);

    void
    Country (::std::unique_ptr< Country_type > p);

    // PostalZip
    //
    typedef ::dataadvice::FolioString255Item PostalZip_type;
    typedef ::xsd::cxx::tree::optional< PostalZip_type > PostalZip_optional;
    typedef ::xsd::cxx::tree::traits< PostalZip_type, char > PostalZip_traits;

    const PostalZip_optional&
    PostalZip () const;

    PostalZip_optional&
    PostalZip ();

    void
    PostalZip (const PostalZip_type& x);

    void
    PostalZip (const PostalZip_optional& x);

    void
    PostalZip (::std::unique_ptr< PostalZip_type > p);

    // FreeformAddress
    //
    typedef ::dataadvice::FolioString255Item FreeformAddress_type;
    typedef ::xsd::cxx::tree::optional< FreeformAddress_type > FreeformAddress_optional;
    typedef ::xsd::cxx::tree::traits< FreeformAddress_type, char > FreeformAddress_traits;

    const FreeformAddress_optional&
    FreeformAddress () const;

    FreeformAddress_optional&
    FreeformAddress ();

    void
    FreeformAddress (const FreeformAddress_type& x);

    void
    FreeformAddress (const FreeformAddress_optional& x);

    void
    FreeformAddress (::std::unique_ptr< FreeformAddress_type > p);

    // Compartment
    //
    typedef ::dataadvice::FolioString255Item Compartment_type;
    typedef ::xsd::cxx::tree::optional< Compartment_type > Compartment_optional;
    typedef ::xsd::cxx::tree::traits< Compartment_type, char > Compartment_traits;

    const Compartment_optional&
    Compartment () const;

    Compartment_optional&
    Compartment ();

    void
    Compartment (const Compartment_type& x);

    void
    Compartment (const Compartment_optional& x);

    void
    Compartment (::std::unique_ptr< Compartment_type > p);

    // DeliveryInstallationType
    //
    typedef ::dataadvice::FolioString255Item DeliveryInstallationType_type;
    typedef ::xsd::cxx::tree::optional< DeliveryInstallationType_type > DeliveryInstallationType_optional;
    typedef ::xsd::cxx::tree::traits< DeliveryInstallationType_type, char > DeliveryInstallationType_traits;

    const DeliveryInstallationType_optional&
    DeliveryInstallationType () const;

    DeliveryInstallationType_optional&
    DeliveryInstallationType ();

    void
    DeliveryInstallationType (const DeliveryInstallationType_type& x);

    void
    DeliveryInstallationType (const DeliveryInstallationType_optional& x);

    void
    DeliveryInstallationType (::std::unique_ptr< DeliveryInstallationType_type > p);

    // DeliveryInstallationTypeValue
    //
    typedef ::dataadvice::FolioString255Item DeliveryInstallationTypeValue_type;
    typedef ::xsd::cxx::tree::optional< DeliveryInstallationTypeValue_type > DeliveryInstallationTypeValue_optional;
    typedef ::xsd::cxx::tree::traits< DeliveryInstallationTypeValue_type, char > DeliveryInstallationTypeValue_traits;

    const DeliveryInstallationTypeValue_optional&
    DeliveryInstallationTypeValue () const;

    DeliveryInstallationTypeValue_optional&
    DeliveryInstallationTypeValue ();

    void
    DeliveryInstallationTypeValue (const DeliveryInstallationTypeValue_type& x);

    void
    DeliveryInstallationTypeValue (const DeliveryInstallationTypeValue_optional& x);

    void
    DeliveryInstallationTypeValue (::std::unique_ptr< DeliveryInstallationTypeValue_type > p);

    // ModeOfDelivery
    //
    typedef ::dataadvice::FolioString255Item ModeOfDelivery_type;
    typedef ::xsd::cxx::tree::optional< ModeOfDelivery_type > ModeOfDelivery_optional;
    typedef ::xsd::cxx::tree::traits< ModeOfDelivery_type, char > ModeOfDelivery_traits;

    const ModeOfDelivery_optional&
    ModeOfDelivery () const;

    ModeOfDelivery_optional&
    ModeOfDelivery ();

    void
    ModeOfDelivery (const ModeOfDelivery_type& x);

    void
    ModeOfDelivery (const ModeOfDelivery_optional& x);

    void
    ModeOfDelivery (::std::unique_ptr< ModeOfDelivery_type > p);

    // ModeOfDeliveryValue
    //
    typedef ::dataadvice::FolioString255Item ModeOfDeliveryValue_type;
    typedef ::xsd::cxx::tree::optional< ModeOfDeliveryValue_type > ModeOfDeliveryValue_optional;
    typedef ::xsd::cxx::tree::traits< ModeOfDeliveryValue_type, char > ModeOfDeliveryValue_traits;

    const ModeOfDeliveryValue_optional&
    ModeOfDeliveryValue () const;

    ModeOfDeliveryValue_optional&
    ModeOfDeliveryValue ();

    void
    ModeOfDeliveryValue (const ModeOfDeliveryValue_type& x);

    void
    ModeOfDeliveryValue (const ModeOfDeliveryValue_optional& x);

    void
    ModeOfDeliveryValue (::std::unique_ptr< ModeOfDeliveryValue_type > p);

    // Site
    //
    typedef ::dataadvice::FolioString255Item Site_type;
    typedef ::xsd::cxx::tree::optional< Site_type > Site_optional;
    typedef ::xsd::cxx::tree::traits< Site_type, char > Site_traits;

    const Site_optional&
    Site () const;

    Site_optional&
    Site ();

    void
    Site (const Site_type& x);

    void
    Site (const Site_optional& x);

    void
    Site (::std::unique_ptr< Site_type > p);

    // BulkMailCode
    //
    typedef ::dataadvice::FolioString255Item BulkMailCode_type;
    typedef ::xsd::cxx::tree::optional< BulkMailCode_type > BulkMailCode_optional;
    typedef ::xsd::cxx::tree::traits< BulkMailCode_type, char > BulkMailCode_traits;

    const BulkMailCode_optional&
    BulkMailCode () const;

    BulkMailCode_optional&
    BulkMailCode ();

    void
    BulkMailCode (const BulkMailCode_type& x);

    void
    BulkMailCode (const BulkMailCode_optional& x);

    void
    BulkMailCode (::std::unique_ptr< BulkMailCode_type > p);

    // Constructors.
    //
    MailingAddress ();

    MailingAddress (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    MailingAddress (const MailingAddress& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual MailingAddress*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MailingAddress&
    operator= (const MailingAddress& x);

    virtual 
    ~MailingAddress ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Attention_optional Attention_;
    CareOf_optional CareOf_;
    Floor_optional Floor_;
    UnitNumber_optional UnitNumber_;
    StreetDirectionPrefix_optional StreetDirectionPrefix_;
    StreetNumber_optional StreetNumber_;
    StreetName_optional StreetName_;
    StreetType_optional StreetType_;
    StreetDirectionSuffix_optional StreetDirectionSuffix_;
    City_optional City_;
    ProvinceState_optional ProvinceState_;
    Country_optional Country_;
    PostalZip_optional PostalZip_;
    FreeformAddress_optional FreeformAddress_;
    Compartment_optional Compartment_;
    DeliveryInstallationType_optional DeliveryInstallationType_;
    DeliveryInstallationTypeValue_optional DeliveryInstallationTypeValue_;
    ModeOfDelivery_optional ModeOfDelivery_;
    ModeOfDeliveryValue_optional ModeOfDeliveryValue_;
    Site_optional Site_;
    BulkMailCode_optional BulkMailCode_;
  };

  class FormattedMailingAddress: public ::dataadvice::FolioItemGroup
  {
    public:
    // Line1
    //
    typedef ::dataadvice::FormattedMailingAddressLine Line1_type;
    typedef ::xsd::cxx::tree::optional< Line1_type > Line1_optional;
    typedef ::xsd::cxx::tree::traits< Line1_type, char > Line1_traits;

    const Line1_optional&
    Line1 () const;

    Line1_optional&
    Line1 ();

    void
    Line1 (const Line1_type& x);

    void
    Line1 (const Line1_optional& x);

    void
    Line1 (::std::unique_ptr< Line1_type > p);

    // Line2
    //
    typedef ::dataadvice::FormattedMailingAddressLine Line2_type;
    typedef ::xsd::cxx::tree::optional< Line2_type > Line2_optional;
    typedef ::xsd::cxx::tree::traits< Line2_type, char > Line2_traits;

    const Line2_optional&
    Line2 () const;

    Line2_optional&
    Line2 ();

    void
    Line2 (const Line2_type& x);

    void
    Line2 (const Line2_optional& x);

    void
    Line2 (::std::unique_ptr< Line2_type > p);

    // Line3
    //
    typedef ::dataadvice::FormattedMailingAddressLine Line3_type;
    typedef ::xsd::cxx::tree::optional< Line3_type > Line3_optional;
    typedef ::xsd::cxx::tree::traits< Line3_type, char > Line3_traits;

    const Line3_optional&
    Line3 () const;

    Line3_optional&
    Line3 ();

    void
    Line3 (const Line3_type& x);

    void
    Line3 (const Line3_optional& x);

    void
    Line3 (::std::unique_ptr< Line3_type > p);

    // Line4
    //
    typedef ::dataadvice::FormattedMailingAddressLine Line4_type;
    typedef ::xsd::cxx::tree::optional< Line4_type > Line4_optional;
    typedef ::xsd::cxx::tree::traits< Line4_type, char > Line4_traits;

    const Line4_optional&
    Line4 () const;

    Line4_optional&
    Line4 ();

    void
    Line4 (const Line4_type& x);

    void
    Line4 (const Line4_optional& x);

    void
    Line4 (::std::unique_ptr< Line4_type > p);

    // Line5
    //
    typedef ::dataadvice::FormattedMailingAddressLine Line5_type;
    typedef ::xsd::cxx::tree::optional< Line5_type > Line5_optional;
    typedef ::xsd::cxx::tree::traits< Line5_type, char > Line5_traits;

    const Line5_optional&
    Line5 () const;

    Line5_optional&
    Line5 ();

    void
    Line5 (const Line5_type& x);

    void
    Line5 (const Line5_optional& x);

    void
    Line5 (::std::unique_ptr< Line5_type > p);

    // Line6
    //
    typedef ::dataadvice::FormattedMailingAddressLine Line6_type;
    typedef ::xsd::cxx::tree::optional< Line6_type > Line6_optional;
    typedef ::xsd::cxx::tree::traits< Line6_type, char > Line6_traits;

    const Line6_optional&
    Line6 () const;

    Line6_optional&
    Line6 ();

    void
    Line6 (const Line6_type& x);

    void
    Line6 (const Line6_optional& x);

    void
    Line6 (::std::unique_ptr< Line6_type > p);

    // Constructors.
    //
    FormattedMailingAddress ();

    FormattedMailingAddress (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    FormattedMailingAddress (const FormattedMailingAddress& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual FormattedMailingAddress*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FormattedMailingAddress&
    operator= (const FormattedMailingAddress& x);

    virtual 
    ~FormattedMailingAddress ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Line1_optional Line1_;
    Line2_optional Line2_;
    Line3_optional Line3_;
    Line4_optional Line4_;
    Line5_optional Line5_;
    Line6_optional Line6_;
  };

  class String40: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    String40 ();

    String40 (const char*);

    String40 (const ::std::string&);

    String40 (const ::xml_schema::string&);

    String40 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    String40 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    String40 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    String40 (const String40& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual String40*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~String40 ();
  };

  class FormattedMailingAddressLine: public ::dataadvice::String40
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::String40 OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FormattedMailingAddressLine ();

    FormattedMailingAddressLine (const char*);

    FormattedMailingAddressLine (const ::std::string&);

    FormattedMailingAddressLine (const ::xml_schema::string&);

    FormattedMailingAddressLine (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    FormattedMailingAddressLine (const FormattedMailingAddressLine& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

    virtual FormattedMailingAddressLine*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FormattedMailingAddressLine&
    operator= (const FormattedMailingAddressLine& x);

    virtual 
    ~FormattedMailingAddressLine ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class LegalDescriptionCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // LegalDescription
    //
    typedef ::dataadvice::LegalDescription LegalDescription_type;
    typedef ::xsd::cxx::tree::sequence< LegalDescription_type > LegalDescription_sequence;
    typedef LegalDescription_sequence::iterator LegalDescription_iterator;
    typedef LegalDescription_sequence::const_iterator LegalDescription_const_iterator;
    typedef ::xsd::cxx::tree::traits< LegalDescription_type, char > LegalDescription_traits;

    const LegalDescription_sequence&
    LegalDescription () const;

    LegalDescription_sequence&
    LegalDescription ();

    void
    LegalDescription (const LegalDescription_sequence& s);

    // Constructors.
    //
    LegalDescriptionCollection ();

    LegalDescriptionCollection (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    LegalDescriptionCollection (const LegalDescriptionCollection& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual LegalDescriptionCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LegalDescriptionCollection&
    operator= (const LegalDescriptionCollection& x);

    virtual 
    ~LegalDescriptionCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    LegalDescription_sequence LegalDescription_;
  };

  class LegalDescription: public ::dataadvice::FolioItemGroup
  {
    public:
    // FormattedLegalDescription
    //
    typedef ::dataadvice::FolioString1024Item FormattedLegalDescription_type;
    typedef ::xsd::cxx::tree::optional< FormattedLegalDescription_type > FormattedLegalDescription_optional;
    typedef ::xsd::cxx::tree::traits< FormattedLegalDescription_type, char > FormattedLegalDescription_traits;

    const FormattedLegalDescription_optional&
    FormattedLegalDescription () const;

    FormattedLegalDescription_optional&
    FormattedLegalDescription ();

    void
    FormattedLegalDescription (const FormattedLegalDescription_type& x);

    void
    FormattedLegalDescription (const FormattedLegalDescription_optional& x);

    void
    FormattedLegalDescription (::std::unique_ptr< FormattedLegalDescription_type > p);

    // PID
    //
    typedef ::dataadvice::FolioString255Item PID_type;
    typedef ::xsd::cxx::tree::optional< PID_type > PID_optional;
    typedef ::xsd::cxx::tree::traits< PID_type, char > PID_traits;

    const PID_optional&
    PID () const;

    PID_optional&
    PID ();

    void
    PID (const PID_type& x);

    void
    PID (const PID_optional& x);

    void
    PID (::std::unique_ptr< PID_type > p);

    // Lot
    //
    typedef ::dataadvice::FolioString255Item Lot_type;
    typedef ::xsd::cxx::tree::optional< Lot_type > Lot_optional;
    typedef ::xsd::cxx::tree::traits< Lot_type, char > Lot_traits;

    const Lot_optional&
    Lot () const;

    Lot_optional&
    Lot ();

    void
    Lot (const Lot_type& x);

    void
    Lot (const Lot_optional& x);

    void
    Lot (::std::unique_ptr< Lot_type > p);

    // StrataLot
    //
    typedef ::dataadvice::FolioString255Item StrataLot_type;
    typedef ::xsd::cxx::tree::optional< StrataLot_type > StrataLot_optional;
    typedef ::xsd::cxx::tree::traits< StrataLot_type, char > StrataLot_traits;

    const StrataLot_optional&
    StrataLot () const;

    StrataLot_optional&
    StrataLot ();

    void
    StrataLot (const StrataLot_type& x);

    void
    StrataLot (const StrataLot_optional& x);

    void
    StrataLot (::std::unique_ptr< StrataLot_type > p);

    // Parcel
    //
    typedef ::dataadvice::FolioString255Item Parcel_type;
    typedef ::xsd::cxx::tree::optional< Parcel_type > Parcel_optional;
    typedef ::xsd::cxx::tree::traits< Parcel_type, char > Parcel_traits;

    const Parcel_optional&
    Parcel () const;

    Parcel_optional&
    Parcel ();

    void
    Parcel (const Parcel_type& x);

    void
    Parcel (const Parcel_optional& x);

    void
    Parcel (::std::unique_ptr< Parcel_type > p);

    // Block
    //
    typedef ::dataadvice::FolioString255Item Block_type;
    typedef ::xsd::cxx::tree::optional< Block_type > Block_optional;
    typedef ::xsd::cxx::tree::traits< Block_type, char > Block_traits;

    const Block_optional&
    Block () const;

    Block_optional&
    Block ();

    void
    Block (const Block_type& x);

    void
    Block (const Block_optional& x);

    void
    Block (::std::unique_ptr< Block_type > p);

    // SubBlock
    //
    typedef ::dataadvice::FolioString255Item SubBlock_type;
    typedef ::xsd::cxx::tree::optional< SubBlock_type > SubBlock_optional;
    typedef ::xsd::cxx::tree::traits< SubBlock_type, char > SubBlock_traits;

    const SubBlock_optional&
    SubBlock () const;

    SubBlock_optional&
    SubBlock ();

    void
    SubBlock (const SubBlock_type& x);

    void
    SubBlock (const SubBlock_optional& x);

    void
    SubBlock (::std::unique_ptr< SubBlock_type > p);

    // Plan
    //
    typedef ::dataadvice::FolioString255Item Plan_type;
    typedef ::xsd::cxx::tree::optional< Plan_type > Plan_optional;
    typedef ::xsd::cxx::tree::traits< Plan_type, char > Plan_traits;

    const Plan_optional&
    Plan () const;

    Plan_optional&
    Plan ();

    void
    Plan (const Plan_type& x);

    void
    Plan (const Plan_optional& x);

    void
    Plan (::std::unique_ptr< Plan_type > p);

    // SubLot
    //
    typedef ::dataadvice::FolioString255Item SubLot_type;
    typedef ::xsd::cxx::tree::optional< SubLot_type > SubLot_optional;
    typedef ::xsd::cxx::tree::traits< SubLot_type, char > SubLot_traits;

    const SubLot_optional&
    SubLot () const;

    SubLot_optional&
    SubLot ();

    void
    SubLot (const SubLot_type& x);

    void
    SubLot (const SubLot_optional& x);

    void
    SubLot (::std::unique_ptr< SubLot_type > p);

    // Part1
    //
    typedef ::dataadvice::FolioString255Item Part1_type;
    typedef ::xsd::cxx::tree::optional< Part1_type > Part1_optional;
    typedef ::xsd::cxx::tree::traits< Part1_type, char > Part1_traits;

    const Part1_optional&
    Part1 () const;

    Part1_optional&
    Part1 ();

    void
    Part1 (const Part1_type& x);

    void
    Part1 (const Part1_optional& x);

    void
    Part1 (::std::unique_ptr< Part1_type > p);

    // Part2
    //
    typedef ::dataadvice::FolioString255Item Part2_type;
    typedef ::xsd::cxx::tree::optional< Part2_type > Part2_optional;
    typedef ::xsd::cxx::tree::traits< Part2_type, char > Part2_traits;

    const Part2_optional&
    Part2 () const;

    Part2_optional&
    Part2 ();

    void
    Part2 (const Part2_type& x);

    void
    Part2 (const Part2_optional& x);

    void
    Part2 (::std::unique_ptr< Part2_type > p);

    // Part3
    //
    typedef ::dataadvice::FolioString255Item Part3_type;
    typedef ::xsd::cxx::tree::optional< Part3_type > Part3_optional;
    typedef ::xsd::cxx::tree::traits< Part3_type, char > Part3_traits;

    const Part3_optional&
    Part3 () const;

    Part3_optional&
    Part3 ();

    void
    Part3 (const Part3_type& x);

    void
    Part3 (const Part3_optional& x);

    void
    Part3 (::std::unique_ptr< Part3_type > p);

    // Part4
    //
    typedef ::dataadvice::FolioString255Item Part4_type;
    typedef ::xsd::cxx::tree::optional< Part4_type > Part4_optional;
    typedef ::xsd::cxx::tree::traits< Part4_type, char > Part4_traits;

    const Part4_optional&
    Part4 () const;

    Part4_optional&
    Part4 ();

    void
    Part4 (const Part4_type& x);

    void
    Part4 (const Part4_optional& x);

    void
    Part4 (::std::unique_ptr< Part4_type > p);

    // DistrictLot
    //
    typedef ::dataadvice::FolioString255Item DistrictLot_type;
    typedef ::xsd::cxx::tree::optional< DistrictLot_type > DistrictLot_optional;
    typedef ::xsd::cxx::tree::traits< DistrictLot_type, char > DistrictLot_traits;

    const DistrictLot_optional&
    DistrictLot () const;

    DistrictLot_optional&
    DistrictLot ();

    void
    DistrictLot (const DistrictLot_type& x);

    void
    DistrictLot (const DistrictLot_optional& x);

    void
    DistrictLot (::std::unique_ptr< DistrictLot_type > p);

    // LegalSubdivision
    //
    typedef ::dataadvice::FolioString255Item LegalSubdivision_type;
    typedef ::xsd::cxx::tree::optional< LegalSubdivision_type > LegalSubdivision_optional;
    typedef ::xsd::cxx::tree::traits< LegalSubdivision_type, char > LegalSubdivision_traits;

    const LegalSubdivision_optional&
    LegalSubdivision () const;

    LegalSubdivision_optional&
    LegalSubdivision ();

    void
    LegalSubdivision (const LegalSubdivision_type& x);

    void
    LegalSubdivision (const LegalSubdivision_optional& x);

    void
    LegalSubdivision (::std::unique_ptr< LegalSubdivision_type > p);

    // Section
    //
    typedef ::dataadvice::FolioString255Item Section_type;
    typedef ::xsd::cxx::tree::optional< Section_type > Section_optional;
    typedef ::xsd::cxx::tree::traits< Section_type, char > Section_traits;

    const Section_optional&
    Section () const;

    Section_optional&
    Section ();

    void
    Section (const Section_type& x);

    void
    Section (const Section_optional& x);

    void
    Section (::std::unique_ptr< Section_type > p);

    // Township
    //
    typedef ::dataadvice::FolioString255Item Township_type;
    typedef ::xsd::cxx::tree::optional< Township_type > Township_optional;
    typedef ::xsd::cxx::tree::traits< Township_type, char > Township_traits;

    const Township_optional&
    Township () const;

    Township_optional&
    Township ();

    void
    Township (const Township_type& x);

    void
    Township (const Township_optional& x);

    void
    Township (::std::unique_ptr< Township_type > p);

    // Range
    //
    typedef ::dataadvice::FolioString255Item Range_type;
    typedef ::xsd::cxx::tree::optional< Range_type > Range_optional;
    typedef ::xsd::cxx::tree::traits< Range_type, char > Range_traits;

    const Range_optional&
    Range () const;

    Range_optional&
    Range ();

    void
    Range (const Range_type& x);

    void
    Range (const Range_optional& x);

    void
    Range (::std::unique_ptr< Range_type > p);

    // Meridian
    //
    typedef ::dataadvice::FolioString255Item Meridian_type;
    typedef ::xsd::cxx::tree::optional< Meridian_type > Meridian_optional;
    typedef ::xsd::cxx::tree::traits< Meridian_type, char > Meridian_traits;

    const Meridian_optional&
    Meridian () const;

    Meridian_optional&
    Meridian ();

    void
    Meridian (const Meridian_type& x);

    void
    Meridian (const Meridian_optional& x);

    void
    Meridian (::std::unique_ptr< Meridian_type > p);

    // MeridianShort
    //
    typedef ::dataadvice::FolioString255Item MeridianShort_type;
    typedef ::xsd::cxx::tree::optional< MeridianShort_type > MeridianShort_optional;
    typedef ::xsd::cxx::tree::traits< MeridianShort_type, char > MeridianShort_traits;

    const MeridianShort_optional&
    MeridianShort () const;

    MeridianShort_optional&
    MeridianShort ();

    void
    MeridianShort (const MeridianShort_type& x);

    void
    MeridianShort (const MeridianShort_optional& x);

    void
    MeridianShort (::std::unique_ptr< MeridianShort_type > p);

    // BCAGroup
    //
    typedef ::dataadvice::FolioString255Item BCAGroup_type;
    typedef ::xsd::cxx::tree::optional< BCAGroup_type > BCAGroup_optional;
    typedef ::xsd::cxx::tree::traits< BCAGroup_type, char > BCAGroup_traits;

    const BCAGroup_optional&
    BCAGroup () const;

    BCAGroup_optional&
    BCAGroup ();

    void
    BCAGroup (const BCAGroup_type& x);

    void
    BCAGroup (const BCAGroup_optional& x);

    void
    BCAGroup (::std::unique_ptr< BCAGroup_type > p);

    // LandDistrict
    //
    typedef ::dataadvice::FolioString255Item LandDistrict_type;
    typedef ::xsd::cxx::tree::optional< LandDistrict_type > LandDistrict_optional;
    typedef ::xsd::cxx::tree::traits< LandDistrict_type, char > LandDistrict_traits;

    const LandDistrict_optional&
    LandDistrict () const;

    LandDistrict_optional&
    LandDistrict ();

    void
    LandDistrict (const LandDistrict_type& x);

    void
    LandDistrict (const LandDistrict_optional& x);

    void
    LandDistrict (::std::unique_ptr< LandDistrict_type > p);

    // LandDistrictDescription
    //
    typedef ::dataadvice::FolioString255Item LandDistrictDescription_type;
    typedef ::xsd::cxx::tree::optional< LandDistrictDescription_type > LandDistrictDescription_optional;
    typedef ::xsd::cxx::tree::traits< LandDistrictDescription_type, char > LandDistrictDescription_traits;

    const LandDistrictDescription_optional&
    LandDistrictDescription () const;

    LandDistrictDescription_optional&
    LandDistrictDescription ();

    void
    LandDistrictDescription (const LandDistrictDescription_type& x);

    void
    LandDistrictDescription (const LandDistrictDescription_optional& x);

    void
    LandDistrictDescription (::std::unique_ptr< LandDistrictDescription_type > p);

    // Portion
    //
    typedef ::dataadvice::FolioString255Item Portion_type;
    typedef ::xsd::cxx::tree::optional< Portion_type > Portion_optional;
    typedef ::xsd::cxx::tree::traits< Portion_type, char > Portion_traits;

    const Portion_optional&
    Portion () const;

    Portion_optional&
    Portion ();

    void
    Portion (const Portion_type& x);

    void
    Portion (const Portion_optional& x);

    void
    Portion (::std::unique_ptr< Portion_type > p);

    // ExceptPlan
    //
    typedef ::dataadvice::FolioString255Item ExceptPlan_type;
    typedef ::xsd::cxx::tree::optional< ExceptPlan_type > ExceptPlan_optional;
    typedef ::xsd::cxx::tree::traits< ExceptPlan_type, char > ExceptPlan_traits;

    const ExceptPlan_optional&
    ExceptPlan () const;

    ExceptPlan_optional&
    ExceptPlan ();

    void
    ExceptPlan (const ExceptPlan_type& x);

    void
    ExceptPlan (const ExceptPlan_optional& x);

    void
    ExceptPlan (::std::unique_ptr< ExceptPlan_type > p);

    // FirstNationReserveNumber
    //
    typedef ::dataadvice::FolioString255Item FirstNationReserveNumber_type;
    typedef ::xsd::cxx::tree::optional< FirstNationReserveNumber_type > FirstNationReserveNumber_optional;
    typedef ::xsd::cxx::tree::traits< FirstNationReserveNumber_type, char > FirstNationReserveNumber_traits;

    const FirstNationReserveNumber_optional&
    FirstNationReserveNumber () const;

    FirstNationReserveNumber_optional&
    FirstNationReserveNumber ();

    void
    FirstNationReserveNumber (const FirstNationReserveNumber_type& x);

    void
    FirstNationReserveNumber (const FirstNationReserveNumber_optional& x);

    void
    FirstNationReserveNumber (::std::unique_ptr< FirstNationReserveNumber_type > p);

    // FirstNationReserveDescription
    //
    typedef ::dataadvice::FolioString255Item FirstNationReserveDescription_type;
    typedef ::xsd::cxx::tree::optional< FirstNationReserveDescription_type > FirstNationReserveDescription_optional;
    typedef ::xsd::cxx::tree::traits< FirstNationReserveDescription_type, char > FirstNationReserveDescription_traits;

    const FirstNationReserveDescription_optional&
    FirstNationReserveDescription () const;

    FirstNationReserveDescription_optional&
    FirstNationReserveDescription ();

    void
    FirstNationReserveDescription (const FirstNationReserveDescription_type& x);

    void
    FirstNationReserveDescription (const FirstNationReserveDescription_optional& x);

    void
    FirstNationReserveDescription (::std::unique_ptr< FirstNationReserveDescription_type > p);

    // LeaseLicenceNumber
    //
    typedef ::dataadvice::FolioString255Item LeaseLicenceNumber_type;
    typedef ::xsd::cxx::tree::optional< LeaseLicenceNumber_type > LeaseLicenceNumber_optional;
    typedef ::xsd::cxx::tree::traits< LeaseLicenceNumber_type, char > LeaseLicenceNumber_traits;

    const LeaseLicenceNumber_optional&
    LeaseLicenceNumber () const;

    LeaseLicenceNumber_optional&
    LeaseLicenceNumber ();

    void
    LeaseLicenceNumber (const LeaseLicenceNumber_type& x);

    void
    LeaseLicenceNumber (const LeaseLicenceNumber_optional& x);

    void
    LeaseLicenceNumber (::std::unique_ptr< LeaseLicenceNumber_type > p);

    // LandBranchFileNumber
    //
    typedef ::dataadvice::FolioString255Item LandBranchFileNumber_type;
    typedef ::xsd::cxx::tree::optional< LandBranchFileNumber_type > LandBranchFileNumber_optional;
    typedef ::xsd::cxx::tree::traits< LandBranchFileNumber_type, char > LandBranchFileNumber_traits;

    const LandBranchFileNumber_optional&
    LandBranchFileNumber () const;

    LandBranchFileNumber_optional&
    LandBranchFileNumber ();

    void
    LandBranchFileNumber (const LandBranchFileNumber_type& x);

    void
    LandBranchFileNumber (const LandBranchFileNumber_optional& x);

    void
    LandBranchFileNumber (::std::unique_ptr< LandBranchFileNumber_type > p);

    // AirSpaceParcelNumber
    //
    typedef ::dataadvice::FolioString255Item AirSpaceParcelNumber_type;
    typedef ::xsd::cxx::tree::optional< AirSpaceParcelNumber_type > AirSpaceParcelNumber_optional;
    typedef ::xsd::cxx::tree::traits< AirSpaceParcelNumber_type, char > AirSpaceParcelNumber_traits;

    const AirSpaceParcelNumber_optional&
    AirSpaceParcelNumber () const;

    AirSpaceParcelNumber_optional&
    AirSpaceParcelNumber ();

    void
    AirSpaceParcelNumber (const AirSpaceParcelNumber_type& x);

    void
    AirSpaceParcelNumber (const AirSpaceParcelNumber_optional& x);

    void
    AirSpaceParcelNumber (::std::unique_ptr< AirSpaceParcelNumber_type > p);

    // LegalText
    //
    typedef ::dataadvice::FolioString1024Item LegalText_type;
    typedef ::xsd::cxx::tree::optional< LegalText_type > LegalText_optional;
    typedef ::xsd::cxx::tree::traits< LegalText_type, char > LegalText_traits;

    const LegalText_optional&
    LegalText () const;

    LegalText_optional&
    LegalText ();

    void
    LegalText (const LegalText_type& x);

    void
    LegalText (const LegalText_optional& x);

    void
    LegalText (::std::unique_ptr< LegalText_type > p);

    // Constructors.
    //
    LegalDescription ();

    LegalDescription (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    LegalDescription (const LegalDescription& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual LegalDescription*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LegalDescription&
    operator= (const LegalDescription& x);

    virtual 
    ~LegalDescription ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FormattedLegalDescription_optional FormattedLegalDescription_;
    PID_optional PID_;
    Lot_optional Lot_;
    StrataLot_optional StrataLot_;
    Parcel_optional Parcel_;
    Block_optional Block_;
    SubBlock_optional SubBlock_;
    Plan_optional Plan_;
    SubLot_optional SubLot_;
    Part1_optional Part1_;
    Part2_optional Part2_;
    Part3_optional Part3_;
    Part4_optional Part4_;
    DistrictLot_optional DistrictLot_;
    LegalSubdivision_optional LegalSubdivision_;
    Section_optional Section_;
    Township_optional Township_;
    Range_optional Range_;
    Meridian_optional Meridian_;
    MeridianShort_optional MeridianShort_;
    BCAGroup_optional BCAGroup_;
    LandDistrict_optional LandDistrict_;
    LandDistrictDescription_optional LandDistrictDescription_;
    Portion_optional Portion_;
    ExceptPlan_optional ExceptPlan_;
    FirstNationReserveNumber_optional FirstNationReserveNumber_;
    FirstNationReserveDescription_optional FirstNationReserveDescription_;
    LeaseLicenceNumber_optional LeaseLicenceNumber_;
    LandBranchFileNumber_optional LandBranchFileNumber_;
    AirSpaceParcelNumber_optional AirSpaceParcelNumber_;
    LegalText_optional LegalText_;
  };

  class LandCharacteristic: public ::dataadvice::FolioItemGroup
  {
    public:
    // LandCharacteristicCode
    //
    typedef ::dataadvice::FolioLookupCodeItem LandCharacteristicCode_type;
    typedef ::xsd::cxx::tree::optional< LandCharacteristicCode_type > LandCharacteristicCode_optional;
    typedef ::xsd::cxx::tree::traits< LandCharacteristicCode_type, char > LandCharacteristicCode_traits;

    const LandCharacteristicCode_optional&
    LandCharacteristicCode () const;

    LandCharacteristicCode_optional&
    LandCharacteristicCode ();

    void
    LandCharacteristicCode (const LandCharacteristicCode_type& x);

    void
    LandCharacteristicCode (const LandCharacteristicCode_optional& x);

    void
    LandCharacteristicCode (::std::unique_ptr< LandCharacteristicCode_type > p);

    // LandCharacteristicDescription
    //
    typedef ::dataadvice::FolioString255Item LandCharacteristicDescription_type;
    typedef ::xsd::cxx::tree::optional< LandCharacteristicDescription_type > LandCharacteristicDescription_optional;
    typedef ::xsd::cxx::tree::traits< LandCharacteristicDescription_type, char > LandCharacteristicDescription_traits;

    const LandCharacteristicDescription_optional&
    LandCharacteristicDescription () const;

    LandCharacteristicDescription_optional&
    LandCharacteristicDescription ();

    void
    LandCharacteristicDescription (const LandCharacteristicDescription_type& x);

    void
    LandCharacteristicDescription (const LandCharacteristicDescription_optional& x);

    void
    LandCharacteristicDescription (::std::unique_ptr< LandCharacteristicDescription_type > p);

    // Constructors.
    //
    LandCharacteristic ();

    LandCharacteristic (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    LandCharacteristic (const LandCharacteristic& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual LandCharacteristic*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LandCharacteristic&
    operator= (const LandCharacteristic& x);

    virtual 
    ~LandCharacteristic ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    LandCharacteristicCode_optional LandCharacteristicCode_;
    LandCharacteristicDescription_optional LandCharacteristicDescription_;
  };

  class LandCharacteristicCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // LandCharacteristic
    //
    typedef ::dataadvice::LandCharacteristic LandCharacteristic_type;
    typedef ::xsd::cxx::tree::sequence< LandCharacteristic_type > LandCharacteristic_sequence;
    typedef LandCharacteristic_sequence::iterator LandCharacteristic_iterator;
    typedef LandCharacteristic_sequence::const_iterator LandCharacteristic_const_iterator;
    typedef ::xsd::cxx::tree::traits< LandCharacteristic_type, char > LandCharacteristic_traits;

    const LandCharacteristic_sequence&
    LandCharacteristic () const;

    LandCharacteristic_sequence&
    LandCharacteristic ();

    void
    LandCharacteristic (const LandCharacteristic_sequence& s);

    // Constructors.
    //
    LandCharacteristicCollection ();

    LandCharacteristicCollection (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    LandCharacteristicCollection (const LandCharacteristicCollection& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual LandCharacteristicCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LandCharacteristicCollection&
    operator= (const LandCharacteristicCollection& x);

    virtual 
    ~LandCharacteristicCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    LandCharacteristic_sequence LandCharacteristic_;
  };

  class ManufacturedHomeCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // ManufacturedHome
    //
    typedef ::dataadvice::ManufacturedHome ManufacturedHome_type;
    typedef ::xsd::cxx::tree::sequence< ManufacturedHome_type > ManufacturedHome_sequence;
    typedef ManufacturedHome_sequence::iterator ManufacturedHome_iterator;
    typedef ManufacturedHome_sequence::const_iterator ManufacturedHome_const_iterator;
    typedef ::xsd::cxx::tree::traits< ManufacturedHome_type, char > ManufacturedHome_traits;

    const ManufacturedHome_sequence&
    ManufacturedHome () const;

    ManufacturedHome_sequence&
    ManufacturedHome ();

    void
    ManufacturedHome (const ManufacturedHome_sequence& s);

    // Constructors.
    //
    ManufacturedHomeCollection ();

    ManufacturedHomeCollection (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    ManufacturedHomeCollection (const ManufacturedHomeCollection& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

    virtual ManufacturedHomeCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ManufacturedHomeCollection&
    operator= (const ManufacturedHomeCollection& x);

    virtual 
    ~ManufacturedHomeCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ManufacturedHome_sequence ManufacturedHome_;
  };

  class ManufacturedHome: public ::dataadvice::FolioItemGroup
  {
    public:
    // MHRegistryNumber
    //
    typedef ::dataadvice::FolioString255Item MHRegistryNumber_type;
    typedef ::xsd::cxx::tree::optional< MHRegistryNumber_type > MHRegistryNumber_optional;
    typedef ::xsd::cxx::tree::traits< MHRegistryNumber_type, char > MHRegistryNumber_traits;

    const MHRegistryNumber_optional&
    MHRegistryNumber () const;

    MHRegistryNumber_optional&
    MHRegistryNumber ();

    void
    MHRegistryNumber (const MHRegistryNumber_type& x);

    void
    MHRegistryNumber (const MHRegistryNumber_optional& x);

    void
    MHRegistryNumber (::std::unique_ptr< MHRegistryNumber_type > p);

    // MHBayNumber
    //
    typedef ::dataadvice::FolioString255Item MHBayNumber_type;
    typedef ::xsd::cxx::tree::optional< MHBayNumber_type > MHBayNumber_optional;
    typedef ::xsd::cxx::tree::traits< MHBayNumber_type, char > MHBayNumber_traits;

    const MHBayNumber_optional&
    MHBayNumber () const;

    MHBayNumber_optional&
    MHBayNumber ();

    void
    MHBayNumber (const MHBayNumber_type& x);

    void
    MHBayNumber (const MHBayNumber_optional& x);

    void
    MHBayNumber (::std::unique_ptr< MHBayNumber_type > p);

    // MHPark
    //
    typedef ::dataadvice::FolioString255Item MHPark_type;
    typedef ::xsd::cxx::tree::optional< MHPark_type > MHPark_optional;
    typedef ::xsd::cxx::tree::traits< MHPark_type, char > MHPark_traits;

    const MHPark_optional&
    MHPark () const;

    MHPark_optional&
    MHPark ();

    void
    MHPark (const MHPark_type& x);

    void
    MHPark (const MHPark_optional& x);

    void
    MHPark (::std::unique_ptr< MHPark_type > p);

    // MHParkRollNumber
    //
    typedef ::dataadvice::FolioString255Item MHParkRollNumber_type;
    typedef ::xsd::cxx::tree::optional< MHParkRollNumber_type > MHParkRollNumber_optional;
    typedef ::xsd::cxx::tree::traits< MHParkRollNumber_type, char > MHParkRollNumber_traits;

    const MHParkRollNumber_optional&
    MHParkRollNumber () const;

    MHParkRollNumber_optional&
    MHParkRollNumber ();

    void
    MHParkRollNumber (const MHParkRollNumber_type& x);

    void
    MHParkRollNumber (const MHParkRollNumber_optional& x);

    void
    MHParkRollNumber (::std::unique_ptr< MHParkRollNumber_type > p);

    // Constructors.
    //
    ManufacturedHome ();

    ManufacturedHome (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    ManufacturedHome (const ManufacturedHome& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual ManufacturedHome*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ManufacturedHome&
    operator= (const ManufacturedHome& x);

    virtual 
    ~ManufacturedHome ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MHRegistryNumber_optional MHRegistryNumber_;
    MHBayNumber_optional MHBayNumber_;
    MHPark_optional MHPark_;
    MHParkRollNumber_optional MHParkRollNumber_;
  };

  class FarmCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // Farm
    //
    typedef ::dataadvice::Farm Farm_type;
    typedef ::xsd::cxx::tree::sequence< Farm_type > Farm_sequence;
    typedef Farm_sequence::iterator Farm_iterator;
    typedef Farm_sequence::const_iterator Farm_const_iterator;
    typedef ::xsd::cxx::tree::traits< Farm_type, char > Farm_traits;

    const Farm_sequence&
    Farm () const;

    Farm_sequence&
    Farm ();

    void
    Farm (const Farm_sequence& s);

    // Constructors.
    //
    FarmCollection ();

    FarmCollection (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    FarmCollection (const FarmCollection& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual FarmCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FarmCollection&
    operator= (const FarmCollection& x);

    virtual 
    ~FarmCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Farm_sequence Farm_;
  };

  class Farm: public ::dataadvice::FolioItemGroup
  {
    public:
    // FarmNumber
    //
    typedef ::dataadvice::FolioString255Item FarmNumber_type;
    typedef ::xsd::cxx::tree::sequence< FarmNumber_type > FarmNumber_sequence;
    typedef FarmNumber_sequence::iterator FarmNumber_iterator;
    typedef FarmNumber_sequence::const_iterator FarmNumber_const_iterator;
    typedef ::xsd::cxx::tree::traits< FarmNumber_type, char > FarmNumber_traits;

    const FarmNumber_sequence&
    FarmNumber () const;

    FarmNumber_sequence&
    FarmNumber ();

    void
    FarmNumber (const FarmNumber_sequence& s);

    // Constructors.
    //
    Farm ();

    Farm (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Farm (const Farm& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Farm*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Farm&
    operator= (const Farm& x);

    virtual 
    ~Farm ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    FarmNumber_sequence FarmNumber_;
  };

  class OilAndGasCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // OilAndGas
    //
    typedef ::dataadvice::OilAndGas OilAndGas_type;
    typedef ::xsd::cxx::tree::sequence< OilAndGas_type > OilAndGas_sequence;
    typedef OilAndGas_sequence::iterator OilAndGas_iterator;
    typedef OilAndGas_sequence::const_iterator OilAndGas_const_iterator;
    typedef ::xsd::cxx::tree::traits< OilAndGas_type, char > OilAndGas_traits;

    const OilAndGas_sequence&
    OilAndGas () const;

    OilAndGas_sequence&
    OilAndGas ();

    void
    OilAndGas (const OilAndGas_sequence& s);

    // Constructors.
    //
    OilAndGasCollection ();

    OilAndGasCollection (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    OilAndGasCollection (const OilAndGasCollection& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual OilAndGasCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OilAndGasCollection&
    operator= (const OilAndGasCollection& x);

    virtual 
    ~OilAndGasCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OilAndGas_sequence OilAndGas_;
  };

  class OilAndGas: public ::dataadvice::FolioItemGroup
  {
    public:
    // PipelineProjectNumber
    //
    typedef ::dataadvice::FolioString255Item PipelineProjectNumber_type;
    typedef ::xsd::cxx::tree::optional< PipelineProjectNumber_type > PipelineProjectNumber_optional;
    typedef ::xsd::cxx::tree::traits< PipelineProjectNumber_type, char > PipelineProjectNumber_traits;

    const PipelineProjectNumber_optional&
    PipelineProjectNumber () const;

    PipelineProjectNumber_optional&
    PipelineProjectNumber ();

    void
    PipelineProjectNumber (const PipelineProjectNumber_type& x);

    void
    PipelineProjectNumber (const PipelineProjectNumber_optional& x);

    void
    PipelineProjectNumber (::std::unique_ptr< PipelineProjectNumber_type > p);

    // Constructors.
    //
    OilAndGas ();

    OilAndGas (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    OilAndGas (const OilAndGas& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual OilAndGas*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    OilAndGas&
    operator= (const OilAndGas& x);

    virtual 
    ~OilAndGas ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PipelineProjectNumber_optional PipelineProjectNumber_;
  };

  class ManagedForestCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // ManagedForest
    //
    typedef ::dataadvice::ManagedForest ManagedForest_type;
    typedef ::xsd::cxx::tree::sequence< ManagedForest_type > ManagedForest_sequence;
    typedef ManagedForest_sequence::iterator ManagedForest_iterator;
    typedef ManagedForest_sequence::const_iterator ManagedForest_const_iterator;
    typedef ::xsd::cxx::tree::traits< ManagedForest_type, char > ManagedForest_traits;

    const ManagedForest_sequence&
    ManagedForest () const;

    ManagedForest_sequence&
    ManagedForest ();

    void
    ManagedForest (const ManagedForest_sequence& s);

    // Constructors.
    //
    ManagedForestCollection ();

    ManagedForestCollection (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    ManagedForestCollection (const ManagedForestCollection& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual ManagedForestCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ManagedForestCollection&
    operator= (const ManagedForestCollection& x);

    virtual 
    ~ManagedForestCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ManagedForest_sequence ManagedForest_;
  };

  class ManagedForest: public ::dataadvice::FolioItemGroup
  {
    public:
    // ManagedForestNumber
    //
    typedef ::dataadvice::FolioString255Item ManagedForestNumber_type;
    typedef ::xsd::cxx::tree::optional< ManagedForestNumber_type > ManagedForestNumber_optional;
    typedef ::xsd::cxx::tree::traits< ManagedForestNumber_type, char > ManagedForestNumber_traits;

    const ManagedForestNumber_optional&
    ManagedForestNumber () const;

    ManagedForestNumber_optional&
    ManagedForestNumber ();

    void
    ManagedForestNumber (const ManagedForestNumber_type& x);

    void
    ManagedForestNumber (const ManagedForestNumber_optional& x);

    void
    ManagedForestNumber (::std::unique_ptr< ManagedForestNumber_type > p);

    // Constructors.
    //
    ManagedForest ();

    ManagedForest (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    ManagedForest (const ManagedForest& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual ManagedForest*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ManagedForest&
    operator= (const ManagedForest& x);

    virtual 
    ~ManagedForest ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ManagedForestNumber_optional ManagedForestNumber_;
  };

  class FolioAmendmentCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // Amendment
    //
    typedef ::dataadvice::FolioAmendment Amendment_type;
    typedef ::xsd::cxx::tree::sequence< Amendment_type > Amendment_sequence;
    typedef Amendment_sequence::iterator Amendment_iterator;
    typedef Amendment_sequence::const_iterator Amendment_const_iterator;
    typedef ::xsd::cxx::tree::traits< Amendment_type, char > Amendment_traits;

    const Amendment_sequence&
    Amendment () const;

    Amendment_sequence&
    Amendment ();

    void
    Amendment (const Amendment_sequence& s);

    // Constructors.
    //
    FolioAmendmentCollection ();

    FolioAmendmentCollection (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    FolioAmendmentCollection (const FolioAmendmentCollection& x,
                              ::xml_schema::flags f = 0,
                              ::xml_schema::container* c = 0);

    virtual FolioAmendmentCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioAmendmentCollection&
    operator= (const FolioAmendmentCollection& x);

    virtual 
    ~FolioAmendmentCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Amendment_sequence Amendment_;
  };

  class FolioAmendment: public ::dataadvice::FolioItemGroup
  {
    public:
    // AmendmentType
    //
    typedef ::dataadvice::FolioLookupCodeItem AmendmentType_type;
    typedef ::xsd::cxx::tree::optional< AmendmentType_type > AmendmentType_optional;
    typedef ::xsd::cxx::tree::traits< AmendmentType_type, char > AmendmentType_traits;

    const AmendmentType_optional&
    AmendmentType () const;

    AmendmentType_optional&
    AmendmentType ();

    void
    AmendmentType (const AmendmentType_type& x);

    void
    AmendmentType (const AmendmentType_optional& x);

    void
    AmendmentType (::std::unique_ptr< AmendmentType_type > p);

    // AmendmentTypeDescription
    //
    typedef ::dataadvice::FolioString255Item AmendmentTypeDescription_type;
    typedef ::xsd::cxx::tree::optional< AmendmentTypeDescription_type > AmendmentTypeDescription_optional;
    typedef ::xsd::cxx::tree::traits< AmendmentTypeDescription_type, char > AmendmentTypeDescription_traits;

    const AmendmentTypeDescription_optional&
    AmendmentTypeDescription () const;

    AmendmentTypeDescription_optional&
    AmendmentTypeDescription ();

    void
    AmendmentTypeDescription (const AmendmentTypeDescription_type& x);

    void
    AmendmentTypeDescription (const AmendmentTypeDescription_optional& x);

    void
    AmendmentTypeDescription (::std::unique_ptr< AmendmentTypeDescription_type > p);

    // AmendmentReasonCode
    //
    typedef ::dataadvice::FolioLookupCodeItem AmendmentReasonCode_type;
    typedef ::xsd::cxx::tree::optional< AmendmentReasonCode_type > AmendmentReasonCode_optional;
    typedef ::xsd::cxx::tree::traits< AmendmentReasonCode_type, char > AmendmentReasonCode_traits;

    const AmendmentReasonCode_optional&
    AmendmentReasonCode () const;

    AmendmentReasonCode_optional&
    AmendmentReasonCode ();

    void
    AmendmentReasonCode (const AmendmentReasonCode_type& x);

    void
    AmendmentReasonCode (const AmendmentReasonCode_optional& x);

    void
    AmendmentReasonCode (::std::unique_ptr< AmendmentReasonCode_type > p);

    // AmendmentReasonDescription
    //
    typedef ::dataadvice::FolioString255Item AmendmentReasonDescription_type;
    typedef ::xsd::cxx::tree::optional< AmendmentReasonDescription_type > AmendmentReasonDescription_optional;
    typedef ::xsd::cxx::tree::traits< AmendmentReasonDescription_type, char > AmendmentReasonDescription_traits;

    const AmendmentReasonDescription_optional&
    AmendmentReasonDescription () const;

    AmendmentReasonDescription_optional&
    AmendmentReasonDescription ();

    void
    AmendmentReasonDescription (const AmendmentReasonDescription_type& x);

    void
    AmendmentReasonDescription (const AmendmentReasonDescription_optional& x);

    void
    AmendmentReasonDescription (::std::unique_ptr< AmendmentReasonDescription_type > p);

    // SuppOccupancyDate
    //
    typedef ::dataadvice::FolioDateItem SuppOccupancyDate_type;
    typedef ::xsd::cxx::tree::optional< SuppOccupancyDate_type > SuppOccupancyDate_optional;
    typedef ::xsd::cxx::tree::traits< SuppOccupancyDate_type, char > SuppOccupancyDate_traits;

    const SuppOccupancyDate_optional&
    SuppOccupancyDate () const;

    SuppOccupancyDate_optional&
    SuppOccupancyDate ();

    void
    SuppOccupancyDate (const SuppOccupancyDate_type& x);

    void
    SuppOccupancyDate (const SuppOccupancyDate_optional& x);

    void
    SuppOccupancyDate (::std::unique_ptr< SuppOccupancyDate_type > p);

    // SuppOccupancyCode
    //
    typedef ::dataadvice::FolioCharacterItem SuppOccupancyCode_type;
    typedef ::xsd::cxx::tree::optional< SuppOccupancyCode_type > SuppOccupancyCode_optional;
    typedef ::xsd::cxx::tree::traits< SuppOccupancyCode_type, char > SuppOccupancyCode_traits;

    const SuppOccupancyCode_optional&
    SuppOccupancyCode () const;

    SuppOccupancyCode_optional&
    SuppOccupancyCode ();

    void
    SuppOccupancyCode (const SuppOccupancyCode_type& x);

    void
    SuppOccupancyCode (const SuppOccupancyCode_optional& x);

    void
    SuppOccupancyCode (::std::unique_ptr< SuppOccupancyCode_type > p);

    // Constructors.
    //
    FolioAmendment ();

    FolioAmendment (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    FolioAmendment (const FolioAmendment& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual FolioAmendment*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioAmendment&
    operator= (const FolioAmendment& x);

    virtual 
    ~FolioAmendment ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    AmendmentType_optional AmendmentType_;
    AmendmentTypeDescription_optional AmendmentTypeDescription_;
    AmendmentReasonCode_optional AmendmentReasonCode_;
    AmendmentReasonDescription_optional AmendmentReasonDescription_;
    SuppOccupancyDate_optional SuppOccupancyDate_;
    SuppOccupancyCode_optional SuppOccupancyCode_;
  };

  class SaleCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // Sale
    //
    typedef ::dataadvice::Sale Sale_type;
    typedef ::xsd::cxx::tree::sequence< Sale_type > Sale_sequence;
    typedef Sale_sequence::iterator Sale_iterator;
    typedef Sale_sequence::const_iterator Sale_const_iterator;
    typedef ::xsd::cxx::tree::traits< Sale_type, char > Sale_traits;

    const Sale_sequence&
    Sale () const;

    Sale_sequence&
    Sale ();

    void
    Sale (const Sale_sequence& s);

    // Constructors.
    //
    SaleCollection ();

    SaleCollection (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    SaleCollection (const SaleCollection& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual SaleCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SaleCollection&
    operator= (const SaleCollection& x);

    virtual 
    ~SaleCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Sale_sequence Sale_;
  };

  class Sale: public ::dataadvice::FolioItemGroup
  {
    public:
    // DocumentNumber
    //
    typedef ::dataadvice::FolioString255Item DocumentNumber_type;
    typedef ::xsd::cxx::tree::optional< DocumentNumber_type > DocumentNumber_optional;
    typedef ::xsd::cxx::tree::traits< DocumentNumber_type, char > DocumentNumber_traits;

    const DocumentNumber_optional&
    DocumentNumber () const;

    DocumentNumber_optional&
    DocumentNumber ();

    void
    DocumentNumber (const DocumentNumber_type& x);

    void
    DocumentNumber (const DocumentNumber_optional& x);

    void
    DocumentNumber (::std::unique_ptr< DocumentNumber_type > p);

    // ConveyanceDate
    //
    typedef ::dataadvice::FolioDateItem ConveyanceDate_type;
    typedef ::xsd::cxx::tree::optional< ConveyanceDate_type > ConveyanceDate_optional;
    typedef ::xsd::cxx::tree::traits< ConveyanceDate_type, char > ConveyanceDate_traits;

    const ConveyanceDate_optional&
    ConveyanceDate () const;

    ConveyanceDate_optional&
    ConveyanceDate ();

    void
    ConveyanceDate (const ConveyanceDate_type& x);

    void
    ConveyanceDate (const ConveyanceDate_optional& x);

    void
    ConveyanceDate (::std::unique_ptr< ConveyanceDate_type > p);

    // ConveyancePrice
    //
    typedef ::dataadvice::FolioDecimalItem ConveyancePrice_type;
    typedef ::xsd::cxx::tree::optional< ConveyancePrice_type > ConveyancePrice_optional;
    typedef ::xsd::cxx::tree::traits< ConveyancePrice_type, char > ConveyancePrice_traits;

    const ConveyancePrice_optional&
    ConveyancePrice () const;

    ConveyancePrice_optional&
    ConveyancePrice ();

    void
    ConveyancePrice (const ConveyancePrice_type& x);

    void
    ConveyancePrice (const ConveyancePrice_optional& x);

    void
    ConveyancePrice (::std::unique_ptr< ConveyancePrice_type > p);

    // ConveyanceType
    //
    typedef ::dataadvice::FolioLookupCodeItem ConveyanceType_type;
    typedef ::xsd::cxx::tree::optional< ConveyanceType_type > ConveyanceType_optional;
    typedef ::xsd::cxx::tree::traits< ConveyanceType_type, char > ConveyanceType_traits;

    const ConveyanceType_optional&
    ConveyanceType () const;

    ConveyanceType_optional&
    ConveyanceType ();

    void
    ConveyanceType (const ConveyanceType_type& x);

    void
    ConveyanceType (const ConveyanceType_optional& x);

    void
    ConveyanceType (::std::unique_ptr< ConveyanceType_type > p);

    // ConveyanceTypeDescription
    //
    typedef ::dataadvice::FolioString255Item ConveyanceTypeDescription_type;
    typedef ::xsd::cxx::tree::optional< ConveyanceTypeDescription_type > ConveyanceTypeDescription_optional;
    typedef ::xsd::cxx::tree::traits< ConveyanceTypeDescription_type, char > ConveyanceTypeDescription_traits;

    const ConveyanceTypeDescription_optional&
    ConveyanceTypeDescription () const;

    ConveyanceTypeDescription_optional&
    ConveyanceTypeDescription ();

    void
    ConveyanceTypeDescription (const ConveyanceTypeDescription_type& x);

    void
    ConveyanceTypeDescription (const ConveyanceTypeDescription_optional& x);

    void
    ConveyanceTypeDescription (::std::unique_ptr< ConveyanceTypeDescription_type > p);

    // RejectReasonCode
    //
    typedef ::dataadvice::FolioLookupCodeItem RejectReasonCode_type;
    typedef ::xsd::cxx::tree::optional< RejectReasonCode_type > RejectReasonCode_optional;
    typedef ::xsd::cxx::tree::traits< RejectReasonCode_type, char > RejectReasonCode_traits;

    const RejectReasonCode_optional&
    RejectReasonCode () const;

    RejectReasonCode_optional&
    RejectReasonCode ();

    void
    RejectReasonCode (const RejectReasonCode_type& x);

    void
    RejectReasonCode (const RejectReasonCode_optional& x);

    void
    RejectReasonCode (::std::unique_ptr< RejectReasonCode_type > p);

    // RejectReasonDescription
    //
    typedef ::dataadvice::FolioString255Item RejectReasonDescription_type;
    typedef ::xsd::cxx::tree::optional< RejectReasonDescription_type > RejectReasonDescription_optional;
    typedef ::xsd::cxx::tree::traits< RejectReasonDescription_type, char > RejectReasonDescription_traits;

    const RejectReasonDescription_optional&
    RejectReasonDescription () const;

    RejectReasonDescription_optional&
    RejectReasonDescription ();

    void
    RejectReasonDescription (const RejectReasonDescription_type& x);

    void
    RejectReasonDescription (const RejectReasonDescription_optional& x);

    void
    RejectReasonDescription (::std::unique_ptr< RejectReasonDescription_type > p);

    // Constructors.
    //
    Sale ();

    Sale (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    Sale (const Sale& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual Sale*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Sale&
    operator= (const Sale& x);

    virtual 
    ~Sale ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DocumentNumber_optional DocumentNumber_;
    ConveyanceDate_optional ConveyanceDate_;
    ConveyancePrice_optional ConveyancePrice_;
    ConveyanceType_optional ConveyanceType_;
    ConveyanceTypeDescription_optional ConveyanceTypeDescription_;
    RejectReasonCode_optional RejectReasonCode_;
    RejectReasonDescription_optional RejectReasonDescription_;
  };

  class FolioDescription: public ::dataadvice::FolioItemGroup
  {
    public:
    // Neighbourhood
    //
    typedef ::dataadvice::Neighbourhood Neighbourhood_type;
    typedef ::xsd::cxx::tree::optional< Neighbourhood_type > Neighbourhood_optional;
    typedef ::xsd::cxx::tree::traits< Neighbourhood_type, char > Neighbourhood_traits;

    const Neighbourhood_optional&
    Neighbourhood () const;

    Neighbourhood_optional&
    Neighbourhood ();

    void
    Neighbourhood (const Neighbourhood_type& x);

    void
    Neighbourhood (const Neighbourhood_optional& x);

    void
    Neighbourhood (::std::unique_ptr< Neighbourhood_type > p);

    // ActualUseCode
    //
    typedef ::dataadvice::FolioLookupCodeItem ActualUseCode_type;
    typedef ::xsd::cxx::tree::optional< ActualUseCode_type > ActualUseCode_optional;
    typedef ::xsd::cxx::tree::traits< ActualUseCode_type, char > ActualUseCode_traits;

    const ActualUseCode_optional&
    ActualUseCode () const;

    ActualUseCode_optional&
    ActualUseCode ();

    void
    ActualUseCode (const ActualUseCode_type& x);

    void
    ActualUseCode (const ActualUseCode_optional& x);

    void
    ActualUseCode (::std::unique_ptr< ActualUseCode_type > p);

    // ActualUseDescription
    //
    typedef ::dataadvice::FolioString255Item ActualUseDescription_type;
    typedef ::xsd::cxx::tree::optional< ActualUseDescription_type > ActualUseDescription_optional;
    typedef ::xsd::cxx::tree::traits< ActualUseDescription_type, char > ActualUseDescription_traits;

    const ActualUseDescription_optional&
    ActualUseDescription () const;

    ActualUseDescription_optional&
    ActualUseDescription ();

    void
    ActualUseDescription (const ActualUseDescription_type& x);

    void
    ActualUseDescription (const ActualUseDescription_optional& x);

    void
    ActualUseDescription (::std::unique_ptr< ActualUseDescription_type > p);

    // VacantFlag
    //
    typedef ::dataadvice::FolioBooleanItem VacantFlag_type;
    typedef ::xsd::cxx::tree::optional< VacantFlag_type > VacantFlag_optional;
    typedef ::xsd::cxx::tree::traits< VacantFlag_type, char > VacantFlag_traits;

    const VacantFlag_optional&
    VacantFlag () const;

    VacantFlag_optional&
    VacantFlag ();

    void
    VacantFlag (const VacantFlag_type& x);

    void
    VacantFlag (const VacantFlag_optional& x);

    void
    VacantFlag (::std::unique_ptr< VacantFlag_type > p);

    // BCTransitFlag
    //
    typedef ::dataadvice::FolioBooleanItem BCTransitFlag_type;
    typedef ::xsd::cxx::tree::optional< BCTransitFlag_type > BCTransitFlag_optional;
    typedef ::xsd::cxx::tree::traits< BCTransitFlag_type, char > BCTransitFlag_traits;

    const BCTransitFlag_optional&
    BCTransitFlag () const;

    BCTransitFlag_optional&
    BCTransitFlag ();

    void
    BCTransitFlag (const BCTransitFlag_type& x);

    void
    BCTransitFlag (const BCTransitFlag_optional& x);

    void
    BCTransitFlag (::std::unique_ptr< BCTransitFlag_type > p);

    // PoliceTaxFlag
    //
    typedef ::dataadvice::FolioBooleanItem PoliceTaxFlag_type;
    typedef ::xsd::cxx::tree::optional< PoliceTaxFlag_type > PoliceTaxFlag_optional;
    typedef ::xsd::cxx::tree::traits< PoliceTaxFlag_type, char > PoliceTaxFlag_traits;

    const PoliceTaxFlag_optional&
    PoliceTaxFlag () const;

    PoliceTaxFlag_optional&
    PoliceTaxFlag ();

    void
    PoliceTaxFlag (const PoliceTaxFlag_type& x);

    void
    PoliceTaxFlag (const PoliceTaxFlag_optional& x);

    void
    PoliceTaxFlag (::std::unique_ptr< PoliceTaxFlag_type > p);

    // ALRCode
    //
    typedef ::dataadvice::FolioLookupCodeItem ALRCode_type;
    typedef ::xsd::cxx::tree::optional< ALRCode_type > ALRCode_optional;
    typedef ::xsd::cxx::tree::traits< ALRCode_type, char > ALRCode_traits;

    const ALRCode_optional&
    ALRCode () const;

    ALRCode_optional&
    ALRCode ();

    void
    ALRCode (const ALRCode_type& x);

    void
    ALRCode (const ALRCode_optional& x);

    void
    ALRCode (::std::unique_ptr< ALRCode_type > p);

    // ALRDescription
    //
    typedef ::dataadvice::FolioString255Item ALRDescription_type;
    typedef ::xsd::cxx::tree::optional< ALRDescription_type > ALRDescription_optional;
    typedef ::xsd::cxx::tree::traits< ALRDescription_type, char > ALRDescription_traits;

    const ALRDescription_optional&
    ALRDescription () const;

    ALRDescription_optional&
    ALRDescription ();

    void
    ALRDescription (const ALRDescription_type& x);

    void
    ALRDescription (const ALRDescription_optional& x);

    void
    ALRDescription (::std::unique_ptr< ALRDescription_type > p);

    // ParkingArea
    //
    typedef ::dataadvice::FolioString255Item ParkingArea_type;
    typedef ::xsd::cxx::tree::optional< ParkingArea_type > ParkingArea_optional;
    typedef ::xsd::cxx::tree::traits< ParkingArea_type, char > ParkingArea_traits;

    const ParkingArea_optional&
    ParkingArea () const;

    ParkingArea_optional&
    ParkingArea ();

    void
    ParkingArea (const ParkingArea_type& x);

    void
    ParkingArea (const ParkingArea_optional& x);

    void
    ParkingArea (::std::unique_ptr< ParkingArea_type > p);

    // LandMeasurement
    //
    typedef ::dataadvice::LandMeasurement LandMeasurement_type;
    typedef ::xsd::cxx::tree::optional< LandMeasurement_type > LandMeasurement_optional;
    typedef ::xsd::cxx::tree::traits< LandMeasurement_type, char > LandMeasurement_traits;

    const LandMeasurement_optional&
    LandMeasurement () const;

    LandMeasurement_optional&
    LandMeasurement ();

    void
    LandMeasurement (const LandMeasurement_type& x);

    void
    LandMeasurement (const LandMeasurement_optional& x);

    void
    LandMeasurement (::std::unique_ptr< LandMeasurement_type > p);

    // SchoolDistrict
    //
    typedef ::dataadvice::SpecialDistrict SchoolDistrict_type;
    typedef ::xsd::cxx::tree::optional< SchoolDistrict_type > SchoolDistrict_optional;
    typedef ::xsd::cxx::tree::traits< SchoolDistrict_type, char > SchoolDistrict_traits;

    const SchoolDistrict_optional&
    SchoolDistrict () const;

    SchoolDistrict_optional&
    SchoolDistrict ();

    void
    SchoolDistrict (const SchoolDistrict_type& x);

    void
    SchoolDistrict (const SchoolDistrict_optional& x);

    void
    SchoolDistrict (::std::unique_ptr< SchoolDistrict_type > p);

    // RegionalDistrict
    //
    typedef ::dataadvice::SpecialDistrict RegionalDistrict_type;
    typedef ::xsd::cxx::tree::optional< RegionalDistrict_type > RegionalDistrict_optional;
    typedef ::xsd::cxx::tree::traits< RegionalDistrict_type, char > RegionalDistrict_traits;

    const RegionalDistrict_optional&
    RegionalDistrict () const;

    RegionalDistrict_optional&
    RegionalDistrict ();

    void
    RegionalDistrict (const RegionalDistrict_type& x);

    void
    RegionalDistrict (const RegionalDistrict_optional& x);

    void
    RegionalDistrict (::std::unique_ptr< RegionalDistrict_type > p);

    // RegionalHospitalDistrict
    //
    typedef ::dataadvice::SpecialDistrict RegionalHospitalDistrict_type;
    typedef ::xsd::cxx::tree::optional< RegionalHospitalDistrict_type > RegionalHospitalDistrict_optional;
    typedef ::xsd::cxx::tree::traits< RegionalHospitalDistrict_type, char > RegionalHospitalDistrict_traits;

    const RegionalHospitalDistrict_optional&
    RegionalHospitalDistrict () const;

    RegionalHospitalDistrict_optional&
    RegionalHospitalDistrict ();

    void
    RegionalHospitalDistrict (const RegionalHospitalDistrict_type& x);

    void
    RegionalHospitalDistrict (const RegionalHospitalDistrict_optional& x);

    void
    RegionalHospitalDistrict (::std::unique_ptr< RegionalHospitalDistrict_type > p);

    // PredominantManualClass
    //
    typedef ::dataadvice::ManualClass PredominantManualClass_type;
    typedef ::xsd::cxx::tree::optional< PredominantManualClass_type > PredominantManualClass_optional;
    typedef ::xsd::cxx::tree::traits< PredominantManualClass_type, char > PredominantManualClass_traits;

    const PredominantManualClass_optional&
    PredominantManualClass () const;

    PredominantManualClass_optional&
    PredominantManualClass ();

    void
    PredominantManualClass (const PredominantManualClass_type& x);

    void
    PredominantManualClass (const PredominantManualClass_optional& x);

    void
    PredominantManualClass (::std::unique_ptr< PredominantManualClass_type > p);

    // Constructors.
    //
    FolioDescription ();

    FolioDescription (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    FolioDescription (const FolioDescription& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual FolioDescription*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioDescription&
    operator= (const FolioDescription& x);

    virtual 
    ~FolioDescription ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Neighbourhood_optional Neighbourhood_;
    ActualUseCode_optional ActualUseCode_;
    ActualUseDescription_optional ActualUseDescription_;
    VacantFlag_optional VacantFlag_;
    BCTransitFlag_optional BCTransitFlag_;
    PoliceTaxFlag_optional PoliceTaxFlag_;
    ALRCode_optional ALRCode_;
    ALRDescription_optional ALRDescription_;
    ParkingArea_optional ParkingArea_;
    LandMeasurement_optional LandMeasurement_;
    SchoolDistrict_optional SchoolDistrict_;
    RegionalDistrict_optional RegionalDistrict_;
    RegionalHospitalDistrict_optional RegionalHospitalDistrict_;
    PredominantManualClass_optional PredominantManualClass_;
  };

  class LandMeasurement: public ::dataadvice::FolioItemGroup
  {
    public:
    // LandDimensionType
    //
    typedef ::dataadvice::FolioString255Item LandDimensionType_type;
    typedef ::xsd::cxx::tree::optional< LandDimensionType_type > LandDimensionType_optional;
    typedef ::xsd::cxx::tree::traits< LandDimensionType_type, char > LandDimensionType_traits;

    const LandDimensionType_optional&
    LandDimensionType () const;

    LandDimensionType_optional&
    LandDimensionType ();

    void
    LandDimensionType (const LandDimensionType_type& x);

    void
    LandDimensionType (const LandDimensionType_optional& x);

    void
    LandDimensionType (::std::unique_ptr< LandDimensionType_type > p);

    // LandDimensionTypeDescription
    //
    typedef ::dataadvice::FolioString255Item LandDimensionTypeDescription_type;
    typedef ::xsd::cxx::tree::optional< LandDimensionTypeDescription_type > LandDimensionTypeDescription_optional;
    typedef ::xsd::cxx::tree::traits< LandDimensionTypeDescription_type, char > LandDimensionTypeDescription_traits;

    const LandDimensionTypeDescription_optional&
    LandDimensionTypeDescription () const;

    LandDimensionTypeDescription_optional&
    LandDimensionTypeDescription ();

    void
    LandDimensionTypeDescription (const LandDimensionTypeDescription_type& x);

    void
    LandDimensionTypeDescription (const LandDimensionTypeDescription_optional& x);

    void
    LandDimensionTypeDescription (::std::unique_ptr< LandDimensionTypeDescription_type > p);

    // LandDimension
    //
    typedef ::dataadvice::FolioString255Item LandDimension_type;
    typedef ::xsd::cxx::tree::optional< LandDimension_type > LandDimension_optional;
    typedef ::xsd::cxx::tree::traits< LandDimension_type, char > LandDimension_traits;

    const LandDimension_optional&
    LandDimension () const;

    LandDimension_optional&
    LandDimension ();

    void
    LandDimension (const LandDimension_type& x);

    void
    LandDimension (const LandDimension_optional& x);

    void
    LandDimension (::std::unique_ptr< LandDimension_type > p);

    // LandWidth
    //
    typedef ::dataadvice::FolioString255Item LandWidth_type;
    typedef ::xsd::cxx::tree::optional< LandWidth_type > LandWidth_optional;
    typedef ::xsd::cxx::tree::traits< LandWidth_type, char > LandWidth_traits;

    const LandWidth_optional&
    LandWidth () const;

    LandWidth_optional&
    LandWidth ();

    void
    LandWidth (const LandWidth_type& x);

    void
    LandWidth (const LandWidth_optional& x);

    void
    LandWidth (::std::unique_ptr< LandWidth_type > p);

    // LandDepth
    //
    typedef ::dataadvice::FolioString255Item LandDepth_type;
    typedef ::xsd::cxx::tree::optional< LandDepth_type > LandDepth_optional;
    typedef ::xsd::cxx::tree::traits< LandDepth_type, char > LandDepth_traits;

    const LandDepth_optional&
    LandDepth () const;

    LandDepth_optional&
    LandDepth ();

    void
    LandDepth (const LandDepth_type& x);

    void
    LandDepth (const LandDepth_optional& x);

    void
    LandDepth (::std::unique_ptr< LandDepth_type > p);

    // Constructors.
    //
    LandMeasurement ();

    LandMeasurement (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    LandMeasurement (const LandMeasurement& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual LandMeasurement*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    LandMeasurement&
    operator= (const LandMeasurement& x);

    virtual 
    ~LandMeasurement ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    LandDimensionType_optional LandDimensionType_;
    LandDimensionTypeDescription_optional LandDimensionTypeDescription_;
    LandDimension_optional LandDimension_;
    LandWidth_optional LandWidth_;
    LandDepth_optional LandDepth_;
  };

  class Neighbourhood: public ::dataadvice::FolioItemGroup
  {
    public:
    // NeighbourhoodCode
    //
    typedef ::dataadvice::FolioLookupCodeItem NeighbourhoodCode_type;
    typedef ::xsd::cxx::tree::optional< NeighbourhoodCode_type > NeighbourhoodCode_optional;
    typedef ::xsd::cxx::tree::traits< NeighbourhoodCode_type, char > NeighbourhoodCode_traits;

    const NeighbourhoodCode_optional&
    NeighbourhoodCode () const;

    NeighbourhoodCode_optional&
    NeighbourhoodCode ();

    void
    NeighbourhoodCode (const NeighbourhoodCode_type& x);

    void
    NeighbourhoodCode (const NeighbourhoodCode_optional& x);

    void
    NeighbourhoodCode (::std::unique_ptr< NeighbourhoodCode_type > p);

    // NeighbourhoodDescription
    //
    typedef ::dataadvice::FolioString255Item NeighbourhoodDescription_type;
    typedef ::xsd::cxx::tree::optional< NeighbourhoodDescription_type > NeighbourhoodDescription_optional;
    typedef ::xsd::cxx::tree::traits< NeighbourhoodDescription_type, char > NeighbourhoodDescription_traits;

    const NeighbourhoodDescription_optional&
    NeighbourhoodDescription () const;

    NeighbourhoodDescription_optional&
    NeighbourhoodDescription ();

    void
    NeighbourhoodDescription (const NeighbourhoodDescription_type& x);

    void
    NeighbourhoodDescription (const NeighbourhoodDescription_optional& x);

    void
    NeighbourhoodDescription (::std::unique_ptr< NeighbourhoodDescription_type > p);

    // Constructors.
    //
    Neighbourhood ();

    Neighbourhood (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    Neighbourhood (const Neighbourhood& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual Neighbourhood*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Neighbourhood&
    operator= (const Neighbourhood& x);

    virtual 
    ~Neighbourhood ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    NeighbourhoodCode_optional NeighbourhoodCode_;
    NeighbourhoodDescription_optional NeighbourhoodDescription_;
  };

  class SpecialDistrict: public ::dataadvice::FolioItemGroup
  {
    public:
    // DistrictCode
    //
    typedef ::dataadvice::FolioLookupCodeItem DistrictCode_type;
    typedef ::xsd::cxx::tree::optional< DistrictCode_type > DistrictCode_optional;
    typedef ::xsd::cxx::tree::traits< DistrictCode_type, char > DistrictCode_traits;

    const DistrictCode_optional&
    DistrictCode () const;

    DistrictCode_optional&
    DistrictCode ();

    void
    DistrictCode (const DistrictCode_type& x);

    void
    DistrictCode (const DistrictCode_optional& x);

    void
    DistrictCode (::std::unique_ptr< DistrictCode_type > p);

    // DistrictDescription
    //
    typedef ::dataadvice::FolioString255Item DistrictDescription_type;
    typedef ::xsd::cxx::tree::optional< DistrictDescription_type > DistrictDescription_optional;
    typedef ::xsd::cxx::tree::traits< DistrictDescription_type, char > DistrictDescription_traits;

    const DistrictDescription_optional&
    DistrictDescription () const;

    DistrictDescription_optional&
    DistrictDescription ();

    void
    DistrictDescription (const DistrictDescription_type& x);

    void
    DistrictDescription (const DistrictDescription_optional& x);

    void
    DistrictDescription (::std::unique_ptr< DistrictDescription_type > p);

    // Constructors.
    //
    SpecialDistrict ();

    SpecialDistrict (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    SpecialDistrict (const SpecialDistrict& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

    virtual SpecialDistrict*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    SpecialDistrict&
    operator= (const SpecialDistrict& x);

    virtual 
    ~SpecialDistrict ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DistrictCode_optional DistrictCode_;
    DistrictDescription_optional DistrictDescription_;
  };

  class ManualClass: public ::dataadvice::FolioItemGroup
  {
    public:
    // ManualClassCode
    //
    typedef ::dataadvice::FolioLookupCodeItem ManualClassCode_type;
    typedef ::xsd::cxx::tree::optional< ManualClassCode_type > ManualClassCode_optional;
    typedef ::xsd::cxx::tree::traits< ManualClassCode_type, char > ManualClassCode_traits;

    const ManualClassCode_optional&
    ManualClassCode () const;

    ManualClassCode_optional&
    ManualClassCode ();

    void
    ManualClassCode (const ManualClassCode_type& x);

    void
    ManualClassCode (const ManualClassCode_optional& x);

    void
    ManualClassCode (::std::unique_ptr< ManualClassCode_type > p);

    // ManualClassDescription
    //
    typedef ::dataadvice::FolioString255Item ManualClassDescription_type;
    typedef ::xsd::cxx::tree::optional< ManualClassDescription_type > ManualClassDescription_optional;
    typedef ::xsd::cxx::tree::traits< ManualClassDescription_type, char > ManualClassDescription_traits;

    const ManualClassDescription_optional&
    ManualClassDescription () const;

    ManualClassDescription_optional&
    ManualClassDescription ();

    void
    ManualClassDescription (const ManualClassDescription_type& x);

    void
    ManualClassDescription (const ManualClassDescription_optional& x);

    void
    ManualClassDescription (::std::unique_ptr< ManualClassDescription_type > p);

    // PercentDeviation
    //
    typedef ::dataadvice::FolioDecimalItem PercentDeviation_type;
    typedef ::xsd::cxx::tree::optional< PercentDeviation_type > PercentDeviation_optional;
    typedef ::xsd::cxx::tree::traits< PercentDeviation_type, char > PercentDeviation_traits;

    const PercentDeviation_optional&
    PercentDeviation () const;

    PercentDeviation_optional&
    PercentDeviation ();

    void
    PercentDeviation (const PercentDeviation_type& x);

    void
    PercentDeviation (const PercentDeviation_optional& x);

    void
    PercentDeviation (::std::unique_ptr< PercentDeviation_type > p);

    // Constructors.
    //
    ManualClass ();

    ManualClass (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    ManualClass (const ManualClass& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual ManualClass*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ManualClass&
    operator= (const ManualClass& x);

    virtual 
    ~ManualClass ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ManualClassCode_optional ManualClassCode_;
    ManualClassDescription_optional ManualClassDescription_;
    PercentDeviation_optional PercentDeviation_;
  };

  class MinorTaxing: public ::dataadvice::FolioItemGroup
  {
    public:
    // ElectoralAreas
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection ElectoralAreas_type;
    typedef ::xsd::cxx::tree::optional< ElectoralAreas_type > ElectoralAreas_optional;
    typedef ::xsd::cxx::tree::traits< ElectoralAreas_type, char > ElectoralAreas_traits;

    const ElectoralAreas_optional&
    ElectoralAreas () const;

    ElectoralAreas_optional&
    ElectoralAreas ();

    void
    ElectoralAreas (const ElectoralAreas_type& x);

    void
    ElectoralAreas (const ElectoralAreas_optional& x);

    void
    ElectoralAreas (::std::unique_ptr< ElectoralAreas_type > p);

    // ServiceAreas
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection ServiceAreas_type;
    typedef ::xsd::cxx::tree::optional< ServiceAreas_type > ServiceAreas_optional;
    typedef ::xsd::cxx::tree::traits< ServiceAreas_type, char > ServiceAreas_traits;

    const ServiceAreas_optional&
    ServiceAreas () const;

    ServiceAreas_optional&
    ServiceAreas ();

    void
    ServiceAreas (const ServiceAreas_type& x);

    void
    ServiceAreas (const ServiceAreas_optional& x);

    void
    ServiceAreas (::std::unique_ptr< ServiceAreas_type > p);

    // Defined
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection Defined_type;
    typedef ::xsd::cxx::tree::optional< Defined_type > Defined_optional;
    typedef ::xsd::cxx::tree::traits< Defined_type, char > Defined_traits;

    const Defined_optional&
    Defined () const;

    Defined_optional&
    Defined ();

    void
    Defined (const Defined_type& x);

    void
    Defined (const Defined_optional& x);

    void
    Defined (::std::unique_ptr< Defined_type > p);

    // SpecifiedRegional
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection SpecifiedRegional_type;
    typedef ::xsd::cxx::tree::optional< SpecifiedRegional_type > SpecifiedRegional_optional;
    typedef ::xsd::cxx::tree::traits< SpecifiedRegional_type, char > SpecifiedRegional_traits;

    const SpecifiedRegional_optional&
    SpecifiedRegional () const;

    SpecifiedRegional_optional&
    SpecifiedRegional ();

    void
    SpecifiedRegional (const SpecifiedRegional_type& x);

    void
    SpecifiedRegional (const SpecifiedRegional_optional& x);

    void
    SpecifiedRegional (::std::unique_ptr< SpecifiedRegional_type > p);

    // SpecifiedMunicipal
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection SpecifiedMunicipal_type;
    typedef ::xsd::cxx::tree::optional< SpecifiedMunicipal_type > SpecifiedMunicipal_optional;
    typedef ::xsd::cxx::tree::traits< SpecifiedMunicipal_type, char > SpecifiedMunicipal_traits;

    const SpecifiedMunicipal_optional&
    SpecifiedMunicipal () const;

    SpecifiedMunicipal_optional&
    SpecifiedMunicipal ();

    void
    SpecifiedMunicipal (const SpecifiedMunicipal_type& x);

    void
    SpecifiedMunicipal (const SpecifiedMunicipal_optional& x);

    void
    SpecifiedMunicipal (::std::unique_ptr< SpecifiedMunicipal_type > p);

    // LocalAreas
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection LocalAreas_type;
    typedef ::xsd::cxx::tree::optional< LocalAreas_type > LocalAreas_optional;
    typedef ::xsd::cxx::tree::traits< LocalAreas_type, char > LocalAreas_traits;

    const LocalAreas_optional&
    LocalAreas () const;

    LocalAreas_optional&
    LocalAreas ();

    void
    LocalAreas (const LocalAreas_type& x);

    void
    LocalAreas (const LocalAreas_optional& x);

    void
    LocalAreas (::std::unique_ptr< LocalAreas_type > p);

    // GeneralServices
    //
    typedef ::dataadvice::MinorTaxingJurisdiction GeneralServices_type;
    typedef ::xsd::cxx::tree::optional< GeneralServices_type > GeneralServices_optional;
    typedef ::xsd::cxx::tree::traits< GeneralServices_type, char > GeneralServices_traits;

    const GeneralServices_optional&
    GeneralServices () const;

    GeneralServices_optional&
    GeneralServices ();

    void
    GeneralServices (const GeneralServices_type& x);

    void
    GeneralServices (const GeneralServices_optional& x);

    void
    GeneralServices (::std::unique_ptr< GeneralServices_type > p);

    // ImprovementDistricts
    //
    typedef ::dataadvice::MinorTaxingJurisdictionCollection ImprovementDistricts_type;
    typedef ::xsd::cxx::tree::optional< ImprovementDistricts_type > ImprovementDistricts_optional;
    typedef ::xsd::cxx::tree::traits< ImprovementDistricts_type, char > ImprovementDistricts_traits;

    const ImprovementDistricts_optional&
    ImprovementDistricts () const;

    ImprovementDistricts_optional&
    ImprovementDistricts ();

    void
    ImprovementDistricts (const ImprovementDistricts_type& x);

    void
    ImprovementDistricts (const ImprovementDistricts_optional& x);

    void
    ImprovementDistricts (::std::unique_ptr< ImprovementDistricts_type > p);

    // IslandsTrusts
    //
    typedef ::dataadvice::MinorTaxingJurisdiction IslandsTrusts_type;
    typedef ::xsd::cxx::tree::optional< IslandsTrusts_type > IslandsTrusts_optional;
    typedef ::xsd::cxx::tree::traits< IslandsTrusts_type, char > IslandsTrusts_traits;

    const IslandsTrusts_optional&
    IslandsTrusts () const;

    IslandsTrusts_optional&
    IslandsTrusts ();

    void
    IslandsTrusts (const IslandsTrusts_type& x);

    void
    IslandsTrusts (const IslandsTrusts_optional& x);

    void
    IslandsTrusts (::std::unique_ptr< IslandsTrusts_type > p);

    // Constructors.
    //
    MinorTaxing ();

    MinorTaxing (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    MinorTaxing (const MinorTaxing& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual MinorTaxing*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinorTaxing&
    operator= (const MinorTaxing& x);

    virtual 
    ~MinorTaxing ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ElectoralAreas_optional ElectoralAreas_;
    ServiceAreas_optional ServiceAreas_;
    Defined_optional Defined_;
    SpecifiedRegional_optional SpecifiedRegional_;
    SpecifiedMunicipal_optional SpecifiedMunicipal_;
    LocalAreas_optional LocalAreas_;
    GeneralServices_optional GeneralServices_;
    ImprovementDistricts_optional ImprovementDistricts_;
    IslandsTrusts_optional IslandsTrusts_;
  };

  class MinorTaxingJurisdictionCollection: public ::dataadvice::FolioItemGroup
  {
    public:
    // MinorTaxingJurisdiction
    //
    typedef ::dataadvice::MinorTaxingJurisdiction MinorTaxingJurisdiction_type;
    typedef ::xsd::cxx::tree::sequence< MinorTaxingJurisdiction_type > MinorTaxingJurisdiction_sequence;
    typedef MinorTaxingJurisdiction_sequence::iterator MinorTaxingJurisdiction_iterator;
    typedef MinorTaxingJurisdiction_sequence::const_iterator MinorTaxingJurisdiction_const_iterator;
    typedef ::xsd::cxx::tree::traits< MinorTaxingJurisdiction_type, char > MinorTaxingJurisdiction_traits;

    const MinorTaxingJurisdiction_sequence&
    MinorTaxingJurisdiction () const;

    MinorTaxingJurisdiction_sequence&
    MinorTaxingJurisdiction ();

    void
    MinorTaxingJurisdiction (const MinorTaxingJurisdiction_sequence& s);

    // Constructors.
    //
    MinorTaxingJurisdictionCollection ();

    MinorTaxingJurisdictionCollection (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    MinorTaxingJurisdictionCollection (const MinorTaxingJurisdictionCollection& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

    virtual MinorTaxingJurisdictionCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinorTaxingJurisdictionCollection&
    operator= (const MinorTaxingJurisdictionCollection& x);

    virtual 
    ~MinorTaxingJurisdictionCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MinorTaxingJurisdiction_sequence MinorTaxingJurisdiction_;
  };

  class MinorTaxingJurisdiction: public ::dataadvice::FolioItemGroup
  {
    public:
    // MinorTaxingCode
    //
    typedef ::dataadvice::FolioLookupCodeItem MinorTaxingCode_type;
    typedef ::xsd::cxx::tree::optional< MinorTaxingCode_type > MinorTaxingCode_optional;
    typedef ::xsd::cxx::tree::traits< MinorTaxingCode_type, char > MinorTaxingCode_traits;

    const MinorTaxingCode_optional&
    MinorTaxingCode () const;

    MinorTaxingCode_optional&
    MinorTaxingCode ();

    void
    MinorTaxingCode (const MinorTaxingCode_type& x);

    void
    MinorTaxingCode (const MinorTaxingCode_optional& x);

    void
    MinorTaxingCode (::std::unique_ptr< MinorTaxingCode_type > p);

    // MinorTaxingCodeShort
    //
    typedef ::dataadvice::FolioCharacterItem MinorTaxingCodeShort_type;
    typedef ::xsd::cxx::tree::optional< MinorTaxingCodeShort_type > MinorTaxingCodeShort_optional;
    typedef ::xsd::cxx::tree::traits< MinorTaxingCodeShort_type, char > MinorTaxingCodeShort_traits;

    const MinorTaxingCodeShort_optional&
    MinorTaxingCodeShort () const;

    MinorTaxingCodeShort_optional&
    MinorTaxingCodeShort ();

    void
    MinorTaxingCodeShort (const MinorTaxingCodeShort_type& x);

    void
    MinorTaxingCodeShort (const MinorTaxingCodeShort_optional& x);

    void
    MinorTaxingCodeShort (::std::unique_ptr< MinorTaxingCodeShort_type > p);

    // MinorTaxingDescription
    //
    typedef ::dataadvice::FolioString255Item MinorTaxingDescription_type;
    typedef ::xsd::cxx::tree::optional< MinorTaxingDescription_type > MinorTaxingDescription_optional;
    typedef ::xsd::cxx::tree::traits< MinorTaxingDescription_type, char > MinorTaxingDescription_traits;

    const MinorTaxingDescription_optional&
    MinorTaxingDescription () const;

    MinorTaxingDescription_optional&
    MinorTaxingDescription ();

    void
    MinorTaxingDescription (const MinorTaxingDescription_type& x);

    void
    MinorTaxingDescription (const MinorTaxingDescription_optional& x);

    void
    MinorTaxingDescription (::std::unique_ptr< MinorTaxingDescription_type > p);

    // Constructors.
    //
    MinorTaxingJurisdiction ();

    MinorTaxingJurisdiction (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    MinorTaxingJurisdiction (const MinorTaxingJurisdiction& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

    virtual MinorTaxingJurisdiction*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    MinorTaxingJurisdiction&
    operator= (const MinorTaxingJurisdiction& x);

    virtual 
    ~MinorTaxingJurisdiction ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MinorTaxingCode_optional MinorTaxingCode_;
    MinorTaxingCodeShort_optional MinorTaxingCodeShort_;
    MinorTaxingDescription_optional MinorTaxingDescription_;
  };

  class PropertyValues: public ::xml_schema::type
  {
    public:
    // GeneralValues
    //
    typedef ::dataadvice::PropertyClassValuesCollection GeneralValues_type;
    typedef ::xsd::cxx::tree::optional< GeneralValues_type > GeneralValues_optional;
    typedef ::xsd::cxx::tree::traits< GeneralValues_type, char > GeneralValues_traits;

    const GeneralValues_optional&
    GeneralValues () const;

    GeneralValues_optional&
    GeneralValues ();

    void
    GeneralValues (const GeneralValues_type& x);

    void
    GeneralValues (const GeneralValues_optional& x);

    void
    GeneralValues (::std::unique_ptr< GeneralValues_type > p);

    // BCTransitValues
    //
    typedef ::dataadvice::PropertyClassValuesCollection BCTransitValues_type;
    typedef ::xsd::cxx::tree::optional< BCTransitValues_type > BCTransitValues_optional;
    typedef ::xsd::cxx::tree::traits< BCTransitValues_type, char > BCTransitValues_traits;

    const BCTransitValues_optional&
    BCTransitValues () const;

    BCTransitValues_optional&
    BCTransitValues ();

    void
    BCTransitValues (const BCTransitValues_type& x);

    void
    BCTransitValues (const BCTransitValues_optional& x);

    void
    BCTransitValues (::std::unique_ptr< BCTransitValues_type > p);

    // SchoolValues
    //
    typedef ::dataadvice::PropertyClassValuesCollection SchoolValues_type;
    typedef ::xsd::cxx::tree::optional< SchoolValues_type > SchoolValues_optional;
    typedef ::xsd::cxx::tree::traits< SchoolValues_type, char > SchoolValues_traits;

    const SchoolValues_optional&
    SchoolValues () const;

    SchoolValues_optional&
    SchoolValues ();

    void
    SchoolValues (const SchoolValues_type& x);

    void
    SchoolValues (const SchoolValues_optional& x);

    void
    SchoolValues (::std::unique_ptr< SchoolValues_type > p);

    // TaxExemptValues
    //
    typedef ::dataadvice::TaxExemptValuesCollection TaxExemptValues_type;
    typedef ::xsd::cxx::tree::optional< TaxExemptValues_type > TaxExemptValues_optional;
    typedef ::xsd::cxx::tree::traits< TaxExemptValues_type, char > TaxExemptValues_traits;

    const TaxExemptValues_optional&
    TaxExemptValues () const;

    TaxExemptValues_optional&
    TaxExemptValues ();

    void
    TaxExemptValues (const TaxExemptValues_type& x);

    void
    TaxExemptValues (const TaxExemptValues_optional& x);

    void
    TaxExemptValues (::std::unique_ptr< TaxExemptValues_type > p);

    // Constructors.
    //
    PropertyValues ();

    PropertyValues (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    PropertyValues (const PropertyValues& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

    virtual PropertyValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PropertyValues&
    operator= (const PropertyValues& x);

    virtual 
    ~PropertyValues ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    GeneralValues_optional GeneralValues_;
    BCTransitValues_optional BCTransitValues_;
    SchoolValues_optional SchoolValues_;
    TaxExemptValues_optional TaxExemptValues_;
  };

  class TaxExemptValuesCollection: public ::xml_schema::type
  {
    public:
    // TaxExemptPropertyClassValues
    //
    typedef ::dataadvice::TaxExemptPropertyClassValues TaxExemptPropertyClassValues_type;
    typedef ::xsd::cxx::tree::sequence< TaxExemptPropertyClassValues_type > TaxExemptPropertyClassValues_sequence;
    typedef TaxExemptPropertyClassValues_sequence::iterator TaxExemptPropertyClassValues_iterator;
    typedef TaxExemptPropertyClassValues_sequence::const_iterator TaxExemptPropertyClassValues_const_iterator;
    typedef ::xsd::cxx::tree::traits< TaxExemptPropertyClassValues_type, char > TaxExemptPropertyClassValues_traits;

    const TaxExemptPropertyClassValues_sequence&
    TaxExemptPropertyClassValues () const;

    TaxExemptPropertyClassValues_sequence&
    TaxExemptPropertyClassValues ();

    void
    TaxExemptPropertyClassValues (const TaxExemptPropertyClassValues_sequence& s);

    // Constructors.
    //
    TaxExemptValuesCollection ();

    TaxExemptValuesCollection (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    TaxExemptValuesCollection (const TaxExemptValuesCollection& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

    virtual TaxExemptValuesCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TaxExemptValuesCollection&
    operator= (const TaxExemptValuesCollection& x);

    virtual 
    ~TaxExemptValuesCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TaxExemptPropertyClassValues_sequence TaxExemptPropertyClassValues_;
  };

  class TaxExemptPropertyClassValues: public ::xml_schema::type
  {
    public:
    // TaxExemptCode
    //
    typedef ::dataadvice::LookupCode TaxExemptCode_type;
    typedef ::xsd::cxx::tree::traits< TaxExemptCode_type, char > TaxExemptCode_traits;

    const TaxExemptCode_type&
    TaxExemptCode () const;

    TaxExemptCode_type&
    TaxExemptCode ();

    void
    TaxExemptCode (const TaxExemptCode_type& x);

    void
    TaxExemptCode (::std::unique_ptr< TaxExemptCode_type > p);

    // TaxExemptDescription
    //
    typedef ::dataadvice::String255 TaxExemptDescription_type;
    typedef ::xsd::cxx::tree::optional< TaxExemptDescription_type > TaxExemptDescription_optional;
    typedef ::xsd::cxx::tree::traits< TaxExemptDescription_type, char > TaxExemptDescription_traits;

    const TaxExemptDescription_optional&
    TaxExemptDescription () const;

    TaxExemptDescription_optional&
    TaxExemptDescription ();

    void
    TaxExemptDescription (const TaxExemptDescription_type& x);

    void
    TaxExemptDescription (const TaxExemptDescription_optional& x);

    void
    TaxExemptDescription (::std::unique_ptr< TaxExemptDescription_type > p);

    // PropertyClassCode
    //
    typedef ::dataadvice::PropertyClassCode PropertyClassCode_type;
    typedef ::xsd::cxx::tree::traits< PropertyClassCode_type, char > PropertyClassCode_traits;

    const PropertyClassCode_type&
    PropertyClassCode () const;

    PropertyClassCode_type&
    PropertyClassCode ();

    void
    PropertyClassCode (const PropertyClassCode_type& x);

    void
    PropertyClassCode (::std::unique_ptr< PropertyClassCode_type > p);

    // PropertyClassDescription
    //
    typedef ::dataadvice::String255 PropertyClassDescription_type;
    typedef ::xsd::cxx::tree::optional< PropertyClassDescription_type > PropertyClassDescription_optional;
    typedef ::xsd::cxx::tree::traits< PropertyClassDescription_type, char > PropertyClassDescription_traits;

    const PropertyClassDescription_optional&
    PropertyClassDescription () const;

    PropertyClassDescription_optional&
    PropertyClassDescription ();

    void
    PropertyClassDescription (const PropertyClassDescription_type& x);

    void
    PropertyClassDescription (const PropertyClassDescription_optional& x);

    void
    PropertyClassDescription (::std::unique_ptr< PropertyClassDescription_type > p);

    // LandValue
    //
    typedef ::xml_schema::decimal LandValue_type;
    typedef ::xsd::cxx::tree::traits< LandValue_type, char, ::xsd::cxx::tree::schema_type::decimal > LandValue_traits;

    const LandValue_type&
    LandValue () const;

    LandValue_type&
    LandValue ();

    void
    LandValue (const LandValue_type& x);

    // ImprovementValue
    //
    typedef ::xml_schema::decimal ImprovementValue_type;
    typedef ::xsd::cxx::tree::traits< ImprovementValue_type, char, ::xsd::cxx::tree::schema_type::decimal > ImprovementValue_traits;

    const ImprovementValue_type&
    ImprovementValue () const;

    ImprovementValue_type&
    ImprovementValue ();

    void
    ImprovementValue (const ImprovementValue_type& x);

    // Constructors.
    //
    TaxExemptPropertyClassValues (const TaxExemptCode_type&,
                                  const PropertyClassCode_type&,
                                  const LandValue_type&,
                                  const ImprovementValue_type&);

    TaxExemptPropertyClassValues (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    TaxExemptPropertyClassValues (const TaxExemptPropertyClassValues& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

    virtual TaxExemptPropertyClassValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    TaxExemptPropertyClassValues&
    operator= (const TaxExemptPropertyClassValues& x);

    virtual 
    ~TaxExemptPropertyClassValues ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< TaxExemptCode_type > TaxExemptCode_;
    TaxExemptDescription_optional TaxExemptDescription_;
    ::xsd::cxx::tree::one< PropertyClassCode_type > PropertyClassCode_;
    PropertyClassDescription_optional PropertyClassDescription_;
    ::xsd::cxx::tree::one< LandValue_type > LandValue_;
    ::xsd::cxx::tree::one< ImprovementValue_type > ImprovementValue_;
  };

  class PropertyClassValuesCollection: public ::xml_schema::type
  {
    public:
    // PropertyClassValues
    //
    typedef ::dataadvice::PropertyClassValues PropertyClassValues_type;
    typedef ::xsd::cxx::tree::sequence< PropertyClassValues_type > PropertyClassValues_sequence;
    typedef PropertyClassValues_sequence::iterator PropertyClassValues_iterator;
    typedef PropertyClassValues_sequence::const_iterator PropertyClassValues_const_iterator;
    typedef ::xsd::cxx::tree::traits< PropertyClassValues_type, char > PropertyClassValues_traits;

    const PropertyClassValues_sequence&
    PropertyClassValues () const;

    PropertyClassValues_sequence&
    PropertyClassValues ();

    void
    PropertyClassValues (const PropertyClassValues_sequence& s);

    // Constructors.
    //
    PropertyClassValuesCollection ();

    PropertyClassValuesCollection (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    PropertyClassValuesCollection (const PropertyClassValuesCollection& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

    virtual PropertyClassValuesCollection*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PropertyClassValuesCollection&
    operator= (const PropertyClassValuesCollection& x);

    virtual 
    ~PropertyClassValuesCollection ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    PropertyClassValues_sequence PropertyClassValues_;
  };

  class PropertyClassValues: public ::xml_schema::type
  {
    public:
    // PropertyClassCode
    //
    typedef ::dataadvice::PropertyClassCode PropertyClassCode_type;
    typedef ::xsd::cxx::tree::traits< PropertyClassCode_type, char > PropertyClassCode_traits;

    const PropertyClassCode_type&
    PropertyClassCode () const;

    PropertyClassCode_type&
    PropertyClassCode ();

    void
    PropertyClassCode (const PropertyClassCode_type& x);

    void
    PropertyClassCode (::std::unique_ptr< PropertyClassCode_type > p);

    // PropertyClassDescription
    //
    typedef ::dataadvice::String255 PropertyClassDescription_type;
    typedef ::xsd::cxx::tree::optional< PropertyClassDescription_type > PropertyClassDescription_optional;
    typedef ::xsd::cxx::tree::traits< PropertyClassDescription_type, char > PropertyClassDescription_traits;

    const PropertyClassDescription_optional&
    PropertyClassDescription () const;

    PropertyClassDescription_optional&
    PropertyClassDescription ();

    void
    PropertyClassDescription (const PropertyClassDescription_type& x);

    void
    PropertyClassDescription (const PropertyClassDescription_optional& x);

    void
    PropertyClassDescription (::std::unique_ptr< PropertyClassDescription_type > p);

    // PropertySubClassCode
    //
    typedef ::dataadvice::PropertySubClassCode PropertySubClassCode_type;
    typedef ::xsd::cxx::tree::optional< PropertySubClassCode_type > PropertySubClassCode_optional;
    typedef ::xsd::cxx::tree::traits< PropertySubClassCode_type, char > PropertySubClassCode_traits;

    const PropertySubClassCode_optional&
    PropertySubClassCode () const;

    PropertySubClassCode_optional&
    PropertySubClassCode ();

    void
    PropertySubClassCode (const PropertySubClassCode_type& x);

    void
    PropertySubClassCode (const PropertySubClassCode_optional& x);

    void
    PropertySubClassCode (::std::unique_ptr< PropertySubClassCode_type > p);

    // PropertySubClassDescription
    //
    typedef ::dataadvice::String255 PropertySubClassDescription_type;
    typedef ::xsd::cxx::tree::optional< PropertySubClassDescription_type > PropertySubClassDescription_optional;
    typedef ::xsd::cxx::tree::traits< PropertySubClassDescription_type, char > PropertySubClassDescription_traits;

    const PropertySubClassDescription_optional&
    PropertySubClassDescription () const;

    PropertySubClassDescription_optional&
    PropertySubClassDescription ();

    void
    PropertySubClassDescription (const PropertySubClassDescription_type& x);

    void
    PropertySubClassDescription (const PropertySubClassDescription_optional& x);

    void
    PropertySubClassDescription (::std::unique_ptr< PropertySubClassDescription_type > p);

    // GrossValues
    //
    typedef ::dataadvice::Valuation GrossValues_type;
    typedef ::xsd::cxx::tree::optional< GrossValues_type > GrossValues_optional;
    typedef ::xsd::cxx::tree::traits< GrossValues_type, char > GrossValues_traits;

    const GrossValues_optional&
    GrossValues () const;

    GrossValues_optional&
    GrossValues ();

    void
    GrossValues (const GrossValues_type& x);

    void
    GrossValues (const GrossValues_optional& x);

    void
    GrossValues (::std::unique_ptr< GrossValues_type > p);

    // TaxExemptValues
    //
    typedef ::dataadvice::Valuation TaxExemptValues_type;
    typedef ::xsd::cxx::tree::optional< TaxExemptValues_type > TaxExemptValues_optional;
    typedef ::xsd::cxx::tree::traits< TaxExemptValues_type, char > TaxExemptValues_traits;

    const TaxExemptValues_optional&
    TaxExemptValues () const;

    TaxExemptValues_optional&
    TaxExemptValues ();

    void
    TaxExemptValues (const TaxExemptValues_type& x);

    void
    TaxExemptValues (const TaxExemptValues_optional& x);

    void
    TaxExemptValues (::std::unique_ptr< TaxExemptValues_type > p);

    // NetValues
    //
    typedef ::dataadvice::Valuation NetValues_type;
    typedef ::xsd::cxx::tree::optional< NetValues_type > NetValues_optional;
    typedef ::xsd::cxx::tree::traits< NetValues_type, char > NetValues_traits;

    const NetValues_optional&
    NetValues () const;

    NetValues_optional&
    NetValues ();

    void
    NetValues (const NetValues_type& x);

    void
    NetValues (const NetValues_optional& x);

    void
    NetValues (::std::unique_ptr< NetValues_type > p);

    // Constructors.
    //
    PropertyClassValues (const PropertyClassCode_type&);

    PropertyClassValues (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    PropertyClassValues (const PropertyClassValues& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual PropertyClassValues*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    PropertyClassValues&
    operator= (const PropertyClassValues& x);

    virtual 
    ~PropertyClassValues ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< PropertyClassCode_type > PropertyClassCode_;
    PropertyClassDescription_optional PropertyClassDescription_;
    PropertySubClassCode_optional PropertySubClassCode_;
    PropertySubClassDescription_optional PropertySubClassDescription_;
    GrossValues_optional GrossValues_;
    TaxExemptValues_optional TaxExemptValues_;
    NetValues_optional NetValues_;
  };

  class PropertyClassCode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    PropertyClassCode ();

    PropertyClassCode (const char*);

    PropertyClassCode (const ::std::string&);

    PropertyClassCode (const ::xml_schema::string&);

    PropertyClassCode (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    PropertyClassCode (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    PropertyClassCode (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    PropertyClassCode (const PropertyClassCode& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual PropertyClassCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PropertyClassCode ();
  };

  class PropertySubClassCode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    PropertySubClassCode ();

    PropertySubClassCode (const char*);

    PropertySubClassCode (const ::std::string&);

    PropertySubClassCode (const ::xml_schema::string&);

    PropertySubClassCode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    PropertySubClassCode (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    PropertySubClassCode (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    PropertySubClassCode (const PropertySubClassCode& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

    virtual PropertySubClassCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PropertySubClassCode ();
  };

  class Valuation: public ::xml_schema::type
  {
    public:
    // LandValue
    //
    typedef ::xml_schema::decimal LandValue_type;
    typedef ::xsd::cxx::tree::traits< LandValue_type, char, ::xsd::cxx::tree::schema_type::decimal > LandValue_traits;

    const LandValue_type&
    LandValue () const;

    LandValue_type&
    LandValue ();

    void
    LandValue (const LandValue_type& x);

    // ImprovementValue
    //
    typedef ::xml_schema::decimal ImprovementValue_type;
    typedef ::xsd::cxx::tree::traits< ImprovementValue_type, char, ::xsd::cxx::tree::schema_type::decimal > ImprovementValue_traits;

    const ImprovementValue_type&
    ImprovementValue () const;

    ImprovementValue_type&
    ImprovementValue ();

    void
    ImprovementValue (const ImprovementValue_type& x);

    // Constructors.
    //
    Valuation (const LandValue_type&,
               const ImprovementValue_type&);

    Valuation (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Valuation (const Valuation& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Valuation*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    Valuation&
    operator= (const Valuation& x);

    virtual 
    ~Valuation ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< LandValue_type > LandValue_;
    ::xsd::cxx::tree::one< ImprovementValue_type > ImprovementValue_;
  };

  class FolioIntegerItem: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::xml_schema::integer OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    // Constructors.
    //
    FolioIntegerItem (const ::xml_schema::integer&);

    FolioIntegerItem (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    FolioIntegerItem (const FolioIntegerItem& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual FolioIntegerItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioIntegerItem&
    operator= (const FolioIntegerItem& x);

    virtual 
    ~FolioIntegerItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class FolioBooleanItem: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type >
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::xml_schema::boolean OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    // Constructors.
    //
    FolioBooleanItem (const ::xml_schema::boolean&);

    FolioBooleanItem (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    FolioBooleanItem (const FolioBooleanItem& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual FolioBooleanItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioBooleanItem&
    operator= (const FolioBooleanItem& x);

    virtual 
    ~FolioBooleanItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class FolioDecimalItem: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::xml_schema::decimal OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char, ::xsd::cxx::tree::schema_type::decimal > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    // Constructors.
    //
    FolioDecimalItem (const ::xml_schema::decimal&);

    FolioDecimalItem (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    FolioDecimalItem (const FolioDecimalItem& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

    virtual FolioDecimalItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioDecimalItem&
    operator= (const FolioDecimalItem& x);

    virtual 
    ~FolioDecimalItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class FolioDateItem: public ::xml_schema::date
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::xml_schema::date OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioDateItem (const ::xml_schema::date&);

    FolioDateItem (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    FolioDateItem (const FolioDateItem& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

    virtual FolioDateItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioDateItem&
    operator= (const FolioDateItem& x);

    virtual 
    ~FolioDateItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class UniqueID: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    UniqueID ();

    UniqueID (const char*);

    UniqueID (const ::std::string&);

    UniqueID (const ::xml_schema::string&);

    UniqueID (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    UniqueID (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    UniqueID (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    UniqueID (const UniqueID& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual UniqueID*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~UniqueID ();
  };

  class FolioUniqueIDItem: public ::dataadvice::UniqueID
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::UniqueID OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioUniqueIDItem ();

    FolioUniqueIDItem (const char*);

    FolioUniqueIDItem (const ::std::string&);

    FolioUniqueIDItem (const ::xml_schema::string&);

    FolioUniqueIDItem (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    FolioUniqueIDItem (const FolioUniqueIDItem& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

    virtual FolioUniqueIDItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioUniqueIDItem&
    operator= (const FolioUniqueIDItem& x);

    virtual 
    ~FolioUniqueIDItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class LookupCode: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    LookupCode ();

    LookupCode (const char*);

    LookupCode (const ::std::string&);

    LookupCode (const ::xml_schema::string&);

    LookupCode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    LookupCode (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    LookupCode (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    LookupCode (const LookupCode& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual LookupCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~LookupCode ();
  };

  class FolioLookupCodeItem: public ::dataadvice::LookupCode
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::LookupCode OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioLookupCodeItem ();

    FolioLookupCodeItem (const char*);

    FolioLookupCodeItem (const ::std::string&);

    FolioLookupCodeItem (const ::xml_schema::string&);

    FolioLookupCodeItem (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    FolioLookupCodeItem (const FolioLookupCodeItem& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual FolioLookupCodeItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioLookupCodeItem&
    operator= (const FolioLookupCodeItem& x);

    virtual 
    ~FolioLookupCodeItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class Character: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    Character ();

    Character (const char*);

    Character (const ::std::string&);

    Character (const ::xml_schema::string&);

    Character (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Character (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Character (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    Character (const Character& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual Character*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~Character ();
  };

  class FolioCharacterItem: public ::dataadvice::Character
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::Character OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioCharacterItem ();

    FolioCharacterItem (const char*);

    FolioCharacterItem (const ::std::string&);

    FolioCharacterItem (const ::xml_schema::string&);

    FolioCharacterItem (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    FolioCharacterItem (const FolioCharacterItem& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual FolioCharacterItem*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioCharacterItem&
    operator= (const FolioCharacterItem& x);

    virtual 
    ~FolioCharacterItem ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class String255: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    String255 ();

    String255 (const char*);

    String255 (const ::std::string&);

    String255 (const ::xml_schema::string&);

    String255 (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    String255 (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    String255 (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    String255 (const String255& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual String255*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~String255 ();
  };

  class FolioString255Item: public ::dataadvice::String255
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::String255 OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioString255Item ();

    FolioString255Item (const char*);

    FolioString255Item (const ::std::string&);

    FolioString255Item (const ::xml_schema::string&);

    FolioString255Item (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    FolioString255Item (const FolioString255Item& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

    virtual FolioString255Item*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioString255Item&
    operator= (const FolioString255Item& x);

    virtual 
    ~FolioString255Item ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class String1024: public ::xml_schema::string
  {
    public:
    // Constructors.
    //
    String1024 ();

    String1024 (const char*);

    String1024 (const ::std::string&);

    String1024 (const ::xml_schema::string&);

    String1024 (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    String1024 (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    String1024 (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    String1024 (const String1024& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual String1024*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~String1024 ();
  };

  class FolioString1024Item: public ::dataadvice::String1024
  {
    public:
    // Action
    //
    typedef ::dataadvice::ActionCode Action_type;
    typedef ::xsd::cxx::tree::optional< Action_type > Action_optional;
    typedef ::xsd::cxx::tree::traits< Action_type, char > Action_traits;

    const Action_optional&
    Action () const;

    Action_optional&
    Action ();

    void
    Action (const Action_type& x);

    void
    Action (const Action_optional& x);

    void
    Action (::std::unique_ptr< Action_type > p);

    // OldValue
    //
    typedef ::dataadvice::String1024 OldValue_type;
    typedef ::xsd::cxx::tree::optional< OldValue_type > OldValue_optional;
    typedef ::xsd::cxx::tree::traits< OldValue_type, char > OldValue_traits;

    const OldValue_optional&
    OldValue () const;

    OldValue_optional&
    OldValue ();

    void
    OldValue (const OldValue_type& x);

    void
    OldValue (const OldValue_optional& x);

    void
    OldValue (::std::unique_ptr< OldValue_type > p);

    // Constructors.
    //
    FolioString1024Item ();

    FolioString1024Item (const char*);

    FolioString1024Item (const ::std::string&);

    FolioString1024Item (const ::xml_schema::string&);

    FolioString1024Item (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    FolioString1024Item (const FolioString1024Item& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

    virtual FolioString1024Item*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    FolioString1024Item&
    operator= (const FolioString1024Item& x);

    virtual 
    ~FolioString1024Item ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    Action_optional Action_;
    OldValue_optional OldValue_;
  };

  class ActionCode: public ::xml_schema::string
  {
    public:
    enum value
    {
      Add,
      Change,
      Delete
    };

    ActionCode (value v);

    ActionCode (const char* v);

    ActionCode (const ::std::string& v);

    ActionCode (const ::xml_schema::string& v);

    ActionCode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ActionCode (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ActionCode (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    ActionCode (const ActionCode& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

    virtual ActionCode*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    ActionCode&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_ActionCode_convert ();
    }

    protected:
    value
    _xsd_ActionCode_convert () const;

    public:
    static const char* const _xsd_ActionCode_literals_[3];
    static const value _xsd_ActionCode_indexes_[3];
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace dataadvice
{
  // Parse a URI or a local file.
  //

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::std::string& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::std::string& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::std::string& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               const ::std::string& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::std::istream& is,
               const ::std::string& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::unique_ptr< ::dataadvice::DataAdvice >
  DataAdvice_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // E__WORKSPACE_PROJECTS_NEW_BCAAREADER_NATIVE_BCAA_IMPORTER2_DATA_ADVICE_HXX
